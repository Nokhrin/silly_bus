### 3. Списки и карты: Работа с коллекциями

[источник](https://github.com/gochaorg/blog/blob/master/itdocs/learn-java/01-proc.md#3-Списки-и-карты-Работа-с-коллекциями)

**Цель**: Хранить данные в `List` и `Map` (без углубления в ООП).

**Задания** (используют методы из п.2):

1. Найдите максимум и среднее в списке/массиве числе.
   - числа могут быть любые и сколько их в массиве не известно.

[реализация](ArrayOps.java)

#### уточнение требований
- параметры функции: функция принимает список или массив?
- какой результат ожидаем для пустого массива?
  - ноль?
  - ошибка?
- параметры функции: гарантируется ли гомогенность / что все элементы одного типа?
  - функция принимает `int[]`?
  - функция принимает `Integer[]`?
  - функция принимает `Object[]`?
- какое поведение ожидаем при обработке списка элементов смешанных типов?
  - обрабатываем все числа любых типов?
    - byte & int & double & float
  - обрабатываем все числа определенного типа?
    - byte | int | double | float
  - возможное решение - выделить функции для каждого типа
    - getMaxOfInts, getMaxOfFloats и тд
- какой тип возвращаемого значения функции?
  - `double`?
  - строка определенного формата?
    - какой формат?
    - например, сколько знаков после точки отображать

‼
- до уточнения
  - реализую обработку параметра типа `ArrayList<Object>`
  - полагаю непустой список обязательным параметром
  - валидацию аргументов реализую отдельным методом
  - привожу все числовые типы к `double`
  - реализую возвращаемое значение в виде строки `#.##`

#### рассуждения
- реализовал в виде статических методов по причинам:
  - нет задачи хранить состояние => не надо создавать объект => экономия памяти
  - легче понять структуру => меньше когнитивная нагрузка => дешевле поддерживать/развивать
- исходя из `числа могут быть любые и сколько их в массиве не известно` полагаю,
  - что передается массив произвольного размера
  - массив содержит объекты произвольного типа
  - применяю реализацию `ArrayList` интерфейса `List`, в свою очередь реализующего интерфейс `Collection`
    - цепочка наследования: `ArrayList` -> `List` -> `Collection` -> `Iterable`

---

2. Создайте `Map<String, Integer>` для пар «имя → возраст».

#### уточнение требований
- требуется создать интерфейс для хранения?
  - или метод, выполняющий запись значений в `Map`?
- в каком формате поступают значения `имя`, `возраст`?
  - по отдельности - строкой и числом соответственно?
  - по отдельности - строкой и строкой соответственно?
  - одной строкой с использованием разделителя?
    - какой разделитель?
- требуется ли сохранять порядок сортировки?
  - какой порядок сортировки требуется?
    - по алфавиту - по возрастанию значения поля `имя`?
    - по возрастанию значения поля `возраст`?
    - иначе?
- требуется ли записывать сформированный `Map` на диск?


---

## источники, которые помогли разобраться
https://www.baeldung.com/java-list-interface


## чему я научился
- понятия:
  - примитив
  - объект
  - коллекция примитивов / объектов
- ArrayList - динамический (то есть позволяющий объявлять массив, не указывая количество элементов) массив в Java
  - с примитивами работает только посредством обертки
  - аналог `list` в Python
- получать текстовое представление `int[]`
- представление о коллекциях
- преобразования `массив примитивов` -> `коллекция`
  - только со шпаргалкой, концепт не усвоил
- применять интерфейс `java.util.Map`
  - создал множества и отображения
- работать с группой типов в параметрах функции
  - когда гарантируется, что на вход передается число, но не уточняется подтип числа
  - то же для возвращаемого значения
- поверхностно попробовал `generic` при объявлении методов
  - `public static String getAvgValue(ArrayList<?> list)`


## вопросы
- в каком случае применять массив примитивов (например, `int[]`), в каком - массив объектов (например, `Integer[]`)?
  - есть ли ситуации, в которых следует держаться примитивов?
    - То есть, в которых `int[]` лучше, чем  `Integer[]`
  - есть ли ситуации, когда объекты предпочтительнее?

- следует ли указывать тип элемента в <> инициализатора?
  - `ArrayList<Integer> listOfInts = new ArrayList<Integer>(Arrays.asList(1, 2, 3, 4, 5));` или
  - `ArrayList<Integer> listOfInts = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));` ?

#### **Контрольные вопросы**:
- ❓ Почему `map.get("Alex")` вернет `null` для ключа `"alex"`?
  - ключи словаря/мапы регистрочуствительны, так как завязаны на результат вычисления хэш-функции
    - `"alex"` и `"Alex"` имеют разные хэши
    - для несуществующего ключа метод `get` по умолчанию возвращает `null`
- ❓ Как удалить дубликаты через `new HashSet<>(list)`?
  - HashSet - имплементирует математическое множество, в нем по определению нет дубликатов

