# Типизированное лямбда-исчисление

## Цели изучения
- лямбды в терминологии математики
  1) свободные и связанные переменные
  2) аппликация и абстракция
  3) типизация

- понять синтаксис
  1) функциональные интерфейсы
  2) стандартные интерфейсы Function, Consumer, Supplier BiFunction, BiConsumer
  3) лямбды вида Function< Function< Function< A, B>, C>, D> - т.е. вложенность



## Материалы
[Системы типизации лямбда-исчисления - Москвин](https://www.lektorium.tv/lecture/13181)
[Герман Геверс - Введение в теорию типов](https://www.karlin.mff.cuni.cz/~krajicek/geuvers.pdf)

## Система типов
- общее: совокупность правил, назначающих свойства, именуемые типами, конструкциям, составляющим программу - переменным, выражениям, функциям, модулям
- по Пирсу: разрешимый **синтаксический** метод доказательства отсутствия некоторых поведений программы путем классификации конструкций в соответствии с видами вычисляемых значений
  - важно - синтаксический характер типов

лямбда-исчисление - одна из моделей вычисления - процесса редукции
лямбда-термы - выражения / синтаксические объекты лямбда-исчисления

## Цели типизации
- задать спецификацию программы
  - тип задает требования к термам
- типизированные программы ведут себя предсказуемым образом
- типизированные программы всегда завершаются
- система типов отлавливает ошибки программы

## Лямбда-абстракция
- неименованная функция

### лямбда-термы
- переменная
- абстракция
- применение/аппликация

### переменные
- связанные
  - переменная в области действия лямбды
    - икс в выражении `λx. y`
  - в кодировании: локальные переменные
- свободные
  - переменная, которая не определена внутри выражения
    - игрек в выражении `λx. y`
  - в кодировании: глобальные переменные

### комбинатор
- замкнутый лямбда-терм
- терм, который не содержит свободных переменных
- комбинаторы, содержащие самоприменение, могут быть нетипизируемы

> комбинатор неподвижной точки - рассматривай это как вид рекурсии

функции нескольких переменных могут быть описаны последовательным применением функции к этим переменных

### вопрос
означает ли этот тезис, что для любого вычисления достаточно одной переменной?
в частности, функции в любом ЯП достаточно одного параметра?


подстановка - или, бета-преобразование / бета-конверсия

захват переменной 
- в чистом лямбда-исчислении отсутствует понятие захвата переменной
  - переменная - либо связанная (параметр), либо свободная (глобальная)
- в расширениях лямбда-исчисления появляется вероятность одновременного существования переменной и в свободной, и в связанной формах
  - в таком случае невозможно однозначно определить, над каким значением выполняется применение
  - решение 
    - в науке - альфа-преобразование - замена одного идентификатора переменной на другой
    - в кодировании - переименование одной из конфликтующих переменных

роль индукции в лямбда-исчислении
- доказательство свойств подстановки


### `равенство =` и `тождество ≡`
- равенство - эквивалентность по значению
  - утверждение, что два значения равны
  - `2 + 2` = `4` // значения выражений равны, выражения не тождественны
- тождество - эквивалентность по структуре
  - эквивалентность по связке тип+значение
  - утверждение, что две сущности есть один и тот же объект
  - `2 + 2` ≡ `2 + 2` // значения выражений равны, выражения тождественны
- в кодировании: тождество утверждает, что две сущности являются одним и тем же синтаксическим объектом
  - тождество - операция проверки типов - ответ на вопрос "переданный тип тождественнен ожидаемому?"

### альфа-конверсия
- в кодировании: замена переменных


### подстановка
- операция замены переменной на выражение
```
M[x := N] 
// в выражении M 
// заменить 
// все свободные вхождения переменной x 
// выражением N
```
```
λx. x y[x := z] 
// читается: (лямбда икс) (икс игрек) (где икс заменен на зет)
// икс в конструкции `λx` - связанная переменная, подстановка на нее не действует
λx. x y[x := z] → λx z y
```

### бета-конверсия / бета-редукция / бета-преобразование
- правило, определяющее порядок вычисления аппликации функции
- использует подстановку как ключевой механизм
  - подстановка - инструмент бета-конверсии

```
(λx. M) N → M[x := N]
// читается
// (λx. M) N // применение лямбда икс эМ к переменной эН
// → // дает/приводит к
// M[x := N] // эМ по подстановке эН вместо икс
```
```
(λx. x y) z → (x y)[x := z] → z y
// применение лямбда-выражения лямбда икс, икс игрек к зет 
// приводит к
// выражению икс игрек после подстановки зет вместо икс,
// которое равно зет игрек 
```
- `y` - свободная переменная, в процессе редукции не изменяется
- строго необходима проверка на захват переменной, чтобы сохранить однозначность


```
---
по условию
ω ≡ λx. x x // читается омега эквивалентна лямбде икс, икс икс
// λx. x x - лямбда-выражение, 
где `λx` - "принимает параметр икс" / "параметр лямбда-функции есть икс"
`x x` - "применяет икс к самому себе"

// аппликация/применение ω ω
// суть - применить к самому себе выражение, в котором переменная применяется к самой себе
ω ω → (λx. x x) ω // так как по условию ω ≡ λx. x x

// выполним бета-преобразование
(λx. x x) ω → 
(x x)[x := ω] → 
ω ω → 
(λx. x x) ω →
(x x)[x := ω] →
ω ω →
...
// бесконечный цикл, бесконечная редукция
```

### ита-конверсия
- в кодировании - упрощение синтаксиса за счет замены ненужных оберточных лямбда-функций
```
выражение lambda x: f(x)
эквивалентно
f
если x - переменная, не свободная в f (связанная/локальная переменная)
```




## Лямбда-выражения в Java

### Материалы
[Java Lambda Expressions](https://www.w3schools.com/java/java_lambda.asp)

### основа
- лямбда-функция принимает параметры и возвращает значение
  - (parameter1, parameter2, ..., parameterN)   → expression
- лямбда-функция анонимна, то есть, не требует объявления в классе
- лямбда-функция может быть передана как параметр другой функции
- можно создать переменную, ссылающуюся на лямбда-функцию
  - условие - тип такой переменной - интерфейс, содержащий строго один метод
    - однозначно, какой метод вызывать
    - интерфейс со строго одним методом - функциональный интерфейс

[код - лямбда-функции](/src/main/java/Lambdas/Main.java)

### функциональные интерфейсы / ФИ

#### задача ФИ
- использовать методические ссылки / МС / ссылки на методы / method references
  - МС - не объект, МС - ссылка
  - лямбда-выражение, которое ссылается на метод
    - статический  
    `Integer::parseInt`
    - экземплярный  
    `String::toUpperCase`
  - синтаксический сахар - сокращают запись - применимы для одного вызова одного метода  
- использовать лямбда-выражения / ЛВ

### стандартные интерфейсы Function, Consumer, Supplier BiFunction, BiConsumer
### лямбды вида Function< Function< Function< A, B>, C>, D> - т.е. вложенность


> Java не поддерживает лямбды в чистом виде (без синтаксической эквивалентности)





## выводы
- связь доказательство по индукции - система типов - типобезопасность
- выражение `free как в слове freedom` следует изменить на `free как перменная в λ-исчислении`