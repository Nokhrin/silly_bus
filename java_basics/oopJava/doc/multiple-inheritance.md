# множественное наследование

## проблема

Даны классы A, B, C, D

```text
    A
  /   \
 B     C
  \   /
    D
```

если допустить наследование D от B и C,
то поведение какого класса считать первичным?
в каком порядке разрешать наследование?
D -> **B** -> A
или
D -> **C** -> A
?

[проблема «ромбовидной структуры» («diamond diagram»)](../src/main/java/DemoTyping/DiamondProblem)

### существующие решения

#### Java

##### отказ от множественного наследования классов
- в Java запрещено множественное наследование от классов, но разрешено множественное наследование от интерфейсов
- [множественное наследование - код](../src/main/java/DemoTyping/MultipleInheritance/Main.java)

- причины отказа от множественного наследования классов:
  - стабилизация типизации / повышение типобезопасности
  - упрощение задачи проверки наследования для программиста и компилятора  
  - усиление инкапсуляции - изменение поведения предка изменить поведение потомка; если предков несколько, такие изменения сложнее поддерживать

##### композиция, делегирование
- поведение реализуется как поле класса
  - то есть поведение - отдельный класс, несвязанный наследованием с реализуемым классом
- происходит делегирование поведения вместо наследования
  - делегирование - вызов методов другого объекта, который передан в класс как поле-поведение
- поведение изолируется в классе-поведении

---

#### множественное наследование в разных языках

аналогично Java: C#, Kotlin
- множественное наследование запрещено: один суперкласс
- обходное решение: интерфейсы + композиция

> trait - механизм наследования **поведения**, реализован как интерфейс, определяющий методы, объединенные по какому-либо признаку

---

##### groovy

Groovy:
- ЯП с динамической типизацией
- компилируется в байт-код, который выполняет JVM
- позволяет использовать библиотеки и пакеты Java

отличия от java
- компилируемый или интерпретируемый?
  - 
- поддерживает динамическую типизацию:
  - способен определять типы переменных на этапе runtime, после компиляции 
  - способен разрешить поля и методы классов на этапе runtime, после компиляции 
  - переменные способны изменять свой `тип данных` в ходе выполнения программы
    - изменение типа данных переменной - изменение ссылки переменной - переменная ссылается на значение типа X, далее по ходу выполнения переменная ссылается на значение типа Y
    - изменение типа отслеживает механизм `динамического разрешения методов`
      - если для переменной указан семантический маркер def, 
        - тип переменной не будет проверяться на этапе компиляции
        - переменная будет разрешаться динамически
      - объект Groovy содержит MetaClass, который содержит информацию о действующем типе объекта
```groovy
def x = "hello" // def обозначает, что тип значения переменной определять на этапе runtime
println(x) // hello
// переменная указывает на значение типа String
println(x.getClass()) // class java.lang.String

println(x) // 1
// переменная указывает на значение типа Integer
println(x.getClass()) // class java.lang.Integer
```

- множественное наследование разрешено: trait - https://www.baeldung.com/groovy-traits

---

scala 
- множественное наследование разрешено: trait - https://docs.scala-lang.org/tour/traits.html

javascript, dart
- множественное наследование запрещено: один суперкласс
- обходное решение: миксины - https://javascript.info/mixins

---

> Вообще в java нет множественного наследования, это не корректно говорить что ты его используешь в java
Множественное наследование от интерфейсов, такое можно встретить в книжках, но это скорее путает чем объясняет
Интерфейсы в java появились давно. Возьмем java 7.
Наследование подразумевает, наследование не только определений, но и реализации.

В интерфейсы java 7, нет возможности вставить реализацию объявленных методов.

Именно по этому утверждать что множественное наследование через интерфейсы это что то странное

Другой пример наследования: можно наследовать fields у классов, в интерфейсах fields нет, а статические fields в интерфейсах не дают большой пользы.

Если есть множественное наследование через интерфейсы , то надо описать как решается проблема ромба

_

Интерфейсы являються типами, в том смысле что переменную можно указат тип который интерфейс

В этом смысле думаю надо провести различие между абстрактными классами и интерфейсами - распиши вот этот момент

Абстрактные классы могут наследоваться от абстрактных классов

Если будет цепь наследования абстрактных классов (A -> B -> C) то это нельзя назвать множественным наследованием формально

Но так примерно работает scala

Вот этот момент trait scala и как это решает проблему ромба надо рассмотреть

> Groovy и scala , в части trait являются ститически типизируемые

И при этом trait действительно предоставляют множественное наследование в том смысле что я писал - наследование реализаций

Вопрос, как в них решаеться проблема ромба

И как миксины решают этот же вопрос?

> про наследование и интерфейсы как оно фактически устроено
https://chat.qwen.ai/s/6c4d8186-cacf-4447-b3ca-111977e2bc04?fev=0.0.243

---

#### C++
- множественное наследование классов - среди ЯП СТ - допускается в C++
- проблема конфликта наследования решается в C++ прямым указанием "какой метод от какого класса наследовать"


#### Python
- множественное наследование классов - среди ЯП ДТ - допускается в Python

проблема - определить реализацию наследуемого метода

решение - построить порядок разрешения методов

задача - решение проблемы линеаризации - приближенно представить замкнутую нелинейную систему

для решения применяется алгоритм (Си-Три Линеаризации) - пишется `C3`, что можно ошибочно прочитать как `СЗ` и даже как `С3` 

результат работы алгоритма - линеаризация класса - упорядоченный список классов

построение линеаризации класса для линейной структуры
```text
A
|
B
|
C
```
Линеаризация для класса C есть [C, B, A]

- вызывается метод C.method()
- поиск реализации method() происходит в классе C
- если method() не найден в классе C, поиск происходит в классе B
- если method() не найден в классе B, поиск происходит в классе A
- если метод найден, он будет выполнен
- если не найден, будет выброшено исключение AttributeError


построение линеаризации класса для нелинейной структуры
```text
   A
 /   \
B     C
 \   /
   D
```
возможны две линеаризации класса D 
- [D, B, A, C]
- [D, C, A, B]

такие линеаризации не позволят разрешить наследование из-за последовательностей [A, C], [A, B]
последовательности должны быть монотонными - для любого нового потомка сохраняется последовательность предков
пример: 
- создание класса E, наследующего D
- если линеаризация D - [D, B, A], то для E - и всех его наследников - последовательность [D, B, A] неизменна

для ромба имеем две монотонные линеаризации
- [D, B, A]
- [D, C, A]
при объявлении класса указываем порядок наследования
`class D(C, A)` или `class D(В, A)`, в зависимости от задачи 

##### Процедура построения порядка разрешения методов в Python
- выполняет
- интерпретатор считывает определение класса
  - `class D3(A, B, C)`
- интерпретатор считывает базовые классы из кортежа наследования `(A, B, C)`
  - A -> B -> C, стрелка указывает на родителя
- для считанных из кортежа классов интерпретатор выполняет проверку согласованности порядка разрешения методов (MRO)
- MRO определяет порядок проверки классов при множественном наследовании
- реализован посредством алгоритма СЗ реализации
  1. определяет линейную последовательность классов
  2. для каждого класса в последовательности формирует список всех суперклассов согласно порядку наследования
  3. каждый суперкласс в последовательности располагается перед всеми своими наследниками
- при обнаружении противоречия наследования, например, циклического наследования, интерпретатор выбросит исключение ошибки типа
- при успешной проверке интерпретатор продолжает процедуру определения класса

Построение MRO - часть фазы компиляции класса в Python
При отсутствии стадии компиляции Python кода в целом, фазу создания класса называют "компиляцией"

Фаза компиляции класса Python включает этапы:
- синтаксический анализ кода
  - парсинг текста исходного кода класса
- сборка тела класса
  - выполнение тела класса в локальной области видимости
- построение MRO
  - проверка согласованности наследования
- создание класса
  - вызов процедуры type - или - вызов метакласса


- пример

```python
class A:
    def method(self):
        print('class A')


class B(A):
    def method(self):
        print('class B')


class C(A):
    def method(self):
        print('class C')


class D1(B, C):
    pass


class D1_1(B, C, A):
    """По сути - повтор класса D1
    с отличием в том, что явно указан суперкласс A"""
    pass


class D2(C, B):
    pass


class D2_1(C, B, A):
    """По сути - повтор класса D2
    с отличием в том, что явно указан суперкласс A"""
    pass

    # class D3(A, B, C):
    """
    на этапе построения порядка разрешения методов
    будет выброшено исключение
        TypeError: Cannot create a consistent method resolution
        order (MRO) for bases A, B, C

    реализация класса D3 содержит ошибку
    - правило MRO в Python - суперкласс передается ПОСЛЕ наследников
        - причина ошибки - автор положился на интуицию о том,
            что интерпретация происходит "естественным" образом слева направо
        - список наследников разрешается справа налево
        D(A -> B -> C) - стрелка указывает на родителя, но не на порядок разрешения методов,
            с этим учетом ошибка очевидна

    """
    # pass


if __name__ == '__main__':
    d1 = D1()  # порядок наследования B -> C -> A
    
    # порядок наследования
    # - object - базовый класс для всех объектов в Python
    # - D1 - класс экземпляра, для которого запросили mro
    print(type(d1).mro())  # [<class '__main__.D1'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]
    
    d1.method()  # class B
    # d1.bad_method()  # при выполнении будет выброшено исключение AttributeError, так как реализация bad_method не будет найдена
    # Traceback (most recent call last):
    #   File "/home/region.cbr.ru/65nokhrinav/projects/pythonProject/multiple_inheritance.py", line 63, in <module>
    #     d1.bad_method()  # class B
    #     ^^^^^^^^^^^^^
    # AttributeError: 'D1' object has no attribute 'bad_method'

    d4 = D1_1()  # порядок наследования B -> C -> A
    d4.method()  # class B

    d2 = D2()  # порядок наследования C -> B -> A
    d2.method()  # class С

    d5 = D2_1()  # порядок наследования C -> B -> A
    d5.method()  # class С
```
