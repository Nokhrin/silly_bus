# Множественное наследование

## Задача множественного наследования

## Логика множественного наследования

## Проблемы Множественного наследования


### Проблема ромба

Даны классы A, B, C, D

```text
    A
  /   \
 B     C
  \   /
    D
```

если допустить наследование D от B и C,
то поведение какого класса считать первичным?
в каком порядке разрешать наследование?
D -> **B** -> A
или
D -> **C** -> A
?

[проблема «ромбовидной структуры» («diamond diagram»)](../src/main/java/DemoTyping/DiamondProblem)


## Реализация в Java

### отказ от множественного наследования классов

- причины отказа от множественного наследования классов:
  - стабилизация типизации / повышение типобезопасности
  - упрощение задачи проверки наследования для программиста и компилятора
  - усиление инкапсуляции - изменение поведения предка изменить поведение потомка; если предков несколько, такие изменения сложнее поддерживать

> Наследование подразумевает, наследование не только определений, но и реализации.

- в Java запрещено множественное наследование от классов, следовательно, Java не поддерживает множественное наследование
- в Java разрешено множественное наследование от интерфейсов
- [проблема ромба при наследовании классов](../src/main/java/MultipleInheritance/Classes/Main.java)

> можно наследовать fields у классов, в интерфейсах fields нет, а статические fields в интерфейсах не дают большой пользы.

- Строго говоря, наследование контракта - то есть, определений полей и методов - нельзя назвать наследованием, потому что за определениями нет кода, реализующего это поведение
  - наследование договоренности - интерфейса - добавляет организованности - видно, какие методы ожидаются, легче оставаться в одной области определений

> Если есть множественное наследование через интерфейсы , то надо описать как решается проблема ромба

- даны 4 интерфейса
```java
public interface InterfaceA {
    void methodA();
}
public interface InterfaceB extends InterfaceA {
    void methodB();
}
public interface InterfaceC extends InterfaceA {
    void methodC();
}
public interface InterfaceD extends InterfaceB, InterfaceC {
    void methodD();
}
```
- такие интерфейсы - не имеющие реализации - то есть, в проекте нет классов, их реализующих - есть абстрактные классы?
> нет, абстрактный класс - конкретный кусок кода

- default поле интерфейса позволяет хранить состояние
  - хранение состояние в интерфейсе не противоречит идее разделения обработки состояния и поведения?

абстрактный класс:
- гарантирует
  - общие методы для наследников
  - обязует переопределить методы, объявленные абстрактными

в чем отличие переопределения метоода от перегрузки метода?

- нельзя создать экземпляр абстрактного класса
  - конструктор new не принимает абстрактные классы
  - из-за этого можно тестировать только посредством наследников
- шаблон для создания классов
  - суперкласс / класс-родитель
  - абстрактный класс может содержать абстрактные методы
    - абстрактные методы - объявленные функции 
      - с сигнатурой (тип данных результата, имя функции, тип данных параметров)
      - без тела / логики
  - абстрактный класс может содержать методы конкретные (в противоположность абстрактным) / реализации
    - функции/методы с телом/логикой
    - в наследующих классах реализуются специфические методы, расширяющие функционал абстрактного класса 

- хранение состояния - то есть, значений полей экземпляров
- реализация методов
- наследование
- [код - абстрактный класс](src/main/java/MultipleInheritance/AbstractClasses/TaskManagement.java)


- среда разработки не находит ошибки
- проверим компилятором `javac` - компиляция успешна
```bash
cd cd ~/projects/silly_bus/java_basics/oopJava/
javac -verbose -d ./target/classes ./src/main/java/MultipleInheritance/Interfaces/*.java
```
```text
...
[wrote ./target/classes/MultipleInheritance/Interfaces/InterfaceA.class]
[checking MultipleInheritance.Interfaces.InterfaceB]
[wrote ./target/classes/MultipleInheritance/Interfaces/InterfaceB.class]
[checking MultipleInheritance.Interfaces.InterfaceC]
[wrote ./target/classes/MultipleInheritance/Interfaces/InterfaceC.class]
[checking MultipleInheritance.Interfaces.InterfaceD]
[wrote ./target/classes/MultipleInheritance/Interfaces/InterfaceD.class]
[total 123ms]
```

```bash
ls ./target/classes/MultipleInheritance/Interfaces/
```
```text
InterfaceA.class  InterfaceB.class  InterfaceC.class  InterfaceD.class
```

- исключение - [наследование интерфейса без переопределения default методов интерфейса](../src/main/java/MultipleInheritance/Interfaces/DefaultC.java)
  - не default метод - абстрактный метод, то есть, метод без реализации
  - default метод - не абстрактный, реализованный метод, но реализацию можно переопределить в классе
- если не реализовать метод, компиляция завершится неудачей, ошибка:
```text
./src/main/java/MultipleInheritance/Interfaces/DefaultC.java:3: error: types DefaultA and DefaultB are incompatible;
public interface DefaultC extends DefaultA, DefaultB {
       ^
  interface DefaultC inherits unrelated defaults for method() from types DefaultA and DefaultB
```
- проблема ромба возникает для реализаций методов, интерфейсы содержат абстрактные методы - сигнатуры без реализаций
  - конфликт возникает для реализаций

- вопрос - какое преимущество дает наследование "пустышек" / интерфейсов?
  - [расширение функциональности](../src/main/java/MultipleInheritance/Messaging/Main.java)
    - наследование поведения без наследования состояния
  - подмена / мокирование - создание заглушек с заданными значениями
  
  - инверсия зависимостей
    - как при наличии, так и при отсутствии интерфейса нужно писать конкретную реализацию
    - вижу одно отличие - интерфейс фиксирует сигнатуру, тип данных возвращаемого значения, типы данных параметров
      - эти же свойства - типобезопасность - даст реализация классов

- если добавить реализацию в интерфейс - метод типа default - возникнет конфликт на этапе создания класса, если метод не переопределяется в классе
- решение конфликта наследования - [переопределение метода](../src/main/java/MultipleInheritance/Interfaces/DOverride.java)
- решение конфликта наследования - [вызов super](../src/main/java/MultipleInheritance/Interfaces/DSuper.java) - явное указание на интерфейс, из которого брать реализацию метода

- возможная реализация множественного наследования - наследовать класс И реализовать интерфейс
  - операция Зачисление наследует класс Операция - поле суммы 
  - операция Зачисление наследует интерфейс Действия - метод Выполнить
  - [пример](../src/main/java/MultipleInheritance/Interfaces/Deposit.java)

---

в родо-видовой классификации -
Интерфейс - родовое понятие, обобщtнная форма (например, Фигура, Двигаемый).
Класс - видовое понятие, конкретизация (например, Квадрат, Автомобиль).






---

#### Абстрактные классы VS Интерфейсы
> Интерфейсы являются типами, в том смысле что переменную можно указать тип который интерфейс
> В этом смысле думаю надо провести различие между абстрактными классами и интерфейсами - распиши вот этот момент


#### Наследование и Интерфейсы
> про наследование и интерфейсы как оно фактически устроено
https://chat.qwen.ai/s/6c4d8186-cacf-4447-b3ca-111977e2bc04?fev=0.0.243

---

---



### композиция, делегирование
- поведение реализуется как поле класса
  - то есть поведение - отдельный класс, несвязанный наследованием с реализуемым классом
- происходит делегирование поведения вместо наследования
  - делегирование - вызов методов другого объекта, который передан в класс как поле-поведение
- поведение изолируется в классе-поведении

---

## Реализация в других ЯП

#### C++
- множественное наследование классов - среди ЯП СТ - допускается в C++
- проблема конфликта наследования решается в C++ прямым указанием "какой метод от какого класса наследовать"

### C#, Kotlin
- множественное наследование запрещено: один суперкласс
- обходное решение: интерфейсы + композиция

### Groovy

> Абстрактные классы могут наследоваться от абстрактных классов
> Если будет цепь наследования абстрактных классов (A -> B -> C) то это нельзя назвать множественным наследованием формально
> Но так примерно работает scala
> Вот этот момент trait scala и как это решает проблему ромба надо рассмотреть

> Groovy и scala , в части trait являются статически типизируемые
> И при этом trait действительно предоставляют множественное наследование в том смысле что я писал - наследование реализаций
> Вопрос, как в них решается проблема ромба
> И как миксины решают этот же вопрос?

множественное наследование: 
- https://www.baeldung.com/groovy-traits
- https://groovy-lang.org/objectorientation.html#_traits
типизация:
- https://groovy-lang.org/semantics.html#_typing
- https://groovy-lang.org/semantics.html#_dynamic_vs_static

Groovy:
- ЯП с динамической типизацией
- компилируется в байт-код, который выполняет JVM
- позволяет использовать библиотеки и пакеты Java

отличия от java
- компилируемый или интерпретируемый?
  - todo
- поддерживает динамическую типизацию:
  - способен определять типы переменных на этапе runtime, после компиляции 
  - способен разрешить поля и методы классов на этапе runtime, после компиляции 
  - переменные способны изменять свой `тип данных` в ходе выполнения программы
    - изменение типа данных переменной - изменение ссылки переменной - переменная ссылается на значение типа X, далее по ходу выполнения переменная ссылается на значение типа Y
    - изменение типа отслеживает механизм `динамического разрешения методов`
      - если для переменной указан семантический маркер def, 
        - тип переменной не будет проверяться на этапе компиляции
        - переменная будет разрешаться динамически
      - объект Groovy содержит MetaClass, который содержит информацию о действующем типе объекта
```groovy
def x = "hello" // def обозначает, что тип значения переменной определять на этапе runtime
println(x) // hello
// переменная указывает на значение типа String
println(x.getClass()) // class java.lang.String

println(x) // 1
// переменная указывает на значение типа Integer
println(x.getClass()) // class java.lang.Integer
```



---

javascript, dart
- множественное наследование запрещено: один суперкласс
- обходное решение: миксины - https://javascript.info/mixins


### Scala

> Абстрактные классы могут наследоваться от абстрактных классов
> Если будет цепь наследования абстрактных классов (A -> B -> C) то это нельзя назвать множественным наследованием формально
> Но так примерно работает scala
> Вот этот момент trait scala и как это решает проблему ромба надо рассмотреть

> Groovy и scala , в части trait являются статически типизируемые
> И при этом trait действительно предоставляют множественное наследование в том смысле что я писал - наследование реализаций
> Вопрос, как в них решается проблема ромба
> И как миксины решают этот же вопрос?

вот тут про scala
https://scala-lang.org/files/archive/spec/3.4/05-classes-and-objects.html

scala 
- множественное наследование разрешено: trait - https://docs.scala-lang.org/tour/traits.html

---

### Python
- множественное наследование классов - среди ЯП ДТ - допускается в Python

проблема - определить реализацию наследуемого метода

решение - построить порядок разрешения методов

задача - решение проблемы линеаризации - приближенно представить замкнутую нелинейную систему

для решения применяется алгоритм (Си-Три Линеаризации) - пишется `C3`, что можно ошибочно прочитать как `СЗ` и даже как `С3` 

результат работы алгоритма - линеаризация класса - упорядоченный список классов

построение линеаризации класса для линейной структуры
```text
A
|
B
|
C
```
Линеаризация для класса C есть [C, B, A]

- вызывается метод C.method()
- поиск реализации method() происходит в классе C
- если method() не найден в классе C, поиск происходит в классе B
- если method() не найден в классе B, поиск происходит в классе A
- если метод найден, он будет выполнен
- если не найден, будет выброшено исключение AttributeError


построение линеаризации класса для нелинейной структуры
```text
   A
 /   \
B     C
 \   /
   D
```
возможны две линеаризации класса D 
- [D, B, A, C]
- [D, C, A, B]

такие линеаризации не позволят разрешить наследование из-за последовательностей [A, C], [A, B]
последовательности должны быть монотонными - для любого нового потомка сохраняется последовательность предков
пример: 
- создание класса E, наследующего D
- если линеаризация D - [D, B, A], то для E - и всех его наследников - последовательность [D, B, A] неизменна

для ромба имеем две монотонные линеаризации
- [D, B, A]
- [D, C, A]
при объявлении класса указываем порядок наследования
`class D(C, A)` или `class D(В, A)`, в зависимости от задачи 

#### Процедура построения порядка разрешения методов в Python
- выполняет
- интерпретатор считывает определение класса
  - `class D3(A, B, C)`
- интерпретатор считывает базовые классы из кортежа наследования `(A, B, C)`
  - A -> B -> C, стрелка указывает на родителя
- для считанных из кортежа классов интерпретатор выполняет проверку согласованности порядка разрешения методов (MRO)
- MRO определяет порядок проверки классов при множественном наследовании
- реализован посредством алгоритма СЗ реализации
  1. определяет линейную последовательность классов
  2. для каждого класса в последовательности формирует список всех суперклассов согласно порядку наследования
  3. каждый суперкласс в последовательности располагается перед всеми своими наследниками
- при обнаружении противоречия наследования, например, циклического наследования, интерпретатор выбросит исключение ошибки типа
- при успешной проверке интерпретатор продолжает процедуру определения класса

Построение MRO - часть фазы компиляции класса в Python
При отсутствии стадии компиляции Python кода в целом, фазу создания класса называют "компиляцией"

Фаза компиляции класса Python включает этапы:
- синтаксический анализ кода
  - парсинг текста исходного кода класса
- сборка тела класса
  - выполнение тела класса в локальной области видимости
- построение MRO
  - проверка согласованности наследования
- создание класса
  - вызов процедуры type - или - вызов метакласса


- пример

```python
class A:
    def method(self):
        print('class A')


class B(A):
    def method(self):
        print('class B')


class C(A):
    def method(self):
        print('class C')


class D1(B, C):
    pass


class D1_1(B, C, A):
    """По сути - повтор класса D1
    с отличием в том, что явно указан суперкласс A"""
    pass


class D2(C, B):
    pass


class D2_1(C, B, A):
    """По сути - повтор класса D2
    с отличием в том, что явно указан суперкласс A"""
    pass

    # class D3(A, B, C):
    """
    на этапе построения порядка разрешения методов
    будет выброшено исключение
        TypeError: Cannot create a consistent method resolution
        order (MRO) for bases A, B, C

    реализация класса D3 содержит ошибку
    - правило MRO в Python - суперкласс передается ПОСЛЕ наследников
        - причина ошибки - автор положился на интуицию о том,
            что интерпретация происходит "естественным" образом слева направо
        - список наследников разрешается справа налево
        D(A -> B -> C) - стрелка указывает на родителя, но не на порядок разрешения методов,
            с этим учетом ошибка очевидна

    """
    # pass


if __name__ == '__main__':
    d1 = D1()  # порядок наследования B -> C -> A
    
    # порядок наследования
    # - object - базовый класс для всех объектов в Python
    # - D1 - класс экземпляра, для которого запросили mro
    print(type(d1).mro())  # [<class '__main__.D1'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]
    
    d1.method()  # class B
    # d1.bad_method()  # при выполнении будет выброшено исключение AttributeError, так как реализация bad_method не будет найдена
    # Traceback (most recent call last):
    #   File "/home/region.cbr.ru/65nokhrinav/projects/pythonProject/multiple_inheritance.py", line 63, in <module>
    #     d1.bad_method()  # class B
    #     ^^^^^^^^^^^^^
    # AttributeError: 'D1' object has no attribute 'bad_method'

    d4 = D1_1()  # порядок наследования B -> C -> A
    d4.method()  # class B

    d2 = D2()  # порядок наследования C -> B -> A
    d2.method()  # class С

    d5 = D2_1()  # порядок наследования C -> B -> A
    d5.method()  # class С
```
