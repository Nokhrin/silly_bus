# множественное наследование

## проблема

Даны классы A, B, C, D

```text
    A
  /   \
 B     C
  \   /
    D
```

если допустить наследование D от B и C,
то поведение какого класса считать первичным?
в каком порядке разрешать наследование?
D -> **B** -> A
или
D -> **C** -> A
?

[проблема «ромбовидной структуры» («diamond diagram»)](../src/main/java/DemoTyping/DiamondProblem)

### существующие решения

#### Java

##### отказ от множественного наследования классов
- в Java запрещено множественное наследование от классов, но разрешено множественное наследование от интерфейсов
- [множественное наследование - код](../src/main/java/DemoTyping/MultipleInheritance/Main.java)

- причины отказа от множественного наследования классов:
  - стабилизация типизации / повышение типобезопасности
  - упрощение задачи проверки наследования для программиста и компилятора  
  - усиление инкапсуляции - изменение поведения предка изменить поведение потомка; если предков несколько, такие изменения сложнее поддерживать

##### композиция, делегирование
- поведение реализуется как поле класса
  - то есть поведение - отдельный класс, несвязанный наследованием с реализуемым классом
- происходит делегирование поведения вместо наследования
  - делегирование - вызов методов другого объекта, который передан в класс как поле-поведение
- поведение изолируется в классе-поведении

---

#### множественное наследование в разных языках

аналогично Java: C#, Kotlin
- множественное наследование запрещено: один суперкласс
- обходное решение: интерфейсы + композиция

> trait - механизм наследования **поведения**, реализован как интерфейс, определяющий методы, объединенные по какому-либо признаку

groovy - ЯП с динамической типизацией, код выполняет JVM ("Java с динамической типизацией")
- множественное наследование разрешено: trait - https://www.baeldung.com/groovy-traits

scala 
- множественное наследование разрешено: trait - https://docs.scala-lang.org/tour/traits.html

javascript, dart
- множественное наследование запрещено: один суперкласс
- обходное решение: миксины - https://javascript.info/mixins


#### C++
- множественное наследование классов - среди ЯП СТ - допускается в C++
- проблема конфликта наследования решается в C++ прямым указанием "какой метод от какого класса наследовать"


#### Python
- множественное наследование классов - среди ЯП ДТ - допускается в Python

проблема - определить реализацию наследуемого метода

решение - построить порядок разрешения методов

задача - решение проблемы линеаризации - приближенно представить замкнутую нелинейную систему

для решения применяется алгоритм (Си-Три Линеаризации) - пишется `C3`, что можно ошибочно прочитать как `СЗ` и даже как `С3` 

результат работы алгоритма - линеаризация класса - упорядоченный список классов

построение линеаризации класса для линейной структуры
```text
A
|
B
|
C
```
Линеаризация для класса C есть [C, B, A]

- вызывается метод C.method()
- поиск реализации method() происходит в классе C
- если method() не найден в классе C, поиск происходит в классе B
- если method() не найден в классе B, поиск происходит в классе A
- если метод найден, он будет выполнен
- если не найден, будет выброшено исключение AttributeError


построение линеаризации класса для нелинейной структуры
```text
   A
 /   \
B     C
 \   /
   D
```
возможны две линеаризации класса D 
- [D, B, A, C]
- [D, C, A, B]

такие линеаризации не позволят разрешить наследование из-за последовательностей [A, C], [A, B]
последовательности должны быть монотонными - для любого нового потомка сохраняется последовательность предков
пример: 
- создание класса E, наследующего D
- если линеаризация D - [D, B, A], то для E - и всех его наследников - последовательность [D, B, A] неизменна

для ромба имеем две монотонные линеаризации
- [D, B, A]
- [D, C, A]
при объявлении класса указываем порядок наследования
`class D(C, A)` или `class D(В, A)`, в зависимости от задачи 

##### Процедура построения порядка разрешения методов в Python
- выполняет
- интерпретатор считывает определение класса
  - `class D3(A, B, C)`
- интерпретатор считывает базовые классы из кортежа наследования `(A, B, C)`
  - A -> B -> C, стрелка указывает на родителя
- для считанных из кортежа классов интерпретатор выполняет проверку согласованности порядка разрешения методов (MRO)
- MRO определяет порядок проверки классов при множественном наследовании
- реализован посредством алгоритма СЗ реализации
  1. определяет линейную последовательность классов
  2. для каждого класса в последовательности формирует список всех суперклассов согласно порядку наследования
  3. каждый суперкласс в последовательности располагается перед всеми своими наследниками
- при обнаружении противоречия наследования, например, циклического наследования, интерпретатор выбросит исключение ошибки типа
- при успешной проверке интерпретатор продолжает процедуру определения класса

Построение MRO - часть фазы компиляции класса в Python
При отсутствии стадии компиляции Python кода в целом, фазу создания класса называют "компиляцией"

Фаза компиляции класса Python включает этапы:
- синтаксический анализ кода
  - парсинг текста исходного кода класса
- сборка тела класса
  - выполнение тела класса в локальной области видимости
- построение MRO
  - проверка согласованности наследования
- создание класса
  - вызов процедуры type - или - вызов метакласса


- пример

```python
class A:
    def method(self):
        print('class A')


class B(A):
    def method(self):
        print('class B')


class C(A):
    def method(self):
        print('class C')


class D1(B, C):
    pass


class D1_1(B, C, A):
    """По сути - повтор класса D1
    с отличием в том, что явно указан суперкласс A"""
    pass


class D2(C, B):
    pass


class D2_1(C, B, A):
    """По сути - повтор класса D2
    с отличием в том, что явно указан суперкласс A"""
    pass

    # class D3(A, B, C):
    """
    на этапе построения порядка разрешения методов
    будет выброшено исключение
        TypeError: Cannot create a consistent method resolution
        order (MRO) for bases A, B, C

    реализация класса D3 содержит ошибку
    - правило MRO в Python - суперкласс передается ПОСЛЕ наследников
        - причина ошибки - автор положился на интуицию о том,
            что интерпретация происходит "естественным" образом слева направо
        - список наследников разрешается справа налево
        D(A -> B -> C) - стрелка указывает на родителя, но не на порядок разрешения методов,
            с этим учетом ошибка очевидна

    """
    # pass


if __name__ == '__main__':
    d1 = D1()  # порядок наследования B -> C -> A
    
    # порядок наследования
    # - object - базовый класс для всех объектов в Python
    # - D1 - класс экземпляра, для которого запросили mro
    print(type(d1).mro())  # [<class '__main__.D1'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]
    
    d1.method()  # class B
    # d1.bad_method()  # при выполнении будет выброшено исключение AttributeError, так как реализация bad_method не будет найдена
    # Traceback (most recent call last):
    #   File "/home/region.cbr.ru/65nokhrinav/projects/pythonProject/multiple_inheritance.py", line 63, in <module>
    #     d1.bad_method()  # class B
    #     ^^^^^^^^^^^^^
    # AttributeError: 'D1' object has no attribute 'bad_method'

    d4 = D1_1()  # порядок наследования B -> C -> A
    d4.method()  # class B

    d2 = D2()  # порядок наследования C -> B -> A
    d2.method()  # class С

    d5 = D2_1()  # порядок наследования C -> B -> A
    d5.method()  # class С
```
