# множественное наследование
- 
- в Java допускается множественное наследование от интерфейсов
- [множественное наследование - код](../src/main/java/DemoTyping/MultipleInheritance/Main.java)

> Есть разные причины запрета, но по ходу они не сю всегда применимы
- понимаю этот тезис как вопрос - "почему в Java запрещено множественное наследование классов"

попытка наследовать два класса
проблема -
если допустить наследование от B и C,
то поведение какого класса считать первичным?
[проблема ромба](../src/main/java/DemoTyping/DiamondProblem)

- множественное наследование классов - среди ЯП СТ - допускается в C++
  - проблема конфликта наследования решается в C++ прямым указанием "какой метод от какого класса наследовать"

#### множественное наследование в ЯП ДТ Python

##### Процедура построения порядка разрешения методов в Python
- выполняет
- интерпретатор считывает определение класса
  - `class D3(A, B, C)`
- интерпретатор считывает базовые классы из кортежа наследования `(A, B, C)`
  - A -> B -> C, стрелка указывает на родителя
- для считанных из кортежа классов интерпретатор выполняет проверку согласованности порядка разрешения методов (MRO)
  - MRO реализован как ...
- при обнаружении противоречия наследования, например, циклического наследования, интерпретатор выбросит исключение ошибки типа
- при успешной проверке интерпретатор продолжает процедуру определения класса

Построение MRO - часть фазы компиляции класса в Python
При отсутствии стадии компиляции Python кода в целом, фазу создания класса называют "компиляцией"

Фаза компиляции класса Python включает этапы:
- синтаксический анализ кода
  - парсинг текста исходного кода класса
- сборка тела класса
  - выполнение тела класса в локальной области видимости
- построение MRO
  - проверка согласованности наследования
- создание класса
  - вызов процедуры type - или - вызов метакласса


- пример

```python
class A:
    def method(self):
        print('class A')


class B(A):
    def method(self):
        print('class B')


class C(A):
    def method(self):
        print('class C')


class D1(B, C):
    pass


class D1_1(B, C, A):
    """По сути - повтор класса D1
    с отличием в том, что явно указан суперкласс A"""
    pass


class D2(C, B):
    pass


class D2_1(C, B, A):
    """По сути - повтор класса D2
    с отличием в том, что явно указан суперкласс A"""
    pass

    # class D3(A, B, C):
    """
    на этапе построения порядка разрешения методов
    будет выброшено исключение
        TypeError: Cannot create a consistent method resolution
        order (MRO) for bases A, B, C

    реализация класса D3 содержит ошибку
    - правило MRO в Python - суперкласс передается ПОСЛЕ наследников
        - причина ошибки - автор положился на интуицию о том,
            что интерпретация происходит "естественным" образом слева направо
        - список наследников разрешается справа налево
        D(A -> B -> C) - стрелка указывает на родителя, но не на порядок разрешения методов,
            с этим учетом ошибка очевидна

    """
    # pass


if __name__ == '__main__':
    d1 = D1()  # порядок наследования B -> C -> A
    d1.method()  # class B

    d4 = D1_1()  # порядок наследования B -> C -> A
    d4.method()  # class B

    d2 = D2()  # порядок наследования C -> B -> A
    d2.method()  # class С

    d5 = D2_1()  # порядок наследования C -> B -> A
    d5.method()  # class С
```







> как вызываются унаследованные методы,
> методы непосредственно родительского и
> более верхнего родителя,
> и также унаследованное от интерфейса

> 1) не сравнить, а найти причину отказа от множественного наследования в Java, хотя в C++ оно есть
> 2) сравнить реализации множественного наследования
>

> В С++ есть множественное наследование для классов
> почему его нет в Java для классов ?
>
> в cвязи с этим тебе придется залезть  в соседние языки
>
> groovy trait
> https://www.baeldung.com/groovy-traits
>
> javascript mixin
> https://javascript.info/mixins
>
> scala trait
> https://docs.scala-lang.org/tour/traits.html

---

> Есть у тебя две операции
Пополнения - Deposit
Снятия - Withdraw

Обе операции представленны разными типами
Формально... interface

Главный момент, являются ли эти типы взаимо исключающими? Являються ли interface взаимо исключающими?

И что надо сделать с типами, что бы они были взаимо исключающими?
