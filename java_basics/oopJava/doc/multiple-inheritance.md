# Множественное наследование

## Задача множественного наследования
- разделить общие сущности разного типа на управляемые группы
  - суперкласс A содержит базовые свойства и действия
  - класс/интерфейс B содержит множество действий, дополняющих класс A и объединенных по какому-либо признаку 

## Логика множественного наследования
- компоненты:
  - множество классов {C1, C2, ...}
  - множество объектов {Obj1, Obj2, ...}
  - множество атрибутов и методов - поля и функции классов

todo

Такое формальное описание позволяет:
- Автоматически проверять **корректность наследования** (например, через проверку моделей).
- Обнаруживать **конфликты наследования** (например, в статических анализаторах).
- Доказывать **инварианты** (например, что объект всегда имеет правильный тип атрибута).
- Использовать в верификации программ (например, в методах Hoare logic, TLA+, Kripke-моделях).


## Проблемы Множественного наследования


### Проблема ромба

Даны классы A, B, C, D

```text
    A
  /   \
 B     C
  \   /
    D
```

если допустить наследование D от B и C,
то поведение какого класса считать первичным?
в каком порядке разрешать наследование?
D -> **B** -> A
или
D -> **C** -> A
?

[проблема «ромбовидной структуры» («diamond diagram»)](../src/main/java/DemoTyping/DiamondProblem)


## Реализация в Java

### отказ от множественного наследования классов

- причины отказа от множественного наследования классов:
  - стабилизация типизации / повышение типобезопасности
  - упрощение задачи проверки наследования для программиста и компилятора
  - усиление инкапсуляции - изменение поведения предка изменить поведение потомка; если предков несколько, такие изменения сложнее поддерживать

> Наследование подразумевает, наследование не только определений, но и реализации.

- в Java запрещено множественное наследование от классов, следовательно, Java не поддерживает множественное наследование
- в Java разрешено множественное наследование от интерфейсов
- [проблема ромба при наследовании классов](/src/main/java/MultipleInheritance/Classes/Main.java)

> можно наследовать fields у классов, в интерфейсах fields нет, а статические fields в интерфейсах не дают большой пользы.

- Строго говоря, наследование контракта - то есть, определений полей и методов - нельзя назвать наследованием, потому что за определениями нет кода, реализующего это поведение
  - наследование договоренности - интерфейса - добавляет организованности - видно, какие методы ожидаются, легче оставаться в одной области определений

> Если есть множественное наследование через интерфейсы , то надо описать как решается проблема ромба

- даны 4 интерфейса
```java
public interface InterfaceA {
    void methodA();
}
public interface InterfaceB extends InterfaceA {
    void methodB();
}
public interface InterfaceC extends InterfaceA {
    void methodC();
}
public interface InterfaceD extends InterfaceB, InterfaceC {
    void methodD();
}
```
- такие интерфейсы - не имеющие реализации - то есть, в проекте нет классов, их реализующих - есть абстрактные классы?
> нет, абстрактный класс - конкретный кусок кода

- default поле интерфейса позволяет хранить состояние
  - хранение состояние в интерфейсе не противоречит идее разделения обработки состояния и поведения?

абстрактный класс:
- гарантирует
  - общие методы для наследников
  - обязует переопределить методы, объявленные абстрактными

---
> переопределение и перегрузка - синонимы?

#### Переопределение метода
- Method Overriding

- происходит в runtime
> проверить суждение

- работает в рамках идеи полиморфизма и наследования, 
  - без наследования не имеет смысла
> это для тебя не имеет смысла

  - проявление полиморфизма - 
- подкласс содержит свою логику метода, определенного в суперклассе
- методы содержат одинаковые параметры, одинаковые типы или подтипы данных параметров, одинаковые типы или подтипы возвращаемых значений

> изменяет унаследованное поведение

[код - Переопределение метода](/src/main/java/MultipleInheritance/OperationOverriding.java)

#### Перегрузка метода
- Method Overloading
- происходит в compile
- работает вне концепции наследования
- определения одного и того же метода но с отличием параметров:
  - иной порядок следования параметров, 
  - иной тип данных параметров, 
  - иное количество параметров

> добавляет способы вызова метода

[код - Перегрузка метода](/src/main/java/MultipleInheritance/OperationOverloading.java)

---
> родительский класс, суперкласс, базовый класс - синонимы?

- **суперкласс** / superclass
  - класс, к которому обращается конструктор другого класса с помощью команды `extends`
  - ближайший предок
- родительский класс / parent class - то же, что родительский, так же, ближайший предок
  - чаще упортребляется в русскоязычной среде
- базовый класс / base class
  - в зависимости от контектса может быть
    - синонимом суперкласса, 
    - более отдаленным общим предком, например, `Object`
- **подкласс** / subclass / derived class / дочерний класс - наследник

- ключевое слово `extends` говорит о наследовании от класса
- ключевое слово `implements` говорит о реализации интерфейса, что фактически есть наследовании от класса, но с некоторыми условиями
- ключевые слова использует компилятор при семантическом анализе исходного кода
  - проверяет наличие указанных суперклассов и интерфейсов


---

- нельзя создать экземпляр абстрактного класса
  - конструктор new не принимает абстрактные классы
  - из-за этого можно тестировать только посредством наследников
- шаблон для создания классов
  - суперкласс / класс-родитель
  - абстрактный класс может содержать абстрактные методы
    - абстрактные методы - объявленные функции 
      - с сигнатурой (тип данных результата, имя функции, тип данных параметров)
      - без тела / логики
  - абстрактный класс может содержать методы конкретные (в противоположность абстрактным) / реализации
    - функции/методы с телом/логикой
    - в наследующих классах реализуются специфические методы, расширяющие функционал абстрактного класса 

- хранение состояния - то есть, значений полей экземпляров
- реализация методов
- наследование
- [код - абстрактный класс](src/main/java/MultipleInheritance/AbstractClasses/TaskManagement.java)


- среда разработки не находит ошибки
- проверим компилятором `javac` - компиляция успешна
```bash
cd cd ~/projects/silly_bus/java_basics/oopJava/
javac -verbose -d ./target/classes ./src/main/java/MultipleInheritance/Interfaces/*.java
```
```text
...
[wrote ./target/classes/MultipleInheritance/Interfaces/InterfaceA.class]
[checking MultipleInheritance.Interfaces.InterfaceB]
[wrote ./target/classes/MultipleInheritance/Interfaces/InterfaceB.class]
[checking MultipleInheritance.Interfaces.InterfaceC]
[wrote ./target/classes/MultipleInheritance/Interfaces/InterfaceC.class]
[checking MultipleInheritance.Interfaces.InterfaceD]
[wrote ./target/classes/MultipleInheritance/Interfaces/InterfaceD.class]
[total 123ms]
```

```bash
ls ./target/classes/MultipleInheritance/Interfaces/
```
```text
InterfaceA.class  InterfaceB.class  InterfaceC.class  InterfaceD.class
```

- исключение - [наследование интерфейса без переопределения default методов интерфейса](../src/main/java/MultipleInheritance/Interfaces/DefaultC.java)
  - не default метод - абстрактный метод, то есть, метод без реализации
  - default метод - не абстрактный, реализованный метод, но реализацию можно переопределить в классе
- если не реализовать метод, компиляция завершится неудачей, ошибка:
```text
./src/main/java/MultipleInheritance/Interfaces/DefaultC.java:3: error: types DefaultA and DefaultB are incompatible;
public interface DefaultC extends DefaultA, DefaultB {
       ^
  interface DefaultC inherits unrelated defaults for method() from types DefaultA and DefaultB
```
- проблема ромба возникает для реализаций методов, интерфейсы содержат абстрактные методы - сигнатуры без реализаций
  - конфликт возникает для реализаций

##### какое преимущество дает наследование "пустышек" / интерфейсов?
- интерфейс есть - в широком смысле - протокол, соглашение между двумя агентами, обеспечивающее согласованность взаимодействия
- протокол - в частности, в программировании - **формальное** описание поведения системы - включает
  - множество допустимых состояний: начальное, промежуточное, конечное
  - множество действий - процедур, изменяющих состояние: события, операции
  - условия инициации и завершения действий: триггеры, предусловия и постусловия
  - условия перехода между состояниями - или, условия, при которых возможно выполнить действие
  - условия согласованности при выполнении действий: гарантия определенного состояния системы после выполнения действия, инвариант
    - согласованность проявляется в обработке множественного наследования
- интерфейс - подобие универсального языка - к разработке может подключиться незнакомый с кодовой базой человек, тогда интерфейс даст ему понимание, какие действия ожидаются

> Интерфейс это соглашение между двумя сторонами
> Иначе говоря контракт или протокол (не сетевой) взаимодействия двух разных кусков кода

эти куски кода могут быть написаны разными программистами и организациями

а interface это способ проконтролироват соблюдение контракта компилятором

- [расширение функциональности](../src/main/java/MultipleInheritance/Messaging/Main.java)
  - наследование поведения без наследования состояния
- подмена / мокирование - создание заглушек с заданными значениями
  
- инверсия зависимостей
  - как при наличии, так и при отсутствии интерфейса нужно писать конкретную реализацию
  - вижу одно отличие - интерфейс фиксирует сигнатуру, тип данных возвращаемого значения, типы данных параметров
    - эти же свойства - типобезопасность - даст реализация классов

что обозначает `инверсия`?

- если добавить реализацию в интерфейс - метод типа default - возникнет конфликт на этапе создания класса, если метод не переопределяется в классе
> обычно, нет, проверь

##### эксперимент
- [код - множественное наследование от интерфейсов с default методом](/src/main/java/MultipleInheritance/Interfaces/InterfaceDefaultCheck.java)
- конфликт в случае объявления / declaration класса C3
---
```java
package MultipleInheritance.Interfaces;
/**
Интерфейс в роли суперкласса
 */
interface A {
    default void execute() {
        System.out.println("интерфейс A: default метод");
    }
}

interface B {
    default void execute() {
        System.out.println("интерфейс B: default метод");
    }
}

class C1 implements A {
}

class C2 implements B {
}

//class C3 implements A, B {
//}
/*
javac src/main/java/MultipleInheritance/Interfaces/InterfaceDefaultCheck.java
src/main/java/MultipleInheritance/Interfaces/InterfaceDefaultCheck.java:23: error: types A and B are incompatible;
class C3 implements A, B {
^
  class C3 inherits unrelated defaults for execute() from types A and B
1 error
 */

class C4 implements A, B {
    // обращение к интерфейсу как при переопределении метода класса
    @Override
    public void execute() {
        // ссылаюсь на определенный метод определенного суперкласса
        A.super.execute();
    }
}

class C5 implements A, B {
    public void execute() {
        System.out.println("C5 - своя реализация execute");
    }
}

public class InterfaceDefaultCheck {
    public static void main(String[] args) {
        C1 c1 = new C1();
        c1.execute(); // интерфейс A: default метод

        C2 c2 = new C2();
        c2.execute(); // интерфейс B: default метод

        C4 c4 = new C4();
        c4.execute(); // интерфейс A: default метод

        C5 c5 = new C5();
        c5.execute(); // C5 - своя реализация execute
    }
}

```
##### я уже переопределил метод, зачем писать аннотацию Override?
- подсказка для компилятора - в compile time при прочтении метки Override компилятор
  - проверит наличие метода с аннотацией @Override в суперклассе или интерфейсе
    - семантически суперкласс и интерфейс суть одна конструкция
  - если для метода указана аннотация @Override, но метода нет в суперклассе или интерфейсе, компиляции завершится с ошибкой

```java
interface A {
    default void execute() {
        System.out.println("интерфейс A: default метод");
    }
}

interface B {
    default void execute() {
        System.out.println("интерфейс B: default метод");
    }
}

class C0 implements A, B {
    @Override
    public void execute() {
        System.out.println("корректно переопределил метод");
    }
    @Override
    public void execut() {
        System.out.println("ошибся в наименовании переопределяемого метода");
    }
}
/*
javac src/main/java/MultipleInheritance/Interfaces/InterfaceDefaultCheck.java
src/main/java/MultipleInheritance/Interfaces/InterfaceDefaultCheck.java:22: error: method does not override or implement a method from a supertype
    @Override
    ^
1 error
 */
```

---

- решение конфликта наследования - [переопределение метода](../src/main/java/MultipleInheritance/Interfaces/DOverride.java)
- решение конфликта наследования - [вызов super](../src/main/java/MultipleInheritance/Interfaces/DSuper.java) - явное указание на интерфейс, из которого брать реализацию метода

- возможная реализация множественного наследования - наследовать класс И реализовать интерфейс
  - операция Зачисление наследует класс Операция - поле суммы 
  - операция Зачисление наследует интерфейс Действия - метод Выполнить
  - [пример](../src/main/java/MultipleInheritance/Interfaces/Deposit.java)

---

в родо-видовой классификации -
Интерфейс - родовое понятие, обобщtнная форма (например, Фигура, Двигаемый).
Класс - видовое понятие, конкретизация (например, Квадрат, Автомобиль).

---

#### Абстрактные классы VS Интерфейсы
> Интерфейсы являются типами, в том смысле что переменную можно указать тип который интерфейс
> В этом смысле думаю надо провести различие между абстрактными классами и интерфейсами - распиши вот этот момент

##### Абстрактный класс
- Абстрактный класс и Интерфейс применяются в роли суперклассов

| Абстрактный класс                                                                                                                                             | Интерфейс                                                                                                                                                |
|---------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------|
| содержит поля и методы С ЛОГИКОЙ (реализацией) - структуру и поведение                                                                                        | Не содержит реализацию (в более ранних версиях Java), в Java 8+ может содержать default и static методы с логикой, в Java 12+ - private методы с логикой |
| задает конкретное общее поведение - конкретное - значит, содержит логику - поля, константы (вариант полей с модификатором final), конструкторы, static методы | задает абстрактное общее поведение - объявляет public abstract методы - абстрактное здесь - содержит имена полей и методов, не содержит логики           |
| определяет состояние                                                                                                                                          | определяет поведение                                                                                                                                     |
| наследование обозначается ключевым словом `extends`                                                                                                           | наследование обозначается ключевым словом `implements`                                                                                                   |
| наследование одиночное                                                                                                                                        | наследование множественное                                                                                                                               |
| задача - обобщение сущностей по содержанию                                                                                                                    | задача - обобщение сущностей по поведению                                                                                                                                                         |

> конкретизируй
> | определяет состояние | определяет поведение |

###### Состояние
- набор значений полей - членов класса - в определенный момент времени
- абстрактный класс определяет набор таких полей, или, структуру состояния
- дает структурированный подход при наследовании, за счет того, что поля заданы единожды, помогает избежать ошибки при создании подклассов
```java
import java.math.BigDecimal;

abstract class Account {
    private BigDecimal balance; // определили поле, это поле суть состояние
    
    void setBalance(BigDecimal amount) {
        this.balance = amount;
    }
}
public class Main {
    public static void main(String[] args) {
        Account account = Account();
        
        account.setBalance(BigDecimal.valueOf(100));
        // состояние экземпляра счета определено как значение баланса на данном шаге

        account.setBalance(BigDecimal.valueOf(1000));
        // состояние экземпляра счета изменилось
    }
}
```
###### Поведение
- набор методов класса, или действий, которые способны выполнять подклассы, реализующие интерфейс
```java
/**
 * Интерфейс активного счета
 * требует реализовать методы пополнения, снятия, перевода
 * 
 * если потребуется изменить контракт, например, добавить действие начисления процентов,
 * следует добавить метод - или поведение - в интерфейс
 */
public interface Payable {
    void Deposit();
    void Withdraw();
    void Transfer();
}
```

#### Наследование и Интерфейсы
> про наследование и интерфейсы как оно фактически устроено
https://chat.qwen.ai/s/6c4d8186-cacf-4447-b3ca-111977e2bc04?fev=0.0.243

###### invokevirtual в jvm
- в java определены виртуальные и невиртуальные методы класса
- невиртуальные: static, private, final
- "виртуальность" - ...
- прочие методы - виртуальные
- invokevirtual - команда вызова виртуальных методов, ее выполнение определяется компилятором, то есть решение виртуальный/невиртуальный принимается в compile time
- в runtime задача jvm - найти метод, указанный после команды invokevirtual
- задача решается поиском метода в таблице виртуальных методов vtable, определенной для класса
  - vtable создается ...
- vtable фиксирована, поэтому поиск эффективен - один к одному - для каждого метода строго один адрес в vtable

###### invokeinterface в jvm
- команду invokeinterface компилятор определяет для методов, наследующих / реализующих интерфейс
- в runtime jvm - найти метод, указанный после команды invokeinterface
- к объему определений vtable добавляется объем itable - таблицы методов, декларированных в интерфесах, которые реализует класс
- itable потенциально менее эффективна из-за возможности существования многих реализаций метода с одним именем
  - требуется последовательно проверить реализации, чтобы найти соответствующую обрабатываемой команде

---



### композиция, делегирование
- поведение реализуется как поле класса
  - то есть поведение - отдельный класс, несвязанный наследованием с реализуемым классом
- происходит делегирование поведения вместо наследования
  - делегирование - вызов методов другого объекта, который передан в класс как поле-поведение
- поведение изолируется в классе-поведении

# todo
> исследуй возможности IDEA в работе с кодом делегации


---

## Реализация в других ЯП

#### C++
- множественное наследование классов - среди ЯП СТ - допускается в C++
- проблема конфликта наследования решается в C++ прямым указанием "какой метод от какого класса наследовать"

### C#, Kotlin
- множественное наследование запрещено: один суперкласс
- обходное решение: интерфейсы + композиция

### Groovy

> Абстрактные классы могут наследоваться от абстрактных классов
> Если будет цепь наследования абстрактных классов (A -> B -> C) то это нельзя назвать множественным наследованием формально
> Но так примерно работает scala
> Вот этот момент trait scala и как это решает проблему ромба надо рассмотреть

> Groovy и scala , в части trait являются статически типизируемые
> И при этом trait действительно предоставляют множественное наследование в том смысле что я писал - наследование реализаций
> Вопрос, как в них решается проблема ромба
> И как миксины решают этот же вопрос?

множественное наследование: 
- https://www.baeldung.com/groovy-traits
- https://groovy-lang.org/objectorientation.html#_traits
типизация:
- https://groovy-lang.org/semantics.html#_typing
- https://groovy-lang.org/semantics.html#_dynamic_vs_static

Groovy:
- компилируется в байт-код, который выполняет JVM
- позволяет использовать библиотеки и пакеты Java
- поддерживает динамическую типизацию:
  - способен определять типы переменных на этапе runtime, после компиляции 
  - способен разрешить поля и методы классов на этапе runtime, после компиляции 
  - переменные способны изменять свой `тип данных` в ходе выполнения программы
    - изменение типа данных переменной - изменение ссылки переменной - переменная ссылается на значение типа X, далее по ходу выполнения переменная ссылается на значение типа Y
    - изменение типа отслеживает механизм `динамического разрешения методов`
      - если для переменной указан семантический маркер def, 
        - тип переменной не будет проверяться на этапе компиляции
        - переменная будет разрешаться динамически
      - объект Groovy содержит MetaClass, который содержит информацию о действующем типе объекта
```groovy
def x = "hello" // def обозначает, что тип значения переменной определять на этапе runtime
println(x) // hello
// переменная указывает на значение типа String
println(x.getClass()) // class java.lang.String

println(x) // 1
// переменная указывает на значение типа Integer
println(x.getClass()) // class java.lang.Integer
```

- запрещено множественное наследование классов
- разрешено множественное наследование трейтов
- проблема ромба решается
  - явным переопределением методов
  - явной ссылкой на trait, из которого брать реализацию


---

javascript
- обходное решение: миксины - https://javascript.info/mixins
- наследование от прототипов
  - один объект может наследовать от одного прототипа  
  - миксин - объект, объединяющий функции, определяющие поведение
  - миксин - последовательность таких функций/поведений
  - в каком порядке указаны функции в миксине, в таком и разрешаются (как бы наследуются) - однозначно

### Scala

> Абстрактные классы могут наследоваться от абстрактных классов
> Если будет цепь наследования абстрактных классов (A -> B -> C) то это нельзя назвать множественным наследованием формально
> Но так примерно работает scala
> Вот этот момент trait scala и как это решает проблему ромба надо рассмотреть

> Groovy и scala , в части trait являются статически типизируемые
> И при этом trait действительно предоставляют множественное наследование в том смысле что я писал - наследование реализаций
> Вопрос, как в них решается проблема ромба
> И как миксины решают этот же вопрос?

вот тут про scala
https://scala-lang.org/files/archive/spec/3.4/05-classes-and-objects.html

scala traits
- множественное наследование разрешено: trait - https://docs.scala-lang.org/tour/traits.html

- trait в scala - аналог interface в java
- trait может определять поля и методы
- классы и объекты могут наследоваться от traits и могут добавлять методы
- запрещено создание экземпляра из trait
- применение - создание дженерика - описания типов данных полей и методов подклассов 

> опиши, как trait решает проблему ромба
- в scala запрещено множественное наследование классов
- в scala разрешено множественное наследование трейтов
- проблема ромба принципиально невозможна в scala как следствие механизма наследования трейтов
  - причина проблемы ромба - неоднозначность порядка наследования - в scala отсутствует
  - порядок наследования - или, порядок композиции - всегда линейный
  - линейность достигается семантическим требованием - при множественном наследовании указывать порядок наследования с помощью ключевого слова `with`
  - `class D extends B with C` - справа налево - C наследует от B

---

### Python
- множественное наследование классов - среди ЯП ДТ - допускается в Python

проблема - определить реализацию наследуемого метода

решение - построить порядок разрешения методов

задача - решение проблемы линеаризации - приближенно представить замкнутую нелинейную систему

для решения применяется алгоритм (Си-Три Линеаризации) - пишется `C3`, что можно ошибочно прочитать как `СЗ` и даже как `С3` 

результат работы алгоритма - линеаризация класса - упорядоченный список классов

построение линеаризации класса для линейной структуры
```text
A
|
B
|
C
```
Линеаризация для класса C есть [C, B, A]

- вызывается метод C.method()
- поиск реализации method() происходит в классе C
- если method() не найден в классе C, поиск происходит в классе B
- если method() не найден в классе B, поиск происходит в классе A
- если метод найден, он будет выполнен
- если не найден, будет выброшено исключение AttributeError


построение линеаризации класса для нелинейной структуры
```text
   A
 /   \
B     C
 \   /
   D
```
возможны две линеаризации класса D 
- [D, B, A, C]
- [D, C, A, B]

такие линеаризации не позволят разрешить наследование из-за последовательностей [A, C], [A, B]
последовательности должны быть монотонными - для любого нового потомка сохраняется последовательность предков
пример: 
- создание класса E, наследующего D
- если линеаризация D - [D, B, A], то для E - и всех его наследников - последовательность [D, B, A] неизменна

для ромба имеем две монотонные линеаризации
- [D, B, A]
- [D, C, A]
при объявлении класса указываем порядок наследования
`class D(C, A)` или `class D(В, A)`, в зависимости от задачи 

#### Процедура построения порядка разрешения методов в Python
- выполняет
- интерпретатор считывает определение класса
  - `class D3(A, B, C)`
- интерпретатор считывает базовые классы из кортежа наследования `(A, B, C)`
  - A -> B -> C, стрелка указывает на родителя
- для считанных из кортежа классов интерпретатор выполняет проверку согласованности порядка разрешения методов (MRO)
- MRO определяет порядок проверки классов при множественном наследовании
- реализован посредством алгоритма СЗ реализации
  1. определяет линейную последовательность классов
  2. для каждого класса в последовательности формирует список всех суперклассов согласно порядку наследования
  3. каждый суперкласс в последовательности располагается перед всеми своими наследниками
- при обнаружении противоречия наследования, например, циклического наследования, интерпретатор выбросит исключение ошибки типа
- при успешной проверке интерпретатор продолжает процедуру определения класса

Построение MRO - часть фазы компиляции класса в Python
При отсутствии стадии компиляции Python кода в целом, фазу создания класса называют "компиляцией"

Фаза компиляции класса Python включает этапы:
- синтаксический анализ кода
  - парсинг текста исходного кода класса
- сборка тела класса
  - выполнение тела класса в локальной области видимости
- построение MRO
  - проверка согласованности наследования
- создание класса
  - вызов процедуры type - или - вызов метакласса


- пример

```python
class A:
    def method(self):
        print('class A')


class B(A):
    def method(self):
        print('class B')


class C(A):
    def method(self):
        print('class C')


class D1(B, C):
    pass


class D1_1(B, C, A):
    """По сути - повтор класса D1
    с отличием в том, что явно указан суперкласс A"""
    pass


class D2(C, B):
    pass


class D2_1(C, B, A):
    """По сути - повтор класса D2
    с отличием в том, что явно указан суперкласс A"""
    pass

    # class D3(A, B, C):
    """
    на этапе построения порядка разрешения методов
    будет выброшено исключение
        TypeError: Cannot create a consistent method resolution
        order (MRO) for bases A, B, C

    реализация класса D3 содержит ошибку
    - правило MRO в Python - суперкласс передается ПОСЛЕ наследников
        - причина ошибки - автор положился на интуицию о том,
            что интерпретация происходит "естественным" образом слева направо
        - список наследников разрешается справа налево
        D(A -> B -> C) - стрелка указывает на родителя, но не на порядок разрешения методов,
            с этим учетом ошибка очевидна

    """
    # pass


if __name__ == '__main__':
    d1 = D1()  # порядок наследования B -> C -> A
    
    # порядок наследования
    # - object - базовый класс для всех объектов в Python
    # - D1 - класс экземпляра, для которого запросили mro
    print(type(d1).mro())  # [<class '__main__.D1'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]
    
    d1.method()  # class B
    # d1.bad_method()  # при выполнении будет выброшено исключение AttributeError, так как реализация bad_method не будет найдена
    # Traceback (most recent call last):
    #   File "/home/region.cbr.ru/65nokhrinav/projects/pythonProject/multiple_inheritance.py", line 63, in <module>
    #     d1.bad_method()  # class B
    #     ^^^^^^^^^^^^^
    # AttributeError: 'D1' object has no attribute 'bad_method'

    d4 = D1_1()  # порядок наследования B -> C -> A
    d4.method()  # class B

    d2 = D2()  # порядок наследования C -> B -> A
    d2.method()  # class С

    d5 = D2_1()  # порядок наследования C -> B -> A
    d5.method()  # class С
```
