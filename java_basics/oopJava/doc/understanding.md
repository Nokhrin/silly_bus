#### Полиморфизм

- как работает полиморфизм,
- привести примеры,
- что было бы если этот механизм отсутствовал при условии сохранения статической типизации
  - (т.е. как бы ты выкручивался бы, см варианты type cast / class cast)
- определить понятия contains, aggregates, implements в задаче наследования
- Агрегация VS Наследование

##### Понятие и Понимание полиморфизма
- принцип ООП
- реализуется в Java с помощью `абстрактных классов`, `интерфейсов`, `суперклассов`
- дословно обозначает `возможность принимать множественные формы`

> что такое форма?
- форма - реализация поведения - пример: метод `выполнить`

> как кодируется форма?
- метод `perform` в классах
  - [Deposit](../src/main/java/Deposit.java),
  - [Withdrawal](../src/main/java/Withdrawal.java),
  - [Transfer](../src/main/java/Transfer.java)
- метод носит одинаковое имя в трех разных классах - отсюда понимаем метод `perform` как единую сущность
- метод выполняет определенный для него в классе код - метод `perform` называется одним именем, но реализован по-разному
- каждая уникальная реализация метода `perform` - есть _форма_ метода `perform`

> как определить тип объекта, на который указывает ссылка?
- если считать типом объекта А имя класса, экземпляром которого является объект А, то тип объекта можно определить
  - выполнением оператора `isinstanceof` - пример: `operation isinstanceof Deposit`
    - вернет `true`, если ссылка `operation` указывает на экземпляр класса `Deposit`
  - выполнением метода `Object.getClass()` - пример: `operation.getClass().getSimpleName()`
    - вернет `Deposit`, если ссылка `operation` указывает на экземпляр класса `Deposit`

##### Применение полиморфизма в текущей задаче
- есть класс Операции
- класс операции содержит метод выполнения операции `perform`
- от класса Операции наследуются классы Пополнение, Снятие, Перевод
- каждый метод-наследник переопределяет метод `perform` - то есть, реализует характерную процедуру выполнения
  - выполнение для Пополнения - добавление суммы Операции к балансу счета
  - выполнение для Снятия - вычитание суммы Операции из баланса счета
  - выполнение для Перевода - вычитание суммы Операции из баланса счета отправителя, добавление суммы Операции к балансу счета получателя

> Меня в этом описании, смущают общие слова. Мне прям описание требуется, механики

`Operation` - абстрактный класс  
абстракция здесь - общее для некоторых сущностей множество атрибутов  
таким - общим - атрибутом в `Operation` яаляется метод `perform`  
общим для кого?  
для классов-наследников  
классами-наследниками являются `Deposit`, `Withdrawal`, `Transfer`  
класс-наследник переопределяет родительский метод `perform`
- то есть реализует свой способ выполнения метода `perform`
- `способ выполнения` [выше](README.md:411) был назван `формой`
- полиморфизм - многоформие - гарантирует, что в каждом наследнике будет метод родителя, в данном примере - `perform`  
  зачем наследовать, если реализация своя?  
  наследовать, чтобы гарантировать наличие метода `perform` в множестве классов и их экземплярах

один метод - `perform` - разные реализации `Deposit.perform`, `Withdrawal.perform`, `Transfer.perform`

- Роль полиморфизма на этапе компиляции  
  на этапе компиляции выполняется проверка синтаксиса, проверка типов, проверка графа наследования, пример:  
  `Operation op = new Deposit(BigDecimal.valueOf(500.00));`
- компилятор проверяет
  - Deposit наследует Operation
  - конструктор Deposit существует и принимает аргументы, заявленые в компилируемом коде - в данном случае экземпляр класса BigDecimal  
    `op.perform(account)`
- компилятор проверяет
  - класс Operation, экземпляром которого является объект `op`, содержит метод `perform`
  - компилятор сверяет ожидаемый принимаемый тип аргумента `perform` с типом фактически переданного объекта `account`

- компилятор записывает в байт-код метод `Operation.perform()`

- проявление полиморфизма
  - на этапе выполнения (в райнтайме/runtime)
  - реализацию метода выберет JVM
- Как JVM знает, что op - это Deposit?
  - для private методов - с помощью "статического связывания" - выбор реализации метода на этапе компиляции,  до выполнения программы
  - для public методов - методов, которые могут быть переопределены - с помощью "динамического связывания" - на основе знания типа объекта
  - динамическое связывание - это привязка ключ-значение, которые записываются в системную таблицу vtable
  - пример vtable

```text
vtable для класса Deposit:
[0]  Object.hashCode()
[1]  Object.equals()
[2]  Object.toString()
[3]  Operation.perform() → указатель на метод Deposit.perform()
```

- при выполнении JVM читает имя класса - Deposit, находит в vtable связанный с ним метод Deposit.perform, выполняет Deposit.perform
---

##### Динамика VS Статика

- дан код на языке программирования с динамической типизацией

```python
class A:
    def say_hello(self):
        print('hello from A')

class B:
    def say_hello(self):
        print('hello from B')

a = A()
a.say_hello()

a = B()
a.say_hello()
```
дает вывод
```text
hello from A
hello from B
```

- дан [такой же - уже не рабочий - код на java](../src/main/java/DemoTyping/MainBroken.java)
  дает ошибку компиляции
```text
src/main/java/DemoTyping/MainBroken.java:6:11
java: variable a is already defined in method main(java.lang.String[])
```

- дан [похожий рабочий код на java](../src/main/java/DemoTyping/MainOperational.java)

> задача - развернуто объяснить механику возникновения ошибки


- рассмотрим код Python
```python
class A:  # объявление класса
    def say_hello(self):  # объявление метода - сигнатура
        print('hello from A')  # объявление метода - тело

class B:
    def say_hello(self):
        print('hello from B')

# A() - вызов инициализатора класса A -> создание экземпляра класса А
# при создании экземпляр класса А получает идентификатор - встроенный атрибут `id`
# `a = ` - создание ссылки `a`, ссылка `a` содержит `id` объекта - экземпляра класса А
a = A()
# вызов метода экземпляра класса А
a.say_hello()

# B() - вызов инициализатора класса B -> создание экземпляра класса B
# при создании экземпляр класса B получает идентификатор - встроенный атрибут `id`
# `a = ` - создание ссылки `a`, ссылка `a` содержит `id` объекта - экземпляра класса B
# `a` принимает значение id эземпляра класса B, 
#  таким образом, ссылка на экземпляр А потеряна, экземпляр A будет ликвидирован сборщиком мусора
a = B()  # переменная `a` теперь хранит id экземпляра класса B
# вызов метода экземпляра класса B
a.say_hello()
```

- рассмотрим корректный код Java

```java
public class MainOperational {
    public static void main(String[] args) {
        // new A() - вызов конструктора класса А -> создание экземпляра класса А
        // A a = - объявление переменной `a`, предназначенной для хранения ссылки на экземпляр класса A, установка ссылки на экземпляр класса A
        // аналогично для B
        A a = new A();
        B b = new B();

        // вызов метода объекта, ссылка на который содержит переменная `a`, `b`
        a.sayHello();
        b.sayHello();
    }
}
```

- рассмотрим некорректный код Java
```java
public class MainBroken {
    public static void main(String[] args) {
        // new A() - вызов конструктора класса А -> создание экземпляра класса А
        // A a = - объявление переменной `a`, предназначенной для хранения ссылки на экземпляр класса A, установка ссылки на экземпляр класса A
        A a = new A();

        // new B() - вызов конструктора класса B -> создание экземпляра класса B
        // A a = - объявление переменной `a`, предназначенной для хранения ссылки на экземпляр класса A
        // установка ссылки переменной для типа `A` на объект типа `B` -> недопустимая операция, 
        //  поскольку `a` предназначена только для указания на экземпляры `A`

//        A a = new B();  // строка, вызывающая ошибку компиляции

        //  можно создать новый экземпляр класса A - это работает, так как `a` определена для работы с A
        A a = new A();
        
        // дважды вызвать метода объекта, ссылка на который содержит переменная `a`
        a.sayHello();
        a.sayHello();
    }
}
```

---

- выполнить для некорректного кода
1) Что бы использовалась только одна переменная a
2) использовались оба объекта A, B
3) используй механизм полиморфизма, создай третий общий класс

- задача
  - сохранить статическую типизацию,
  - сохранить имена методов

[реализация](../src/main/java/DemoTyping/MainPoly.java)

---

[Почему подсказки типов / аннотации типов в Python - отстой](why-type-hinting-sucks.md)

---

### объяснить связь `ссылка на объект` и `vtable`

`ссылка на объект`
- определение - это объект, в одном из полей которого записана **адрес в памяти**, по которому располагается объект, на который указывает ссылка
- задача - использовать один экземпляр объекта, не создавать копии для операций, выполняемых над объектом
- пример:
  - `A a = new A();`
  - new A() - выражение, выполняющее конструктор, создающий в памяти экземпляр класса A
  - a - ссылка на созданные экземпляр класса A
  - A - тип ссылки

`невиртуальный метод`
- в Java - метод, который не может быть переопределен: (static ИЛИ final ИЛИ private)
- JVM вызывает `невиртуальный метод` **по типу ссылки на объект**

`виртуальный метод`
- в Java - метод, который может быть переопределен: НЕ (static ИЛИ final ИЛИ private)
- JVM вызывает `виртуальный метод` **по типу объекта**
- для определения "реального" метода, который в коде переопределен виртуальным, выполнение которого код требует от JVM,
  JVM использует `vtable`

## жизненный цикл методов в java
### компилятор
- принимает исходный код (источники: файлы *.java)
- переводит исходный код на язык инструкций
  > ...
  > invoke virtual #myVirtMethod   // вызвать виртуальный метод
  > invoke static  #myStaticMethod // вызвать статический метод
  > ...
- записывает инструкции в формате `байт-кода JVM` - внутреннем формате виртульной машины Java
  - в байт-коде каждая инструкция представлена **одним** байтом
  - байт-код состоит из последовательности байтов
- байт-код может храниться в памяти, может быть записан в файлы *.class, может быть передан по сети, минуя запись на диск

---
исходный код с виртуальным и статическим методами
```java
package DemoTyping;

public class C {
    void sayHello() {
        System.out.println("hello from C");
        System.out.flush();
    }

    public static void sayStatic() {
        System.out.println("STATIC hello from C");
        System.out.flush();
    }
}
```

```java
package DemoTyping;

public class D extends C {
    @Override
    void sayHello() {
        System.out.println("hello from D");
        System.out.flush();
    }
}
```

```java
package DemoTyping;

public class MainPoly {
    public static void main(String[] args) {
        C c;

        c = new C();
        c.sayHello();
        C.sayStatic();

        c = new D();
        c.sayHello();
        D.sayStatic();  // sayStatic унаследован, не переопределен
    }
}
```

инструкции, сгенерированные компилятором из кода, прочитанного из файла `MainPoly.java`
```text
Compiled from "MainPoly.java"
public class DemoTyping.MainPoly {
  public DemoTyping.MainPoly();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public static void main(java.lang.String[]);
    Code:
       0: new           #7                  // class DemoTyping/C
       3: dup
       4: invokespecial #9                  // Method DemoTyping/C."<init>":()V
       7: astore_1
       8: aload_1
       9: invokevirtual #10                 // Method DemoTyping/C.sayHello:()V
      12: invokestatic  #13                 // Method DemoTyping/C.sayStatic:()V
      15: new           #16                 // class DemoTyping/D
      18: dup
      19: invokespecial #18                 // Method DemoTyping/D."<init>":()V
      22: astore_1
      23: aload_1
      24: invokevirtual #10                 // Method DemoTyping/C.sayHello:()V
      27: invokestatic  #19                 // Method DemoTyping/D.sayStatic:()V
      30: return
}
```

- `9: invokevirtual #10                 // Method DemoTyping/C.sayHello:()V`
  - команда вызова виртуального метода
- `12: invokestatic  #13                 // Method DemoTyping/C.sayStatic:()V`
  - команда вызова статического метода


### JVM
- принимает байт-код из источника (из памяти, файлов, сетевых подключений)
- проверяет байт-код
- загружает классы

`vtable`
- table - таблица, v - virtual
- синонимы: `virtual method table` / `VMT`, `dispatch table`
- сущность - структура данных
- функция - динамическое связывание
- задача - определить адрес в памяти, с которого начать выполнение

---


- объяснить понятие `виртуальный метод`
- объяснить хранение типа объекта во время исполнения / в runtime

---

- выделить ключевые мысли - [reddit - типизация с подсказками](https://www.reddit.com/r/Python/comments/10zdidm/why_type_hinting_sucks/)
- выделить ключевые мысли - [reddit - статическая типизация](https://www.reddit.com/r/programming/comments/141hzil/why_static_typing_came_back_richard_feldman/)



---

##### Обобщение

> почитать и осмыслить

- понятие `Родо-видовые понятия` из логики
- термины `sub-typing` и `ко-вариация` из программирования

---

В результате прочтения , того что я скинул должно появиться пара или больше абзацев,
которые обощат опыт текущей задачи - полиморфизма

Обощение должно включать что общего между примером js, python и разного по ключевым вопросам.

Ключевой ... почему так по разному ведут два этих языка (1. Js, python, 2. Java) в вопросе полиморфизма и статич. типизации

Какие примущества и недостатки этих разных подходов дает тебе как программисту и тестировщику.
