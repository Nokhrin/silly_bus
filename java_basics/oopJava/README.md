# Базовые основы ООП

# Цели и задачи

## Общие цели

1. создание классов
2. наследование и виртуальные методы / полиморфизм
3. интерфейсы / полиморфизм
4. ограничение наследования + pattern matching

Практические части будут направлены на освоение этих тем

## Конкретные темы

1. Классы
   - Данные
   - Конструкторы и методы
2. Инкапсуляция
   - public, private, protected
3. Наследование. Полиморфизм
   - Согласованность инкапсуляции с наследованием
   - Частичный доступ protected, default
   - интерфейсы
   - Под-типизация (Sub typing)
     - instance of
     - pattern matching (switch)
   - Непредвиденное поведение из-за наследования
     - Нарушение equals / hashcode
   - Ограничение наследования
     - final (record /classes)
     - sealed
     - pattern matching

## Ожидаемые результаты

1. должны быть сформированы понятия о типах в контексте JAVA, не фундаментально, хотя бы приблеженно
2. разобраться
   а) Что такое интерфейс, отличие от класса
   б) класса от абстрактного класса
   в) абстрактного класса от интерфейса
   г) отличие интерфейсов версии java 7 и более ранних от текущей java 17+
3. разобраться с наследованием
   а) наследование класса от класса
   б) класса от абстрактного класса
   в) абстрактного класса от класса
   г) класса от интерфейса
   в) класса от интерфейсов
   д) класса от класса и интерфейсов
   е) ограничение наследования через final
   ж) ограничение наследования через sealed
   з) ограничение наследования через sealed для интерфейсов
   и) обход ограничения наследования sealed, через non-sealed
4. разобраться как наследование работает с модификаторами доступа (public, protected, private, default) применительно к методам, полям, классов и интерфейсов
5. попытаться найти объяснение почему не наследуются поля в контексте интерфейсов
6. сформулировать принципиальное отличия статической типизации от динамической - сравнить с python
- выдать перечень когда статическая типизация хорошо, когда плохо


## Средства достижения цели

В качестве практики будет взята предметная область и запрограммировано приложение


# Практика

## Функциональные требования

Консольное приложение для управления банковскими счетами

реализующее операции: 
- открытие счета
- пополнение счета
- снятие со счета
- перевод со счета на счет
- проверка баланса счета
- закрытие счета


### CLI
- Ответы содержат:
    - `ok [сообщение]` - успех,
    - `err [сообщение]` - ошибка
- Общий синтаксис команд и ответов
    - комада [аргумент1 [аргумент2 [...]]
    - команда и аргументы разделяются пробелами
    - ok [сообщение]
    - err [сообщение]
- Аргументы разделяются **одиночными пробелами**

### Поддерживаемые команды и формат аргументов:

```text
open                                → создать новый счет (возвращает номер)
close <номер_счета>                 → закрыть счет
deposit <номер_счета> <сумма>       → пополнить счет
withdraw <номер_счета> <сумма>      → снять со счета
transfer <номер_счета> <сумма>      → перевести со счета на счет
balance <номер_счета>               → посмотреть баланс
list                                → вывести список всех открытых счетов
```

### Обработка ошибок
- `not found` - счет не существует
- `not enough funds` - недостаточно средств для снятия
- `invalid input` - некорректный ввод

### Тестирование
- Тесты пишутся **применительно к классу `BankAccountSystem`**
- CLI-ввод не тестируется
- Тесты должны **покрывать все требования первого комплекта**:
  - открытие, 
  - пополнение, 
  - снятие, 
  - баланс, 
  - закрытие

### Пример взаимодействия с приложением

```shell
> # закрытие счета → счета не существует → ошибка
> close 12
<err account not found

> # открытие счета → счета не существует → успех
> open
<ok 12

> # пополнение счета - id=12, +34 руб → счет существует → успех
> deposit 12 34
<ok

> # снятие - счет id=12, -43 руб → недостаточно средств → ошибка
> withdrawal 12 43
<err not enough funds

> # снятие - счет id=12, -31 руб → достаточно средств → успех
> withdrawal 12 31
<ok
```

---

## Проектирование

### Основные сущности

#### Счет

- Уникальный номер - UUID - тип `UUID`
  - нельзя открыть счет с уже существующим номером, если счет с существующим номер НЕ закрыт
- Баланс - вещественное число - тип `BigDecimal`
- Счет может быть открытым или закрытым
- Произвольное количество счетов

#### Пополнение счета
  - нельзя пополнить счет суммой 0 или меньше

#### Снятие со счета
  - нельзя снять денег, больше чем есть на балансе
  - снятие денег возможно при положительном балансе

#### Перевод со счета на счет
  - Равнозначно операциям снятия и пополнения

#### Заем/Кредит
#### Списание процентов по кредиту
#### Просрочка

---
Со счетом (не владельцем счета, а именно со счетом)
может быть связано 0 или более кредитов

Для одного счета есть лимит суммы всех активных кредитов, открыть новый кредит нельзя

Кредит может быть в двух состояниях:
- Активен (начальное) -средства со счета банка выделены на счет владельца
- Закрыт (конечное) -средства переведены со счета владельца на счет банка



### Диаграммы

- вычитать постановку,
- найти сущности в тексте и какие есть между ними операции,
- нарисовать отношения в виде диаграммы
  - Диаграмму состояний и/или диаграмму последовательности
    - определить для каждой операции какие сущности учавствуют
    - Как и в какой последовательности меняются
    - Определить (не) допустимость операций - т.е. проверки и отобразить на диаграмме
  - Операций должно быть 4, но сначала сделать 3 - надо для учебной задачи
    - Пополнение, Снятие, Перевод
    - Кредиты (допустим требование о них появилось во втором релизе)
    - То есть должно быть 2 комплекта диаграмм

- Диаграммы могут использоваться для двух разных языков
  - Первый для описания, что должно делать программа, но без учета специфики, ООП/Java
  - Второй будет уже специфика, возможно потребует по править первые диаграммы

---

#### Диаграмма классов


#### Диаграмма состояний

- начальное состояние: определяет, какие данные и условия считаются доступными к моменту старта

| Элемент                              | Описание                                                                 |
|--------------------------------------|--------------------------------------------------------------------------|
| Входные данные от внешних источников | Например, инициация события («запрос на регистрацию», «поступил заказ»). |
| Состояние внешней среды              | Например, сеть подключена, оборудование включено, база данных доступна.  |
| Параметры системы                    | Настройки, идентификаторы, права доступа (если они заданы до начала).    |
| Состояние хранилища данных           | Например, база пуста, но доступна для записи.                            |
| Временные метки                      | Текущее время, дата - могут быть использованы для инициализации.         | 

    > Пример: Система контроля доступа
    > **Событие**: «Пользователь подошел к двери».
    > **Доступные данные**:
    >     - ID карты (считано считывателем).
    >     - Время суток (для проверки действия пропусков).
    >     - Статус двери (закрыта, открыта, аварийно открыта).
    >     - Список разрешенных карт (из хранилища).
    > 
    > Начальное состояние: «Ожидание ввода карты»  
    > → Система готова проверить карту, если считыватель работает.

#### состояние/прямоугольник

1. Это не результат работы
2. Это условное **состояние памяти** компютера или "системы",
   - возможно оперативной памяти, возможно жесткого диска или комбинации

Состояние (прямоугольник) на диаграмме состояний включает:  
- имя состояния,  
- входные действия,  
- выходные действия,  
- длительные действия,  
- возможные подсостояния.

пример

```plaintext
[Работает]
  entry / запустить мониторинг подключения
  do / обновлять статус каждые 30 секунд
  exit / остановить поток мониторинга
```

В этом примере:
- **Имя состояния**: `Работает`
- **Входное действие**: `запустить мониторинг подключения`
- **Длительное действие (внутри состояния)**: `обновлять статус каждые 30 секунд`
- **Выходное действие**: `остановить поток мониторинга`


#### стрелки/переходы
- **условие** `смены состояния`/`выполнения перехода`
  - ответь на вопрос `что вызывает смену состояния?`
- **действие**
  - действие не равно функции/методу


> Ввод данных и вывод результата, это отдельная задача, не связанная с самой логикой, на диаграммах только логика, без связи с user interface и без связи с каким либо языком программирования

- формат `[условие] / [действие]`
- пример
```
[Пользователь ввел логин и пароль]
    ↓
[проверка данных] → [доступ разрешен] / [открыть доступ к кабинету]
```

> Условие: `логин и пароль верны`  
> Действие: `открыть доступ к кабинету`

---

### Результаты работы

[Диаграмма классов](doc/uml/class-diagram-financial-entities.md)
[Диаграмма состояний - реализация](doc/uml/state-diagram-financial-entities.md)

---

## Кодирование

---

### Классы операций

> Задача - применить понятие полиморфизма из ООП

#### Требования
- [ ] конструктор - _без проверок_
- [ ] метод выполнения операции - `perform`
- [ ] учти свзянные операции, например, `открытие счета` и `закрытие счета`



#### Минимум ООП

Задача - выполнить очередь опереаций
Условие - без ООП
Цель - увидеть преимущества полиморфизма и наследования

- Каждый объект в очереди это экземпляр класса, который не наследует
- Каждая операция это какой то метод объекта, каждый со своим именем
- Можешь использовать метод getClass и операцию class cast/приведение типов
- Запрещено наследование методов

##### Решение

- определены два банковских счета
- определено множество операций: 
  - создание счета
    - параметры: баланс на счете при открытии счета,
  - зачисление на счет
    - параметры: сумма начисления, объект счета-получателя,
  - снятие со счета
    - параметры: сумма снятия, объект счета-источника,
  - перевод со счета на счет
    - параметры: сумма перевода, объект счета-источника, объект счета-получателя,
- определена очередь операций
  - очередь операций включает операции
    - зачисление на счет
    - снятие со счета
    - перевод со счета на счет
  - очередь операций представлена объектом коллекции
    - объект коллекции - экземпляр класса, реализующего интерфейс `Collection`
    - для решения применен класс `Queue` - в связи с близостью логики типа данных (FIFO) и проектируемой системы (очереди операций)
- определен цикл, в теле которого производится
  - извлечение операции из очереди
  - выполнение операции

###### Понятия
> Collection - интерфейс коллекций, существующих в Java
> Queue - класс, реализующий интерфейс Collection

###### Проблема
- каждая операция реализована отдельным классом без применения наследования, то есть
  - тип операции, соответственно, поля и методы операции, неизвестны до извлечение
- при извлечении операции требуется
  - определить принадлежащие операции поля и методы
  - выполнить метод
- гарантируется, что каждая операция содержит только один публичный метод
  - имя метода неизвестно заранее 
  - нельзя жестко привязать "если операция - экземпляр класса Deposit, то выполнять метод performDeposit"
  - можно выполнить существующий метод при условии, что он единственный существующий

> решаем задачу динамической диспетчеризации операций

---
Сценарий - все операции валидны и успешны

- **Счет 1**: `1`, баланс: **5000.00 ₽**
- **Счет 2**: `2`, баланс: **3000.00 ₽**

| №   | Операция       | Параметры                                      | Ожидаемый результат                      |
|-----|----------------|------------------------------------------------|------------------------------------------|
| 1   | **Зачисление** | Сумма: 800.00, Счет-получатель: `1`            | Счет 1: **5800.00**                      |
| 2   | **Снятие**     | Сумма: 600.00, Счет-источник: `2`              | Счет 2: **2400.00**                      |
| 3   | **Перевод**    | Сумма: 1200.00, Источник: `1`, Получатель: `2` | Счет 1: **4600.00**, Счет 2: **3600.00** |
| 4   | **Зачисление** | Сумма: 450.00, Счет-получатель: `2`            | Счет 2: **4050.00**                      |
| 5   | **Снятие**     | Сумма: 900.00, Счет-источник: `1`              | Счет 1: **3700.00**                      |
| 6   | **Перевод**    | Сумма: 500.00, Источник: `2`, Получатель: `1`  | Счет 1: **4200.00**, Счет 2: **3550.00** |
| 7   | **Зачисление** | Сумма: 1100.00, Счет-получатель: `1`           | Счет 1: **5300.00**                      |
| 8   | **Снятие**     | Сумма: 1400.00, Счет-источник: `2`             | Счет 2: **2150.00**                      |
| 9   | **Перевод**    | Сумма: 750.00, Источник: `1`, Получатель: `2`  | Счет 1: **4550.00**, Счет 2: **2900.00** |
| 10  | **Зачисление** | Сумма: 300.00, Счет-получатель: `2`            | Счет 2: **3200.00**                      |

[реализация](src/main/java/NoOop/OpsQueue.java)

---

#### Применение Полиморфизма

Доп задание в рамках текущего
Дать пример устно/письменно:
- как работает полиморфизм, 
- привести примеры, 
- что было бы если этот механизм отсутствовал при условии сохранения статической типизации 
  - (т.е. как бы ты выкручивался бы, см варианты type cast / class cast)
- определить понятия contains, aggregates, implements в задаче наследования
- Агрегация VS Наследование

##### Применение в текущей задаче
- есть класс Операции
- класс операции содержит метод выполнения операции `perform`
- от класса Операции наследуются классы Пополнение, Снятие, Перевод
- каждый метод-наследник переопределяет метод `perform` - то есть, реализует характерную процедуру выполнения
  - выполнение для Пополнения - добавление суммы Операции к балансу счета
  - выполнение для Снятия - вычитание суммы Операции из баланса счета
  - выполнение для Перевода - вычитание суммы Операции из баланса счета отправителя, добавление суммы Операции к балансу счета получателя

##### Полиморфизм - идея, польза, понимание
- принцип ООП
- дословно обозначает `возможность принимать множественные формы`
- реализуется в Java с помощью `абстрактных классов`, `интерфейсов`, `суперклассов`

---



### Результаты работы