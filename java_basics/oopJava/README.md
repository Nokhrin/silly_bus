### **Практический план обучения ООП в Java: "Система обработки финансовых операций"**  
**Цель**: Изучить ООП через рефакторинг финансовой системы — от простых классов до sealed-иерархий с generics.  
**Особенности**:  
- Все задания — часть **единого проекта**, усложняющегося с каждой темой.  
- **Четкие требования** без примеров решений — только задачи для самостоятельного выполнения.  
- **Каверзные вопросы** проверяют понимание принципов, а не конкретную реализацию.  
- **Опора на предыдущие темы**: каждая новая задача использует результаты прошлых.  

---

### **1. Классы и объекты: Создание базовой транзакции**  
**Цель**: Освоить инкапсуляцию и валидацию данных.  
**Задания**:  
1. Реализуйте класс `Transaction` со следующими требованиями:  
   - Поля: `id` (строка), `amount` (число), `currency` (строка).  
   - Конструктор должен проверять:  
     - `amount > 0`,  
     - `currency` принадлежит списку `["USD", "EUR", "RUB"]`.  
   - При нарушении условий выбрасывать `IllegalArgumentException` с понятным сообщением.  
2. Напишите статический метод `validate(Transaction t)`, возвращающий `true` только для валидных транзакций.  
3. Создайте 3 объекта `Transaction`:  
   - Один валидный (например, `id="TX1", amount=100, currency="USD"`),  
   - Два невалидных (нарушение `amount` и `currency`),  
   - Убедитесь, что невалидные объекты не создаются.  

```java
 public class Transaction {
       private ? id;
       private ? amount;
       private ? currency;

       public Transaction(? id, ? amount, ? currency) {
         // . тут реализация .
         // Валидация: amount > 0, currency в списке ["USD", "EUR", "RUB"]
         // ....
       }
 }

 public class TransactionValidator {
    public static boolean validate(Transaction t) {
         // . тут реализация .
    }

// Проверка
try {
    new Transaction("TX1", 100, "USD"); // ?
    new Transaction("TX2", -50, "USD"); // ?
} catch (IllegalArgumentException e) {
    System.out.println(e.getMessage()); // ?
}

```   

**Каверзные вопросы**:  
- ❓ Как поведет себя программа, если поля класса объявить как `public` вместо `private`? Приведите пример сценария, где это нарушит бизнес-логику.  
- ❓ Что произойдет, если валидацию перенести из конструктора в метод `validate()`, но не вызывать его при создании объекта? Как это повлияет на целостность данных?  

**Ссылки**:  
- [Classes and Objects (Oracle)](https://docs.oracle.com/javase/tutorial/java/javaOO/classes.html)  

---

### **2. Наследование: Добавление типов операций**  
**Цель**: Расширить функционал через наследование, избежать дублирования.  
**Задания** (опираются на `Transaction` из п.1):  
1. Создайте иерархию классов:  
   - `Deposit` (пополнение счета),  
   - `Withdrawal` (снятие средств) с полем `sourceAccount`,  
   - `Transfer` (перевод между счетами) с полем `targetAccount`.  
2. Для каждого подкласса:  
   - Добавьте валидацию специфичных полей (например, `sourceAccount` не может быть пустым),  
   - Переопределите метод `validate()`, чтобы он учитывал как базовые, так и специфичные правила.  
3. Создайте массив `Transaction[]`, заполните его объектами разных типов, вызовите `validate()` для каждого элемента.  

**Каверзные вопросы**:  
- ❓ Почему метод `validate()` в подклассах должен вызывать `super.validate()`? Что сломается, если этого не делать?  
- ❓ Как изменится поведение программы, если `Withdrawal` и `Transfer` будут наследоваться напрямую от `Object`, а не от `Transaction`?  

**Ссылки**:  
- [Inheritance (Oracle)](https://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html)  

```java
public class Deposit extends ? { ... }
public class Withdrawal extends ? {
  private final String sourceAccount;
  // ....
}
public class Transfer extends ? {
  private final String targetAccount;
  // ....
```

---

### **3. Абстрактные классы и интерфейсы: Устранение дублирования**  
**Цель**: Вынести общую логику в абстрактный класс и интерфейс.  
**Задания** (опираются на п.2):  
1. Создайте интерфейс `Validatable` с методами:  
   - `boolean isValid()`,  
   - `default String getValidationMessage()`, возвращающий "OK" или "Ошибка".  
2. Создайте абстрактный класс `BaseTransaction`, реализующий `Validatable` и содержащий:  
   - Общие поля `id`, `amount`, `currency`,  
   - Базовую валидацию (как в п.1),  
   - Абстрактный метод `getSpecificValidation()`, который должны реализовать подклассы.  
3. Перепишите все классы (`Deposit`, `Withdrawal`, `Transfer`) так, чтобы они наследовали `BaseTransaction`.  
4. Добавьте в `Validatable` метод `logValidation()`, выводящий результат в консоль.  

**Каверзные вопросы**:  
- ❓ Почему `BaseTransaction` объявлен как `abstract`? Что произойдет, если убрать ключевое слово `abstract`?  
- ❓ Как изменится код, если заменить интерфейс `Validatable` на обычный класс? Какие ограничения это наложит?  

**Ссылки**:  
- [Abstract Classes (Oracle)](https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html) 

```java
  public /* ... ? ... */ Validatable {
    // .... ? .....
  }

 public abstract class BaseTransaction /* ... ? ... */ {
   // ..... ? .....

    @Override
    public boolean isValid() {
      // ..... ? .....
    }
 }
```

---

### **4. Records: Упрощение immutable-классов**  
**Цель**: Заменить boilerplate-код на records.  
**Задания** (опираются на `BaseTransaction` из п.3):  
1. Перепишите `BaseTransaction` как record `Transaction` с компактным конструктором, выполняющим:  
   - Проверку `amount > 0`,  
   - Проверку допустимых валют (`USD`, `EUR`, `RUB`).  
2. Перепишите подклассы (`Deposit`, `Withdrawal`, `Transfer`) как records.  
   - В компактных конструкторах добавьте валидацию специфичных полей (например, `sourceAccount` для `Withdrawal`).  
    - `sourceAccount == null || sourceAccount.isEmpty()`
3. Убедитесь, что:  
   - Попытка создать объект с невалидными данными приводит к исключению,  
   - Поля объектов неизменяемы (попытка модификации после создания → ошибка компиляции).  

**Каверзные вопросы**:  
- ❓ Почему record не может иметь приватных полей? Как это влияет на инкапсуляцию по сравнению с обычным классом?  
- ❓ Что произойдет, если убрать компактный конструктор и оставить валидацию в обычном конструкторе record?  
- ❓ Что произойдет при попытке изменить `amount` после создания объекта?

**Ссылки**:  
- [Records (Oracle)](https://docs.oracle.com/en/java/javase/16/language/records.html)  

---

### **5. Sealed Interfaces: Контроль иерархии типов**  
**Цель**: Ограничить наследование классов.  
**Задания** (опираются на records из п.4):  
1. Создайте sealed-интерфейс `TransactionType`, разрешающий наследование только для `Deposit`, `Withdrawal`, `Transfer`.  
2. Все records из п.4 должны реализовывать `TransactionType`.  
3. Добавьте новый тип операции `Loan`, реализующий `TransactionType`, и убедитесь, что компилятор разрешает это только при добавлении `Loan` в `permits`.  
4. Напишите метод `String process(TransactionType tx)`, использующий `switch` для обработки всех типов операций.  

**Каверзные вопросы**:  
- ❓ Почему sealed-интерфейсы безопаснее открытого наследования? Приведите пример уязвимости в системе без sealed.  
- ❓ Что произойдет, если добавить новый тип в `permits`, но не обновить метод `process()`? Как компилятор поможет обнаружить ошибку?  

**Ссылки**:  
- [Sealed Classes (Oracle)](https://docs.oracle.com/en/java/javase/17/language/sealed-classes-and-interfaces.html)  

```java
public sealed interface TransactionType permits ?, ?, ?
```

---

### **6. Generics: Типобезопасность для валют**  
**Цель**: Добавить поддержку строгой типизации валют.  
**Задания** (опираются на sealed-иерархию из п.5):  
1. Создайте sealed-иерархию для валют:  
   - Интерфейс `Currency` с разрешенными реализациями `USD`, `EUR`, `RUB`,  
   - Каждая валюта — record с полем `amount`.  
2. Перепишите `TransactionType` так, чтобы он использовал generics:  
   - `TransactionType<T extends Currency>`,  
   - Все операции (`Deposit`, `Withdrawal`, `Transfer`) должны работать с конкретной валютой (например, `Deposit<USD>`).  
3. Убедитесь, что:  
   - `new Deposit<>(...)` с `USD` компилируется,  
   - `new Deposit<>(...)` с `String` вместо валюты не компилируется.  

**Каверзные вопросы**:  
- ❓ Почему ограничение `T extends Currency` необходимо? Что сломается без него при обработке операций?  
- ❓ Как добавить поддержку новой валюты (например, `JPY`), не изменяя существующий код обработки операций?  

**Ссылки**:  
- [Generics (Oracle)](https://docs.oracle.com/javase/tutorial/java/generics/)  

---

### **7. Sealed + Generics + Switch: Система обработки ошибок**  
**Цель**: Создать типобезопасную систему ошибок.  
**Задания** (опираются на п.6):  
1. Создайте sealed-иерархию для результатов обработки:  
   - `ProcessingResult<T>` с подтипами `Success<T>` и `Failure`,  
   - `Failure` с подтипами `InsufficientFunds` и `InvalidCurrency`.  
2. Реализуйте метод `ProcessingResult<Double> process(TransactionType<?> tx, double balance)`, который:  
   - Для `Withdrawal`: проверяет баланс и возвращает `Success` или `InsufficientFunds`,  
   - Для `Deposit`: всегда возвращает `Success` с обновленным балансом.  
3. Напишите метод `String handleResult(ProcessingResult<?> result)`, обрабатывающий все типы результатов через `switch`.  

**Каверзные вопросы**:  
- ❓ Что произойдет, если добавить новый тип ошибки (например, `AccountLocked`), но не обновить `handleResult()`? Как компилятор укажет на проблему?  
- ❓ Почему `ProcessingResult` использует sealed вместо enum? Какие преимущества это дает для расширяемости системы?  

**Ссылки**:  
- [Pattern Matching for switch (JEP 406)](https://openjdk.org/jeps/406)  

---

### **8. Итоговый проект: Полная система обработки транзакций**  
**Цель**: Объединить все навыки в рабочем приложении.  

#### **Задача**  
Реализуйте консольное приложение для обработки финансовых операций со следующими требованиями:  
1. **Sealed-иерархия операций**:  
   - Все типы операций (`Deposit`, `Withdrawal`, `Transfer`, `Loan`) должны реализовывать `TransactionType<T extends Currency>`.  
   - Новые типы операций можно добавлять только через обновление `permits`.  
2. **Типобезопасность валют**:  
   - Операции с разными валютами (USD/EUR/RUB) не должны смешиваться.  
   - Попытка перевода `Deposit<USD>` в `Withdrawal<EUR>` должна приводить к ошибке компиляции.  
3. **Обработка ошибок**:  
   - Все операции возвращают `ProcessingResult<Double>` (текущий баланс или ошибку).  
   - При выводе результатов в консоль используются специфичные сообщения для каждого типа ошибки.  
4. **Интерфейс**:  
   - Программа запрашивает у пользователя данные для операции (тип, сумму, валюту, счета),  
   - Выводит результат обработки или описание ошибки.  

#### **Критерии проверки**  
- При вводе невалидной суммы (≤ 0) пользователь получает понятное сообщение об ошибке.  
- Попытка снять больше средств, чем есть на счете, возвращает ошибку `InsufficientFunds`.  
- Все типы операций обрабатываются через `switch`, компилятор гарантирует полноту обработки.  

#### **Каверзные вопросы**  
- ❓ Как система предотвратит попытку перевода средств между разными валютами (например, `Deposit<USD>` → `Withdrawal<EUR>`)?  
- ❓ Что произойдет, если добавить обработку `default` в `switch` для `ProcessingResult`? Как это повлияет на безопасность типов?  

