# Базовые основы ООП

# Цели и задачи

## Общие цели

1. создание классов
2. наследование и виртуальные методы / полиморфизм
3. интерфейсы / полиморфизм
4. ограничение наследования + pattern matching

Практические части будут направлены на освоение этих тем

## Конкретные темы

1. Классы
   - Данные
   - Конструкторы и методы
2. Инкапсуляция
   - public, private, protected
3. Наследование. Полиморфизм
   - Согласованность инкапсуляции с наследованием
   - Частичный доступ protected, default
   - интерфейсы
   - Под-типизация (Sub typing)
     - instance of
     - pattern matching (switch)
   - Непредвиденное поведение из-за наследования
     - Нарушение equals / hashcode
   - Ограничение наследования
     - final (record /classes)
     - sealed
     - pattern matching

## Ожидаемые результаты

1. должны быть сформированы понятия о типах в контексте JAVA, не фундаментально, хотя бы приблеженно
2. разобраться
   а) Что такое интерфейс, отличие от класса
   б) класса от абстрактного класса
   в) абстрактного класса от интерфейса
   г) отличие интерфейсов версии java 7 и более ранних от текущей java 17+
3. разобраться с наследованием
   а) наследование класса от класса
   б) класса от абстрактного класса
   в) абстрактного класса от класса
   г) класса от интерфейса
   в) класса от интерфейсов
   д) класса от класса и интерфейсов
   е) ограничение наследования через final
   ж) ограничение наследования через sealed
   з) ограничение наследования через sealed для интерфейсов
   и) обход ограничения наследования sealed, через non-sealed
4. разобраться как наследование работает с модификаторами доступа (public, protected, private, default) применительно к методам, полям, классов и интерфейсов
5. попытаться найти объяснение почему не наследуются поля в контексте интерфейсов
6. сформулировать принципиальное отличия статической типизации от динамической - сравнить с python
- выдать перечень когда статическая типизация хорошо, когда плохо


## Средства достижения цели

В качестве практики будет взята предметная область и запрограммировано приложение


# Практика

## Функциональные требования

Консольное приложение для управления банковскими счетами

реализующее операции: 
- открытие счета
- пополнение счета
- снятие со счета
- перевод со счета на счет
- проверка баланса счета
- закрытие счета


### CLI
- Ответы содержат:
    - `ok [сообщение]` - успех,
    - `err [сообщение]` - ошибка
- Общий синтаксис команд и ответов
    - комада [аргумент1 [аргумент2 [...]]
    - команда и аргументы разделяются пробелами
    - ok [сообщение]
    - err [сообщение]
- Аргументы разделяются **одиночными пробелами**

### Поддерживаемые команды и формат аргументов:

```text
open                                → создать новый счет (возвращает номер)
close <номер_счета>                 → закрыть счет
deposit <номер_счета> <сумма>       → пополнить счет
withdraw <номер_счета> <сумма>      → снять со счета
transfer <номер_счета> <сумма>      → перевести со счета на счет
balance <номер_счета>               → посмотреть баланс
list                                → вывести список всех открытых счетов
```

### Обработка ошибок
- `not found` - счет не существует
- `not enough funds` - недостаточно средств для снятия
- `invalid input` - некорректный ввод

### Тестирование
- Тесты пишутся **применительно к классу `BankAccountSystem`**
- CLI-ввод не тестируется
- Тесты должны **покрывать все требования первого комплекта**:
  - открытие, 
  - пополнение, 
  - снятие, 
  - баланс, 
  - закрытие

### Пример взаимодействия с приложением

```shell
> # закрытие счета → счета не существует → ошибка
> close 12
<err account not found

> # открытие счета → счета не существует → успех
> open
<ok 12

> # пополнение счета - id=12, +34 руб → счет существует → успех
> deposit 12 34
<ok

> # снятие - счет id=12, -43 руб → недостаточно средств → ошибка
> withdrawal 12 43
<err not enough funds

> # снятие - счет id=12, -31 руб → достаточно средств → успех
> withdrawal 12 31
<ok
```

---

## Проектирование

### Основные сущности

#### Счет

- Уникальный номер - UUID - тип `UUID`
  - нельзя открыть счет с уже существующим номером, если счет с существующим номер НЕ закрыт
- Баланс - вещественное число - тип `BigDecimal`
- Счет может быть открытым или закрытым
- Произвольное количество счетов

#### Пополнение счета
  - нельзя пополнить счет суммой 0 или меньше

#### Снятие со счета
  - нельзя снять денег, больше чем есть на балансе
  - снятие денег возможно при положительном балансе

#### Перевод со счета на счет
  - Равнозначно операциям снятия и пополнения

#### Заем/Кредит
#### Списание процентов по кредиту
#### Просрочка

---
Со счетом (не владельцем счета, а именно со счетом)
может быть связано 0 или более кредитов

Для одного счета есть лимит суммы всех активных кредитов, открыть новый кредит нельзя

Кредит может быть в двух состояниях:
- Активен (начальное) -средства со счета банка выделены на счет владельца
- Закрыт (конечное) -средства переведены со счета владельца на счет банка



### Диаграммы

- вычитать постановку,
- найти сущности в тексте и какие есть между ними операции,
- нарисовать отношения в виде диаграммы
  - Диаграмму состояний и/или диаграмму последовательности
    - определить для каждой операции какие сущности учавствуют
    - Как и в какой последовательности меняются
    - Определить (не) допустимость операций - т.е. проверки и отобразить на диаграмме
  - Операций должно быть 4, но сначала сделать 3 - надо для учебной задачи
    - Пополнение, Снятие, Перевод
    - Кредиты (допустим требование о них появилось во втором релизе)
    - То есть должно быть 2 комплекта диаграмм

- Диаграммы могут использоваться для двух разных языков
  - Первый для описания, что должно делать программа, но без учета специфики, ООП/Java
  - Второй будет уже специфика, возможно потребует по править первые диаграммы

---

#### Диаграмма классов


#### Диаграмма состояний

- начальное состояние: определяет, какие данные и условия считаются доступными к моменту старта

| Элемент                              | Описание                                                                 |
|--------------------------------------|--------------------------------------------------------------------------|
| Входные данные от внешних источников | Например, инициация события («запрос на регистрацию», «поступил заказ»). |
| Состояние внешней среды              | Например, сеть подключена, оборудование включено, база данных доступна.  |
| Параметры системы                    | Настройки, идентификаторы, права доступа (если они заданы до начала).    |
| Состояние хранилища данных           | Например, база пуста, но доступна для записи.                            |
| Временные метки                      | Текущее время, дата - могут быть использованы для инициализации.         | 

    > Пример: Система контроля доступа
    > **Событие**: «Пользователь подошел к двери».
    > **Доступные данные**:
    >     - ID карты (считано считывателем).
    >     - Время суток (для проверки действия пропусков).
    >     - Статус двери (закрыта, открыта, аварийно открыта).
    >     - Список разрешенных карт (из хранилища).
    > 
    > Начальное состояние: «Ожидание ввода карты»  
    > → Система готова проверить карту, если считыватель работает.

#### состояние/прямоугольник

1. Это не результат работы
2. Это условное **состояние памяти** компютера или "системы",
   - возможно оперативной памяти, возможно жесткого диска или комбинации

Состояние (прямоугольник) на диаграмме состояний включает:  
- имя состояния,  
- входные действия,  
- выходные действия,  
- длительные действия,  
- возможные подсостояния.

пример

```plaintext
[Работает]
  entry / запустить мониторинг подключения
  do / обновлять статус каждые 30 секунд
  exit / остановить поток мониторинга
```

В этом примере:
- **Имя состояния**: `Работает`
- **Входное действие**: `запустить мониторинг подключения`
- **Длительное действие (внутри состояния)**: `обновлять статус каждые 30 секунд`
- **Выходное действие**: `остановить поток мониторинга`


#### стрелки/переходы
- **условие** `смены состояния`/`выполнения перехода`
  - ответь на вопрос `что вызывает смену состояния?`
- **действие**
  - действие не равно функции/методу


> Ввод данных и вывод результата, это отдельная задача, не связанная с самой логикой, на диаграммах только логика, без связи с user interface и без связи с каким либо языком программирования

- формат `[условие] / [действие]`
- пример
```
[Пользователь ввел логин и пароль]
    ↓
[проверка данных] → [доступ разрешен] / [открыть доступ к кабинету]
```

> Условие: `логин и пароль верны`  
> Действие: `открыть доступ к кабинету`

---

### Результаты работы

[Диаграмма классов](doc/uml/class-diagram-financial-entities.md)
[Диаграмма состояний - реализация](doc/uml/state-diagram-financial-entities.md)

---

## Кодирование

---

### Классы операций

> Задача - применить понятие полиморфизма из ООП

#### Требования
- [ ] конструктор - _без проверок_
- [ ] метод выполнения операции - `perform`
- [ ] учти свзянные операции, например, `открытие счета` и `закрытие счета`

---
Сценарий - все операции валидны и успешны

- **Счет 1**: `1`, баланс: **5000.00 ₽**
- **Счет 2**: `2`, баланс: **3000.00 ₽**

| №   | Операция       | Параметры                                      | Ожидаемый результат                      |
|-----|----------------|------------------------------------------------|------------------------------------------|
| 1   | **Зачисление** | Сумма: 800.00, Счет-получатель: `1`            | Счет 1: **5800.00**                      |
| 2   | **Снятие**     | Сумма: 600.00, Счет-источник: `2`              | Счет 2: **2400.00**                      |
| 3   | **Перевод**    | Сумма: 1200.00, Источник: `1`, Получатель: `2` | Счет 1: **4600.00**, Счет 2: **3600.00** |
| 4   | **Зачисление** | Сумма: 450.00, Счет-получатель: `2`            | Счет 2: **4050.00**                      |
| 5   | **Снятие**     | Сумма: 900.00, Счет-источник: `1`              | Счет 1: **3700.00**                      |
| 6   | **Перевод**    | Сумма: 500.00, Источник: `2`, Получатель: `1`  | Счет 1: **4200.00**, Счет 2: **3550.00** |
| 7   | **Зачисление** | Сумма: 1100.00, Счет-получатель: `1`           | Счет 1: **5300.00**                      |
| 8   | **Снятие**     | Сумма: 1400.00, Счет-источник: `2`             | Счет 2: **2150.00**                      |
| 9   | **Перевод**    | Сумма: 750.00, Источник: `1`, Получатель: `2`  | Счет 1: **4550.00**, Счет 2: **2900.00** |
| 10  | **Зачисление** | Сумма: 300.00, Счет-получатель: `2`            | Счет 2: **3200.00**                      |

#### Минимум ООП

Задача - выполнить очередь опереаций
Условие - без ООП
Цель - увидеть преимущества полиморфизма и наследования

- Каждый объект в очереди это экземпляр класса, который не наследует
- Каждая операция это какой то метод объекта, каждый со своим именем
- Можешь использовать метод getClass и операцию class cast/приведение типов
- Запрещено наследование методов

##### Решение - Рефлексия

- определены два банковских счета
- определено множество операций: 
  - создание счета
    - параметры: баланс на счете при открытии счета,
  - зачисление на счет
    - параметры: сумма начисления, объект счета-получателя,
  - снятие со счета
    - параметры: сумма снятия, объект счета-источника,
  - перевод со счета на счет
    - параметры: сумма перевода, объект счета-источника, объект счета-получателя,
- определена очередь операций
  - очередь операций включает операции
    - зачисление на счет
    - снятие со счета
    - перевод со счета на счет
  - очередь операций представлена объектом коллекции
    - объект коллекции - экземпляр класса, реализующего интерфейс `Collection`
    - для решения применен класс `Queue` - в связи с близостью логики типа данных (FIFO) и проектируемой системы (очереди операций)
- определен цикл, в теле которого производится
  - извлечение операции из очереди
  - выполнение операции

###### Понятия
> Collection - интерфейс коллекций, существующих в Java
> Queue - класс, реализующий интерфейс Collection

###### Проблема
- каждая операция реализована отдельным классом без применения наследования, то есть
  - тип операции, соответственно, поля и методы операции, неизвестны до извлечение
- при извлечении операции требуется
  - определить принадлежащие операции поля и методы
  - выполнить метод
- гарантируется, что каждая операция содержит только один публичный метод
  - имя метода неизвестно заранее 
  - нельзя жестко привязать "если операция - экземпляр класса Deposit, то выполнять метод performDeposit"
  - можно выполнить существующий метод при условии, что он единственный существующий

> решаем задачу динамической диспетчеризации операций

##### Решение - Динамическая типизация

Цель: освоить динамическую типизацию
Задача: придумать типизацию, как если бы ее не было в Java

Условия:
- запрет на методы Class, Method...
- Используй доп информацию рядом с входными данными (объектами), а не внутри самих данных.
  - передать в очереди пару `(Имя операции, Тип операции)`
  - Тип указываешь как строку

###### Подход

- ограничение - в Java статическая типизация => реализация динамической типизации - имитация
- суть  - тип операции указываю явно при выполнении - то есть как будто код не был скомпилирован, но интерпретируется при выполении
- поскольку "компиляции не производилось", очередь не знает арибутов объекта, поступившего на выполнение
- задача - выполнить операцию, полученную из очереди
  - определить тип операции => понять, какие данные необходимо передать
    - с помощью `instanceof` определяю имя класса
    - реализация классов известна
      - вариант 1 - определить словарь "имя класса: имя метода"
        > не использует ООП принципов
      - вариант 2 - в каждом классе Операции использовать одно и то же слово для имени метода
        > приближает к полиморфизму
  - вызвать метод операции

[реализация - динамическая типизация](src/main/java/NoOop/OpsQueueDynamicTyping.java)

---

#### Применение Полиморфизма

Доп задание в рамках текущего
Дать пример устно/письменно:
- как работает полиморфизм, 
- привести примеры, 
- что было бы если этот механизм отсутствовал при условии сохранения статической типизации 
  - (т.е. как бы ты выкручивался бы, см варианты type cast / class cast)
- определить понятия contains, aggregates, implements в задаче наследования
- Агрегация VS Наследование

##### Полиморфизм - идея, польза, понимание
- принцип ООП
- реализуется в Java с помощью `абстрактных классов`, `интерфейсов`, `суперклассов`
- дословно обозначает `возможность принимать множественные формы`

> что такое форма?
- форма - реализация поведения - пример: метод `выполнить`

> как кодируется форма?
- метод `perform` в классах 
  - [Deposit](src/main/java/Deposit.java), 
  - [Withdrawal](src/main/java/Withdrawal.java), 
  - [Transfer](src/main/java/Transfer.java)
- метод носит одинаковое имя в трех разных классах - отсюда понимаем метод `perform` как единую сущность
- метод выполняет определенный для него в классе код - метод `perform` называется одним именем, но реализован по-разному
- каждая уникальная реализация метода `perform` - есть _форма_ метода `perform`

> как определить тип объекта, на который указывает ссылка?
- если считать типом объекта А имя класса, экземпляром которого является объект А, то тип объекта можно определить 
  - выполнением оператора `isinstanceof` - пример: `operation isinstanceof Deposit`
    - вернет `true`, если ссылка `operation` указывает на экземпляр класса `Deposit`
  - выполнением метода `Object.getClass()` - пример: `operation.getClass().getSimpleName()`
    - вернет `Deposit`, если ссылка `operation` указывает на экземпляр класса `Deposit`

##### Применение в текущей задаче
- есть класс Операции
- класс операции содержит метод выполнения операции `perform`
- от класса Операции наследуются классы Пополнение, Снятие, Перевод
- каждый метод-наследник переопределяет метод `perform` - то есть, реализует характерную процедуру выполнения
  - выполнение для Пополнения - добавление суммы Операции к балансу счета
  - выполнение для Снятия - вычитание суммы Операции из баланса счета
  - выполнение для Перевода - вычитание суммы Операции из баланса счета отправителя, добавление суммы Операции к балансу счета получателя

> Меня в этом описании, смущают общие слова. Мне прям описание требуется, механики

`Operation` - абстрактный класс
абстракция здесь - общее для некоторых сущностей множество атрибутов
таким - общим - атрибутом в `Operation` яаляется метод `perform`
общим для кого?
для классов-наследников
классами-наследниками являются `Deposit`, `Withdrawal`, `Transfer`
класс-наследник переопределяет родительский метод `perform` 
  - то есть реализует свой способ выполнения метода `perform`
  - `способ выполнения` [выше](README.md:411) был назван `формой`
  - полиморфизм - многоформие - гарантирует, что в каждом наследнике будет метод родителя, в данном примере - `perform`
зачем наследовать, если реализация своя?
наследовать, чтобы гарантировать наличие метода `perform` в множестве классов и их экземплярах

один метод - `perform` - разные реализации `Deposit.perform`, `Withdrawal.perform`, `Transfer.perform`

- Роль полиморфизма на этапе компиляции
на этапе компиляции выполняется проверка синтаксиса, проверка типов, проверка графа наследования, пример:
`Operation op = new Deposit(BigDecimal.valueOf(500.00));`
- компилятор проверяет
  - Deposit наследует Operation
  - конструктор Deposit существует и принимает аргументы, заявленые в компилируемом коде - в данном случае экземпляр класса BigDecimal
`op.perform(account)`
- компилятор проверяет
  - класс Operation, экземпляром которого является объект `op`, содержит метод `perform`
  - компилятор сверяет ожидаемый принимаемый тип аргумента `perform` с типом фактически переданного объекта `account`

- компилятор записывает в байт-код метод `Operation.perform()`

- проявление полиморфизма
  - на этапе выполнения (в райнтайме/runtime)
  - реализацию метода выберет JVM 
- Как JVM знает, что op - это Deposit?
  - для private методов - с помощью "статического связывания" - выбор реализации метода на этапе компиляции,  до выполнения программы
  - для public методов - методов, которые могут быть переопределены - с помощью "динамического связывания" - на основе знания типа объекта
  - динамическое связывание - это привязка ключ-значение, которые записываются в системную таблицу vtable
  - пример vtable

```text
vtable для класса Deposit:
[0]  Object.hashCode()
[1]  Object.equals()
[2]  Object.toString()
[3]  Operation.perform() → указатель на метод Deposit.perform()
```

  - при выполнении JVM читает имя класса - Deposit, находит в vtable связанный с ним метод Deposit.perform, выполняет
---

##### Динамика VS Статика

- дан код на языке программирования с динамической типизацией

```python
class A:
    def say_hello(self):
        print('hello from A')

class B:
    def say_hello(self):
        print('hello from B')

a = A()
a.say_hello()

a = B()
a.say_hello()
```
дает вывод
```text
hello from A
hello from B
```

- дан [такой же - уже не рабочий - код на java](src/main/java/DemoTyping/MainBroken.java)
дает ошибку компиляции
```text
src/main/java/DemoTyping/MainBroken.java:6:11
java: variable a is already defined in method main(java.lang.String[])
```

- дан [похожий рабочий код на java](src/main/java/DemoTyping/MainOperational.java)

> задача - развернуто объяснить механику возникновения ошибки


- рассмотрим код Python
```python
class A:  # объявление класса
    def say_hello(self):  # объявление метода - сигнатура
        print('hello from A')  # объявление метода - тело

class B:
    def say_hello(self):
        print('hello from B')

# A() - вызов инициализатора класса A -> создание экземпляра класса А
# при создании экземпляр класса А получает идентификатор - встроенный атрибут `id`
# `a = ` - создание ссылки `a`, ссылка `a` содержит `id` объекта - экземпляра класса А
a = A()
# вызов метода экземпляра класса А
a.say_hello()

# B() - вызов инициализатора класса B -> создание экземпляра класса B
# при создании экземпляр класса B получает идентификатор - встроенный атрибут `id`
# `a = ` - создание ссылки `a`, ссылка `a` содержит `id` объекта - экземпляра класса B
# `a` принимает значение id эземпляра класса B, 
#  таким образом, ссылка на экземпляр А потеряна, экземпляр A будет ликвидирован сборщиком мусора
a = B()  # переменная `a` теперь хранит id экземпляра класса B
# вызов метода экземпляра класса B
a.say_hello()
```

- рассмотрим корректный код Java

```java
public class MainOperational {
    public static void main(String[] args) {
        // new A() - вызов конструктора класса А -> создание экземпляра класса А
        // A a = - объявление переменной `a`, предназначенной для хранения ссылки на экземпляр класса A, установка ссылки на экземпляр класса A
        // аналогично для B
        A a = new A();
        B b = new B();

        // вызов метода объекта, ссылка на который содержит переменная `a`, `b`
        a.sayHello();
        b.sayHello();
    }
}
```

- рассмотрим некорректный код Java
```java
public class MainBroken {
    public static void main(String[] args) {
        // new A() - вызов конструктора класса А -> создание экземпляра класса А
        // A a = - объявление переменной `a`, предназначенной для хранения ссылки на экземпляр класса A, установка ссылки на экземпляр класса A
        A a = new A();

        // new B() - вызов конструктора класса B -> создание экземпляра класса B
        // A a = - объявление переменной `a`, предназначенной для хранения ссылки на экземпляр класса A
        // установка ссылки переменной для типа `A` на объект типа `B` -> недопустимая операция, 
        //  поскольку `a` предназначена только для указания на экземпляры `A`

//        A a = new B();  // строка, вызывающая ошибку компиляции

        //  можно создать новый экземпляр класса A - это работает, так как `a` определена для работы с A
        A a = new A();
        
        // дважды вызвать метода объекта, ссылка на который содержит переменная `a`
        a.sayHello();
        a.sayHello();
    }
}
```


---


### Результаты работы

## Вопросы

### приведение типов
какое техническое обоснование делать  
`Transfer transfer = (Transfer) op.getValue();`  
а не  
`Transfer transfer = op.getValue();`  - здесь уже объявлен тип, зачем еще кастить? Компилятор настолько не доверяет автору кода?
[пример в коде](src/main/java/NoOop/OpsQueue.java#L57)  
что это - процедура/метод/оператор/особенность?
как это связано с компилятором - является его функциональностью?

### применение рефлексии
реализуя решение с рефлексией, встретил утверждение
что _рефлексия используется в Spring для `автозавязка бинов` (@Autowired, @Component)_
для меня это _бессвязный набор слов_ в настоящее время
надо ли на текущем этапе изучения разбираться в этом высказывании?

### учебный процесс и эффективность
что с твоей точки зрения я делаю неправильно?
что предпринять, чтобы исправить эти ошибки?

### почему это важно
почему необходимо понимать 
устройство типизации?
работу компилятора?

не достаточно ли писать **код, который работает**?
почему важно понимать, **как** работает код, который работает?

пример: 
есть класс А, реализованный программистом, понимающим компилятор
класс А выполняет работу Р

есть класс Б, реализованный программистом, НЕ понимающим компилятор
класс Б выполняет работу Р

существует ли преимущество класса А перед классом Б?
если существует, в чем оно заключается и проявляется?
