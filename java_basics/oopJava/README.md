# Базовые основы ООП

# Цели и задачи

## Общие цели

1. создание классов
2. наследование и виртуальные методы / полиморфизм
3. интерфейсы / полиморфизм
4. ограничение наследования + pattern matching

Практические части будут направлены на освоение этих тем

## Конкретные темы

1. Классы
   - Данные
   - Конструкторы и методы
2. Инкапсуляция
   - public, private, protected
3. Наследование. Полиморфизм
   - Согласованность инкапсуляции с наследованием
   - Частичный доступ protected, default
   - интерфейсы
   - Под-типизация (Sub typing)
     - instance of
     - pattern matching (switch)
   - Непредвиденное поведение из-за наследования
     - Нарушение equals / hashcode
   - Ограничение наследования
     - final (record /classes)
     - sealed
     - pattern matching

## Ожидаемые результаты

1. должны быть сформированы понятия о типах в контексте JAVA, не фундаментально, хотя бы приблеженно
2. разобраться
   а) Что такое интерфейс, отличие от класса
   б) класса от абстрактного класса
   в) абстрактного класса от интерфейса
   г) отличие интерфейсов версии java 7 и более ранних от текущей java 17+
3. разобраться с наследованием
   а) наследование класса от класса
   б) класса от абстрактного класса
   в) абстрактного класса от класса
   г) класса от интерфейса
   в) класса от интерфейсов
   д) класса от класса и интерфейсов
   е) ограничение наследования через final
   ж) ограничение наследования через sealed
   з) ограничение наследования через sealed для интерфейсов
   и) обход ограничения наследования sealed, через non-sealed
4. разобраться как наследование работает с модификаторами доступа (public, protected, private, default) применительно к методам, полям, классов и интерфейсов
5. попытаться найти объяснение почему не наследуются поля в контексте интерфейсов
6. сформулировать принципиальное отличия статической типизации от динамической - сравнить с python
- выдать перечень когда статическая типизация хорошо, когда плохо


## Средства достижения цели

В качестве практики будет взята предметная область и запрограммировано приложение


# Практика

## Функциональные требования

Консольное приложение для управления банковскими счетами

реализующее операции: 
- открытие счета
- пополнение счета
- снятие со счета
- перевод со счета на счет
- проверка баланса счета
- закрытие счета


### CLI
- Ответы содержат:
    - `ok [сообщение]` - успех,
    - `err [сообщение]` - ошибка
- Общий синтаксис команд и ответов
    - комада [аргумент1 [аргумент2 [...]]
    - команда и аргументы разделяются пробелами
    - ok [сообщение]
    - err [сообщение]
- Аргументы разделяются **одиночными пробелами**

### Поддерживаемые команды и формат аргументов:

```text
open                                → создать новый счет (возвращает номер)
close <номер_счета>                 → закрыть счет
deposit <номер_счета> <сумма>       → пополнить счет
withdraw <номер_счета> <сумма>      → снять со счета
transfer <номер_счета> <сумма>      → перевести со счета на счет
balance <номер_счета>               → посмотреть баланс
list                                → вывести список всех открытых счетов
```

### Обработка ошибок
- `not found` - счет не существует
- `not enough funds` - недостаточно средств для снятия
- `invalid input` - некорректный ввод

### Тестирование
- Тесты пишутся **применительно к классу `BankAccountSystem`**
- CLI-ввод не тестируется
- Тесты должны **покрывать все требования первого комплекта**:
  - открытие, 
  - пополнение, 
  - снятие, 
  - баланс, 
  - закрытие

### Пример взаимодействия с приложением

```shell
> # закрытие счета → счета не существует → ошибка
> close 12
<err account not found

> # открытие счета → счета не существует → успех
> open
<ok 12

> # пополнение счета - id=12, +34 руб → счет существует → успех
> deposit 12 34
<ok

> # снятие - счет id=12, -43 руб → недостаточно средств → ошибка
> withdrawal 12 43
<err not enough funds

> # снятие - счет id=12, -31 руб → достаточно средств → успех
> withdrawal 12 31
<ok
```

---

## Проектирование

### Основные сущности

#### Счет

- Уникальный номер - UUID - тип `UUID`
  - нельзя открыть счет с уже существующим номером, если счет с существующим номер НЕ закрыт
- Баланс - вещественное число - тип `BigDecimal`
- Счет может быть открытым или закрытым
- Произвольное количество счетов

#### Пополнение счета
  - нельзя пополнить счет суммой 0 или меньше

#### Снятие со счета
  - нельзя снять денег, больше чем есть на балансе
  - снятие денег возможно при положительном балансе

#### Перевод со счета на счет
  - Равнозначно операциям снятия и пополнения

#### Заем/Кредит
#### Списание процентов по кредиту
#### Просрочка

---
Со счетом (не владельцем счета, а именно со счетом)
может быть связано 0 или более кредитов

Для одного счета есть лимит суммы всех активных кредитов, открыть новый кредит нельзя

Кредит может быть в двух состояниях:
- Активен (начальное) -средства со счета банка выделены на счет владельца
- Закрыт (конечное) -средства переведены со счета владельца на счет банка



### Диаграммы

- вычитать постановку,
- найти сущности в тексте и какие есть между ними операции,
- нарисовать отношения в виде диаграммы
  - Диаграмму состояний и/или диаграмму последовательности
    - определить для каждой операции какие сущности учавствуют
    - Как и в какой последовательности меняются
    - Определить (не) допустимость операций - т.е. проверки и отобразить на диаграмме
  - Операций должно быть 4, но сначала сделать 3 - надо для учебной задачи
    - Пополнение, Снятие, Перевод
    - Кредиты (допустим требование о них появилось во втором релизе)
    - То есть должно быть 2 комплекта диаграмм

- Диаграммы могут использоваться для двух разных языков
  - Первый для описания, что должно делать программа, но без учета специфики, ООП/Java
  - Второй будет уже специфика, возможно потребует по править первые диаграммы

---

#### Диаграмма классов


#### Диаграмма состояний

- начальное состояние: определяет, какие данные и условия считаются доступными к моменту старта

| Элемент                              | Описание                                                                 |
|--------------------------------------|--------------------------------------------------------------------------|
| Входные данные от внешних источников | Например, инициация события («запрос на регистрацию», «поступил заказ»). |
| Состояние внешней среды              | Например, сеть подключена, оборудование включено, база данных доступна.  |
| Параметры системы                    | Настройки, идентификаторы, права доступа (если они заданы до начала).    |
| Состояние хранилища данных           | Например, база пуста, но доступна для записи.                            |
| Временные метки                      | Текущее время, дата - могут быть использованы для инициализации.         | 

    > Пример: Система контроля доступа
    > **Событие**: «Пользователь подошёл к двери».
    > **Доступные данные**:
    >     - ID карты (считано считывателем).
    >     - Время суток (для проверки действия пропусков).
    >     - Статус двери (закрыта, открыта, аварийно открыта).
    >     - Список разрешённых карт (из хранилища).
    > 
    > Начальное состояние: «Ожидание ввода карты»  
    > → Система готова проверить карту, если считыватель работает.

#### состояние/прямоугольник

1. Это не результат работы
2. Это условное **состояние памяти** компютера или "системы",
   - возможно оперативной памяти, возможно жесткого диска или комбинации

Состояние (прямоугольник) на диаграмме состояний включает:  
- имя состояния,  
- входные действия,  
- выходные действия,  
- длительные действия,  
- возможные подсостояния.

пример

```plaintext
[Работает]
  entry / запустить мониторинг подключения
  do / обновлять статус каждые 30 секунд
  exit / остановить поток мониторинга
```

В этом примере:
- **Имя состояния**: `Работает`
- **Входное действие**: `запустить мониторинг подключения`
- **Длительное действие (внутри состояния)**: `обновлять статус каждые 30 секунд`
- **Выходное действие**: `остановить поток мониторинга`


#### стрелки/переходы
- **условие** `смены состояния`/`выполнения перехода`
  - ответь на вопрос `что вызывает смену состояния?`
- **действие**
  - действие не равно функции/методу


> Ввод данных и вывод результата, это отдельная задача, не связанная с самой логикой, на диаграммах только логика, без связи с user interface и без связи с каким либо языком программирования

- формат `[условие] / [действие]`
- пример
```
[Пользователь ввел логин и пароль]
    ↓
[проверка данных] → [доступ разрешён] / [открыть доступ к кабинету]
```

> Условие: `логин и пароль верны`  
> Действие: `открыть доступ к кабинету`

---

## Результаты работы

[Диаграмма классов](doc/uml/class-diagram-financial-entities.md)
[Диаграмма состояний - реализация](doc/uml/state-diagram-financial-entities.md)

---

## Кодирование

---

### Классы

- Реализовать для операций классы - первый комплект (и другие сопутствующие классы)
  - В конструкторе ничего не проверям
  - Добавлен метод валидации где он просто возвращает факт наличия ошибки
Условно для тестирования будет такое взаимодействие:
Система находится в начальном состоянии (все данные необходимые для работы программы)

1. На вход подается команда ввиде строки
2. система определят команду и меняет свое состояние если это допустимо или отвергает команду и не менят состояние
3. В любом случае реакция системы должна быть и она выдается ввиде строки

