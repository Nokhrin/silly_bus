# Типизированное лямбда-исчисление

## Цели изучения
- лямбды в терминологии математики
  1) свободные и связанные переменные
  2) аппликация и абстракция
  3) типизация

- понять синтаксис
  1) функциональные интерфейсы
  2) стандартные интерфейсы Function, Consumer, Supplier BiFunction, BiConsumer
  3) лямбды вида Function< Function< Function< A, B>, C>, D> - т.е. вложенность



## Материалы
[Системы типизации лямбда-исчисления - Москвин](https://www.lektorium.tv/lecture/13181)
[Герман Геверс - Введение в теорию типов](https://www.karlin.mff.cuni.cz/~krajicek/geuvers.pdf)

## Система типов
- общее: совокупность правил, назначающих свойства, именуемые типами, конструкциям, составляющим программу - переменным, выражениям, функциям, модулям
- по Пирсу: разрешимый **синтаксический** метод доказательства отсутствия некоторых поведений программы путем классификации конструкций в соответствии с видами вычисляемых значений
  - важно - синтаксический характер типов

лямбда-исчисление - одна из моделей вычисления - процесса редукции
лямбда-термы - выражения / синтаксические объекты лямбда-исчисления

## Цели типизации
- задать спецификацию программы
  - тип задает требования к термам
- типизированные программы ведут себя предсказуемым образом
- типизированные программы всегда завершаются
- система типов отлавливает ошибки программы

## Лямбда-абстракция
- неименованная функция

### лямбда-термы
- переменная
- абстракция
- применение/аппликация

### переменные
- связанные
  - переменная в области действия лямбды
    - икс в выражении `λx. y`
  - в кодировании: локальные переменные
- свободные
  - переменная, которая не определена внутри выражения
    - игрек в выражении `λx. y`
  - в кодировании: глобальные переменные

### комбинатор
- замкнутый лямбда-терм
- терм, который не содержит свободных переменных
- комбинаторы, содержащие самоприменение, могут быть нетипизируемы

> комбинатор неподвижной точки - рассматривай это как вид рекурсии

функции нескольких переменных могут быть описаны последовательным применением функции к этим переменных

### вопрос
означает ли этот тезис, что для любого вычисления достаточно одной переменной?
в частности, функции в любом ЯП достаточно одного параметра?


подстановка - или, бета-преобразование / бета-конверсия

захват переменной 
- в чистом лямбда-исчислении отсутствует понятие захвата переменной
# todo
> рассмотри захват переменной как способ создания чистой функции

https://docs.google.com/presentation/d/1Q0SWJ6JvMOWqRhJnkclecZOJvPn600Rrx1Pg9GxYA0Q/edit?usp=drivesdk
https://docs.google.com/presentation/d/1q93fS0WBi9tdI1rjAAYLLQtTD9oAmV4mthD_kzzJp2g/edit?usp=drivesdk


  - переменная - либо связанная (параметр), либо свободная (глобальная)
- в расширениях лямбда-исчисления появляется вероятность одновременного существования переменной и в свободной, и в связанной формах
  - в таком случае невозможно однозначно определить, над каким значением выполняется применение
  - решение 
    - в науке - альфа-преобразование - замена одного идентификатора переменной на другой
    - в кодировании - переименование одной из конфликтующих переменных

роль индукции в лямбда-исчислении
- доказательство свойств подстановки


### `равенство =` и `тождество ≡`
- равенство - эквивалентность по значению
  - утверждение, что два значения равны
  - `2 + 2` = `4` // значения выражений равны, выражения не тождественны
- тождество - эквивалентность по структуре
  - эквивалентность по связке тип+значение
  - утверждение, что две сущности есть один и тот же объект
  - `2 + 2` ≡ `2 + 2` // значения выражений равны, выражения тождественны
- в кодировании: тождество утверждает, что две сущности являются одним и тем же синтаксическим объектом
  - тождество - операция проверки типов - ответ на вопрос "переданный тип тождественнен ожидаемому?"

### альфа-конверсия
- в кодировании: замена переменных


### подстановка
- операция замены переменной на выражение
```
M[x := N] 
// в выражении M 
// заменить 
// все свободные вхождения переменной x 
// выражением N
```
```
λx. x y[x := z] 
// читается: (лямбда икс) (икс игрек) (где икс заменен на зет)
// икс в конструкции `λx` - связанная переменная, подстановка на нее не действует
λx. x y[x := z] → λx z y
```

### бета-конверсия / бета-редукция / бета-преобразование
- правило, определяющее порядок вычисления аппликации функции
- использует подстановку как ключевой механизм
  - подстановка - инструмент бета-конверсии

```
(λx. M) N → M[x := N]
// читается
// (λx. M) N // применение лямбда икс эМ к переменной эН
// → // дает/приводит к
// M[x := N] // эМ по подстановке эН вместо икс
```
```
(λx. x y) z → (x y)[x := z] → z y
// применение лямбда-выражения лямбда икс, икс игрек к зет 
// приводит к
// выражению икс игрек после подстановки зет вместо икс,
// которое равно зет игрек 
```
- `y` - свободная переменная, в процессе редукции не изменяется
- строго необходима проверка на захват переменной, чтобы сохранить однозначность


```
---
по условию
ω ≡ λx. x x // читается омега эквивалентна лямбде икс, икс икс
// λx. x x - лямбда-выражение, 
где `λx` - "принимает параметр икс" / "параметр лямбда-функции есть икс"
`x x` - "применяет икс к самому себе"

// аппликация/применение ω ω
// суть - применить к самому себе выражение, в котором переменная применяется к самой себе
ω ω → (λx. x x) ω // так как по условию ω ≡ λx. x x

// выполним бета-преобразование
(λx. x x) ω → 
(x x)[x := ω] → 
ω ω → 
(λx. x x) ω →
(x x)[x := ω] →
ω ω →
...
// бесконечный цикл, бесконечная редукция
```

### ита-конверсия
- в кодировании - упрощение синтаксиса за счет замены ненужных оберточных лямбда-функций
```
выражение lambda x: f(x)
эквивалентно
f
если x - переменная, не свободная в f (связанная/локальная переменная)
```




## Лямбда-выражения в Java

Лямбда-выражения в Java - анонимная функция, реализующая функциональный интерфейс

### Материалы
[Java Lambda Expressions](https://www.w3schools.com/java/java_lambda.asp)

### свойства лямбда-выражений в java, базовый синтаксис
- лямбда-функция принимает параметры и возвращает значение
  - (parameter1, parameter2, ..., parameterN)   → expression
- лямбда-функция анонимна, то есть, не требует объявления в классе
- лямбда-функция может быть передана как параметр другой функции
- можно создать переменную, ссылающуюся на лямбда-функцию
  - условие - тип такой переменной - интерфейс, содержащий строго один метод
    - однозначно, какой метод вызывать
    - интерфейс со строго одним методом - функциональный интерфейс

[код - лямбда-функции](/src/main/java/Lambdas/Basics.java)

- лямбда-выражение может заменить `анонимный класс` если описан функциональный интерфейс - интерфейс со строго одним абстрактным методом
  - анонимный класс 
    - объявляется и создается одновременно, используется строго один раз 
    - применять для переопределения нескольких методов, добавления полей, расширения класса
[код - замена анонимного класса](/src/main/java/Lambdas/Anonym.java)

### функциональные интерфейсы / ФИ
- функциональный интерфейс содержит строго один АБСТРАКТНЫЙ метод

```
один абстрактный метод =>
если тип ожидается явно
или
компилятор может определить тип =>
лямбда-выражение может быть передано как реализация абстрактного метода
```

- функциональный интерфейс может содержать другие методы - если эти методы объявлены с модификатором `default` или `static`
  - `default` и `static` - модификаторы методов интерфейсов, определяют поведение метода
  - `default` метод принадлежит экземпляру, может быть переопределен, может быть перегружен
  - `static` метод вызывается от имени интерфейса, не может быть переопределен, может быть перегружен
[код - `default` и `static`](/src/main/java/Lambdas/DefaultAndStatic.java)


#### задача ФИ
- представление поведения с помощью объявления метода
- фиксация типов данных для объявленного метода
- использовать методические ссылки / МС / ссылки на методы / method references
  - МС - не объект, МС - ссылка
  - лямбда-выражение, которое ссылается на метод
    - статический  
    `Integer::parseInt`
    - экземплярный  
    `String::toUpperCase`
  - синтаксический сахар - сокращают запись - применимы для одного вызова одного метода  
- допускают реализацию абстрактного метода с помощью лямбда-выражения

### стандартные интерфейсы Function, Consumer, Supplier BiFunction, BiConsumer
- java.util.function содержит функциональные интерфейсы
- стандартные - наиболее часто используемые
- в качестве типов данных могут применяться обозначения `T`, `R`, например, `Function<T, R>`
  - `T`, `R` обозначают обобщенные типы данных - или, дженерики
  - обозначение - буква - или последовательность букв - не влияет на типизацию, буквы используются по схожести семантики интерфейса
    - в практике приняты обозначения:
      - T - Type (тип)
      - E - Element (элемент, например, в коллекциях)
      - K - Key (ключ)
      - V - Value (значение)
      - N - Number
      - U - Union - последовательность, вторая переменная типа, часто используется, когда нужно больше одного типа (например, T и U).

  - дженерик говорит, что тип данных может быть любым
    - если тип может быть любым, то зачем вводить обозначение?
    - не обесценивают ли обобщенные типы достоинства статической типизации?
  - `T` - от `Type` - тип данных входного параметра
  - `R` - от `Return` - тип данных возвращаемого результата
  - `Function<T, R>` - функция, которая принимает значение типа T и возвращает значение типа R

пример встроенного интерфейса
```java
package java.util.function;

@FunctionalInterface
public interface Supplier<T> {
    T get();
}
```

[код - стандартные интерфейсы](/src/main/java/Lambdas/CommonInterfaces.java)


### лямбды вида Function< Function< Function< A, B>, C>, D> - т.е. вложенность
- вложенность - тело одного лямбда-выражения содержит тело другого лямбда-выражения
- применяется в цепочках вызовов
  - часто встречал в примерах по обработке коллекций, в частности, последовательности Char, в Stream API

- обрабатываемые значения должны быть с модификатором `effectively final`

[код - вложенность лямбда-функций](/src/main/java/Lambdas/NestedLambdas.java)

> Java не поддерживает лямбды в чистом виде (без синтаксической эквивалентности)

