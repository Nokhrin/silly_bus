> Практика - парсинг команд, открые счета, пополнение ,... и т.д.
> В задании есть примеры как эти команды представлены текстом, вот... сделай набор парсеров, которые анализируют текст и возвращают команды

# Парсинг

## Понятия

Синтаксис - набор формальных правил, определяющих построение упорядоченной системы представления информации - например, правила записи команд программы
Синтаксис задает сочетаемость слов, порядок следования слов, порядок объединения слов
Грамматика - определение синтаксис языка
Семантика - значение грамматической конструкции
Значение может иметь только грамматически корректный текст
Поэтому синтаксис должен быть определен до семантики

Парсинг - parsing - процесс анализа синтаксиса текста и его соответствия синтаксическим правилам языка

Текст - последовательность символов - на естественном или искусственном языке,
в текущей работе текст - программный код, в частности, команда, передаваемая в CLI

Пример: синтаксис [спецификации MPEG-video](https://www.iso.org/standard/19180.html) определяет как декодер формирует изображение по переданной ему связке инструкция+данные 

---
> /Большая советская энциклопедия/
> Математическая лингвистика/
математическая дисциплина, разрабатывающая формальный аппарат для описания строения естественных и некоторых искусственных языков. Возникла в 50-х годах 20 века в связи с назревшей в языкознании потребностью уточнения его основных понятий. В М. л. используются по преимуществу идеи и методы алгебры, алгоритмов теории (См. Алгоритмов теория) и автоматов теории (См. Автоматов теория). Не являясь частью лингвистики, М. л. развивается в тесном взаимодействии с ней. М. л. называют иногда лингвистические исследования, в которых применяется какой-либо математический аппарат. 
> Математическое описание языка основан на восходящем к Ф. де Соссюру представлении о языке как механизме, функционирование которого проявляется в речевой деятельности его носителей; её результатом являются «правильные тексты» — последовательности речевых единиц, подчиняющиеся определённым закономерностям, многие из которых допускают математическое описание. Изучение способов математического описания правильных текстов (в первую очередь предложений) составляет содержание одного из разделов М. л. — теории способов описания синтаксической структуры. Для описания строения (синтаксической структуры) предложения можно либо выделить в нём «составляющие» — группы слов, функционирующие как цельные синтаксические единицы, либо указать для каждого сло́ва те слова́, которые от него непосредственно зависят (если такие есть). Так, в предложении «Лошади кушают овёс» при описании по 1-му способу составляющими будут: всё предложение I, каждое отдельное слово и словосочетание С = «кушают овёс» (рис. 1; стрелки означают «непосредственное вложение»); описание по 2-му способу даёт схему, показанную на рисунке 2. Математические объекты, возникающие при таком описании структуры предложения, называются деревом составляющих (1-й способ) и деревом синтаксического подчинения (2-й способ).

> Грамматика формальная/
(в лингвистике)
логическая система, или исчисление, задающая некоторое множество («правильных») цепочек (= конечных последовательностей), построенных из символов заданного конечного набора, называемого «алфавитом» или «основным (терминальным) словарём». 
> В теории Г. ф. цепочки интерпретируются как языковые объекты различных уровней: например, слоги (= цепочки фон), словоформы (= цепочки морф), предложения (= цепочки словоформ) и т. п. Введённые в лингвистику американским учёным Н. Хомским (См. Хомский), Г. ф. представляют собой средство строгого описания естественных языков. 
> Теория Г. ф. составляет важный раздел математической лингвистики (См. Математическая лингвистика), в рамках которой принято подразделение на Г. ф. порождающие и распознающие.
Грамматика порождающая задаёт множество (правильных) цепочек перечислением этих последних вместе с указаниями об их строении; порождающая грамматика может построить любую правильную цепочку, снабдив её характеристикой её структуры, и не должна строить ни одной неправильной цепочки. Наиболее известная разновидность порождающих грамматик — это так называемые грамматики Хомского.
Грамматика распознающая задаёт множество (правильных) цепочек распознаванием этих последних, а именно: для любой предъявленной цепочки грамматика решает, является ли она правильной, и в случае положительного ответа даёт указания о её строении. Наиболее известная разновидность распознающих грамматик — т. н. категориальные, или К-грамматики (введённые К. Айдукевичем и И. Бар-Хиллелом).

---

- задача парсинга - построение текста в виде абстрактного синтаксического дерева - AST

- пример
  - парсинг строки `x = 5 + 3 * 2`
  - ожидаемый результат - AST, описывающее валидный порядок операций и аргументов: умножение 3 и 2 -> сложение 5 и (результат умножения 3 и 2) -> присваивание результата

- теоретическая основа парсинга - формальная грамматика, основанная на математической лингвистике
  - формальная грамматика описывает синтаксис языка
- виды грамматик по отношению к контексту:
  - контекстно-зависимые - учитываются соседние символы - задача NP-полная
  - контекстно-независимые - символ рассматривается без учета окружения - достаточно для анализа языков программирования

---

### Стек / Stack
- структура данных типа FIFO - первым пришел, первым вышел
- в парсинге применяется для накопления последновательности прочитанных символов

---

### Байт-код
- текст программных команд, предназначенный для исполнения виртуальной машиной - JVM в случае Java
---

## Ход работы
входные данные - сырой текст - строка, содержащая последовательность символов
каждый шаг парсинга, выполняя определенную задачу по обработке текста, дает на выходе представление, пригодное для обработки следущим шагом
объект - результат работы шага парсинга - передается на вход следующего шага  

### Этапы обработки текста программы
принцип обработки одинаковый для любого текста, 
в текущем задании происходит обработка искусственного языка - ЯП, что проще поддается описанию из-за наличия формальных требования языка

текст -> лексический анализ -> токены/лексемы -> синтаксический анализ -> абстрактное синтаксическое дерево / АСД -> анализ -> промежуточное представление
обработка промежуточного представления будет зависеть от реализации ЯП
возможны
- трансляция в текст ЯП высокого уровня
- генерация байт-кода
- генерация машинного кода

#### Сканирование / Лексический анализ
оно же - лексирование, или, лексический анализ
исполнитель - алгоритм лексер, или, лексический анализатор
алгоритм получает на вход последовательность / поток символов
алгоритм разбивает последовательность на группы символов согласно запрограммированным правилам
алгоритм возвращает последовательность сгенерированных групп
сгенерированная группа называется лексемой, в естественном языке аналогия - "слово"
лексема - или токен - литерал - например, число, строка, знак пунктуации, пробельный символ

пример
на вход лексеру передается строка
`var average = (min + max) / 2;`

лексер принимает строку как последовательность символов
`v`, `a`, `r`, ` `, `a`, `v`, `e`, `r`, `a`, `g`, `e`, ` `, `=`, ` `, `(`, `m`, `i`, `n`, ` `, `+`, ` `, `m`, `a`, `x`, `)`, ` `, `/`, ` `, `2`, `;`

результат работы лексера - для определенного набора правил
последовательность лексем
`var`, `average`, `=`, `(`, `min`, `+`, `max`, `)`, `/`, `2`, `;`

#### Парсинг / Синтаксический анализ
алгоритм, преобразующий последовательность лексем в грамматические конструкции по грамматическим правилам конкретного ЯП
то есть понятие синтаксической корректности зависит от ЯП
например, для JS корректно ключевое слово `var`, в Python `var` не является ключевым словом, и, так как в примере после var идет литерал имени переменной, в python выражение из примера не будет принято как валидная инструкция

алгоритм парсинга выполняет парсер
парсер получает на вход последовательность лексем, сгенерированную лексером
результат работы парсера - абстрактное синтаксическое дерево лексем
струтура дерева - ненаправленный граф - фиксирует взаимосвязь литералов

```
                   average : переменная
                      |
                      / : оператор деления
              |                         | 
          + : оператор сложения         2 : литерал числа 2
     |                  |
   min : переменная    max : переменная 
```
парсер проверяет дерево на синтаксическую корректность для заданного ЯП

> алгоритмы лексического и синтаксического анализа схожи во всех ЯП
 
> существуют ли примеры принципиальных отличий?

#### Анализ типов / Типизация / Статический анализ
алгоритм статического анализа получает на вход абстрактное синтаксическое дерево - лексически значимые элементы и описание их взаимосвязей
в каждом ЯП своя реализация алгоритма
пример 
на вход передано дерево, представляющее выражение `a + b`
известно, что производится сложение объектов `a` и `b`
однако об этих объектах нет информации: неизвестен тип объекта, если предположить, что это переменные, то неизвестна область видимости, неизвестно, на какие значения переменные ссылаются

задача статического анализа - получение информации об элементах синтаксических конструкций - лексемах

разрешение / связывание - первый шаг анализа
лексема есть идентификатор
связывание находит объявление объекта, обозначаемого идентификатором и создает ссылку  
учитывается область видимости - часть исходного кода, в которой действует определение объекта
> на этом этапе известно, на какие объекты ссылаются a и b
 
в ЯП со статической типизацией на этом этапе выполняется проверка типа - если будут найдены отличия типов переменной и значения - произойдет type error

> в ЯП с динамической типизацией проверка типа выполняется в runtime

##### Хранение собранной информации
появляется проблема хранения данных о лексемах
варианты реализации:
- добавить атрибуты узлам АСД
- создать маппинг идентификатор:атрибуты
- создать новую структуру данных - промежуточное представление - инструкции программ уже не являются исходным кодом, но еще не преобразованы в код, пригодный для выполнения машиной

#### Промежуточное представление
инструкции программ уже не являются исходным кодом, но еще не преобразованы в код, пригодный для выполнения машиной
такое представление - подобие интерфейса - может быть преобразовано для обработки различными компиляторами - добавляет свойство переносимости

лексический, синтаксический и статический анализ оъединяют термином front end

к backend относят процедуры перевода машинного кода для архитектур процессоров

промежуточное представление позволяет независимо поддерживать фронт и бэк
один фронт для каждого ЯП, один бэк для каждой архитектуры
представление связывает любой фронт с любым бэком


> Hit your search engine of choice
and look for “control flow graph”, “static
single-assignment”, “continuation-passing
style”, and “three-address code”.

#### Оптимизация
- не является целью изучения, для общего представления
- повышение производительности операций и сокращение объема задействованной памяти, в compile 
- пример: замена константой выражений, всегда возвращающих одно и то же значение
> понятия 
> “constant propagation”, “common
subexpression elimination”, “loop invariant
code motion”, “global value numbering”,
“strength reduction”, “scalar replacement of
aggregates”, “dead code elimination”, and
“loop unrolling”.

#### Генерация кода
преобразование промежуточного оптимизированного представления в код, понимаемый машиной
тип целевого кода зависит от реализаци ЯП - возможна генерация кода для выполнения на реальном процессоре или на виртуальном
в случае реального процессора для каждой архитектуры процессора требуется своя реализация генератора
код для виртуального процессора - байткод - портируемый код для виртуальной машины, название отражает идею размещение одной команды в пределах одного байта памяти

можно рассматривать байткод как абстракцию надо низкоуровневыми командами ЯП

далее байткод требуется перевести на язык команд процессора
для этого можно создать компилятор байткода - программу, которая установит маппинг команды байткода к команде процессора

другое решение - создать языковую виртуальную машину - программу выполняющую команды байткода так, как будто эта машина есть процессор
пример: ВМ реализована на C, для работы такой ВМ достаточно наличие компилятора ЯП C в системе

#### Выполнение кода
Если при генерации создан исполняемый файл с машинным кодом, то для выполнения кода исполняемый файл передается на выполнение операционной системе
Если сгенерирован файл с байт-кодом, запускается соответствующая ВМ, код передается на выполнение ВМ
Область выполнения называют runtime
runtime - множество объектов и процессов, необходимых для выполнения кода: система управления памятью, сборка мусора (освобождение памяти от объектов, на которые не существует ссылок), таблицы виртуальных методов, ...


### Иные подходы
Компиляция в одну итерацию
Возможно завершить компиляцию на этапе парсинга, если договориться о строгом порядке следования команд для того, чтобы не потребовалось читать - и даже создавать - АСД
например, если вызов функции всегда следует после ее объявления
так компилятору не потребуется повторно считывать лексемы

Интерпретация по дереву
Возможно, подходящее решение для настоящего проекта
Выполнение кода осуществляется после построения дерева - команды выполняются от кроны к корню

Межязыковая компиляция / Трансляция
Идея - после семантических преобразований, когда определено, что команды соответствуют требованиям целевого ЯП, перевести полученные команды на язык команд другого языка того же уровня абстракции
Пример: перевод с ассемблера 8-разрядного процессора на ассемблер 16-разрядного процессора, перевод на C для совместимости c Linux, так как компилятор C есть в этих системах по умолчанию, перевод на JS для запуска в web-браузере

JIT компиляция / компиляция при выполнении
jit компилятор из исходного кода создает машинный код конкретно для той машины, на которой он запущен

Отличия от обычной компиляции
- ключевая идея - определить часто вызываемую повторяющуюся команду, и при повторном ее вызове выполнять уже известный для нее машинный код напрямую на ЦП
- машина, на которой выполняется компиляция: обычная - машина разработчика, JIT - машина пользователя
- время выполнения: обычная - до выполнения, JIT - во время выполнения
- порядок выполнения:
  - обычная: текст программы - .java - .class - .jar | .exe - ВМ
  - jit: текст программы - .class - машинный код

### Итог
компиляция - процедура перевода текста исходного кода, написанного на языке программирования A, на язык программирования B
Обычно, B - язык более низкого уровня по отношению к A
По этому определению к компиляции можно отнести интерпретацию и трансляцию

Но компилятор не есть интерпретатор
Компилятор создает исполняемый файл, выполнение вне ответственности компилятора
Интерпретатор выполняет созданный им код, "выполняет из исходника"

Множества компиляторов и интерпретаторов пересекаются, 
например, Go позволяет скомпилировать выполняемый файл или выполнить программу из исходника - интерпретировать исходный код

> CHALLENGES
1.Pick an open source implementation of a language you like. Download the source
code and poke around in it. Try to find the code that implements the scanner and
parser. Are they hand-written, or generated using tools like Lex and Yacc? ( .l or
.y files usually imply the latter.)
2.Just-in-time compilation tends to be the fastest way to implement a dynamically-
typed language, but not all of them use it. What reasons are there to not JIT?
3.Most Lisp implementations that compile to C also contain an interpreter that lets
them execute Lisp code on the fly as well. Why?
> 
> 

Парсинг строки - процесс получения лексем из текстовой строки с последующей их обработкой согласно синтаксису языка или формату данных

---

# Реализация
Задача - построить парсер

#### Парсер
- Парсер ≡ синтаксический анализатор
- часть компилятора (парсинг - этап компиляции), выполняющее чтение исходного кода, проверку синтаксиса, создание промежуточного файла, пригодного для обработки на следующих этапах компиляции
- различают синтаксические анализаторы
  - нисходящие - top-down
  - восходящие - bottom-up

## Структура программы

## Лексический анализатор
- источник ввода - String
- поддерживаемые лексемы
  - тип операции: 
    - перечисление / enum: `deposit`, `withdraw`, `transfer`
  - параметры операций:
    - deposit сумма id счета `deposit 100 7317ba2f-9145-4f31-9efe-5b4919b2b027`
    - withdraw сумма id счета `withdraw 100 7317ba2f-9145-4f31-9efe-5b4919b2b027`
    - transfer сумма id счета 1 id счета 2 `transfer 100 7317ba2f-9145-4f31-9efe-5b4919b2b027 7317ba2f-9145-4f31-9efe-5b4919b2b028`
  - сумма: 
    - целые числа: 
      - пример: `123`
    - десятичные дроби с одним или двумя знаками в дробной части, разделитель - точка, 
      - пример: `123`, `123.4`, `123.45`
  - id счета - строка в формате UUID
    - 32 16-ричные цифры, разделенные дефисами на 5 групп
      - `xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx`
      - `7317ba2f-9145-4f31-9efe-5b4919b2b027`
- пробельные символы игнорируются
- чтение символа, непредусмотренного требованиями, останавливает обработку с сообщением об ошибке `некорректный ввод`
- позиция курсора хранится в переменной/поле класса `offset`
- корректно обрабатывать сигнал `EOF`
  - обрабатывать значение как поток, количество символов в строке неизвестно
  - `EOF` в Java есть `null`, возвращаемый `BufferedReader`
  - завершать обработку, когда достигнут конец строки
  - проверить отсутствие "некомплектных" парных элементов
    - незакрытые скобки `(123`
    - незакрытые кавычки `"asdf`
    - незавершенные числа `123.`

### Концепты реализации

#### иерархия грамматик Хомского
иерархия классифицирует формальные грамматики по их синтаксической сложности

в порядке возрастания синтаксической сложности определены формальные грамматики:

- регулярная
  - уровень лексического анализатора / лексера

- контекстно-свободная
  - уровень синтаксического анализатора / парсера

- контекстно-зависимая
- свободная

#### рекурсивный спуск
- алгоритм чтения и проверки лексем в тексте - в частности, распознавания команд в тексте исходного кода

---

#### Контекстно-свободные грамматики
Система формальных правил описания языков программирования
Текст состоит из символов
Символы представлены терминалами и нетерминалами
КС грамматика Определяет правила взаимодействия символов, при котором не нарушаются синтаксические правила языка и сохраняется смысл конструкции
Пример - проверка исходного кода программы статическим (синтаксическим) анализатором - линтером


##### Составляющие

###### нетерминалы
- элементы, которые могут быть представлены последовательностью других элементов в результате продукции
- представляют синтаксические категории: утверждения, выражения

###### терминалы
- элементы, которые не могут быть далее раскрыты/представлены цепочкой иных операций и/или терминалов, 
  - соответствующие синтаксическим правилам языка: ключевые слова, операторы, переменные
- пример для банковских операций: `deposit`, ` `, `123.45`, `7317ba2f-9145-4f31-9efe-5b4919b2b027`

###### начальный символ | стартовый символ | start symbol
- нетерминал, от которого начинается применение продукционных правил
- задача - преобразовать нетерминал в цепочку терминалов
- обозначается `S`

###### продукция | правила вывода | продукционные правила | production rules
применение вне КС-грамматики ограничено, так как не дает формальной строгости
дает наглядность, читаемость, "понимаемость на глаз" - для быстрого проектирования черновика системы норм
форма представления знания в формате импликации (если-то): условие-действие 
не учитывает содержание суждение, только формальную логическую зависимость
> ЕСЛИ запрошена операция снятия И сумма не превышает баланс, ТО выполнить снятие
> ЕСЛИ найдена строка `withdraw 100`, ТО вызвать статический метод Withdraw.perform(100)
> ЕСЛИ в коде есть "{" без "}", ТО — ошибка синтаксиса

derivation - вывод - результат применения правил
применение правила обозначается `A → α`, A - нетерминал, α - цепочка терминалов и/или нетерминалов

задача - построить цепочку терминалов


грамматика арифметического выражения
---
S - стартовый символ, начальный нетерминал
E, T, F - нетерминалы
+, *, a, b, 0, 1, (, ) - терминалы

```
1/ S → E
2/ E → E + T | T
3/ T → T * F | F
4/ F → ( E ) | a | b | 0 | 1
```
правило 1 - S → E - гласит 
- любая строка описываемой грамматики начинается с S
- первый шаг всегда - замена S на E - замена стартового символа на нетерминал

---

#### BNF
Backus-Naur Form ≡ BNF ≡ форма Бэкуса-Наура ≡ нормальная форма Бэкуса-Наура
- формальная система описания ≡ нотация ≡ метаязык
- применяется для описания синтаксиса искусственных языков - грамматики, элементов, атрибутов
  - ЯП, 
  - данных, 
  - протоколов

- основные элементы
  - терминал - символ - "" (указывается в кавычках, пример: `"+"`)
    - позиция в грамматической конструкции, которую невозможно заменить/упростить, конечное/терминальное описание
  - нетерминал - правило - в скобках <> - пример: `<expr>`
    - позиция в грамматической конструкции, которую можно заменить упрощенной конструкцией
  - определение - выражается знаком `::=`
    - пример: `<expr> ::= <term>` - выражение определяется как терминал - этому описанию соответствуют нетерминалы число, арифметическое выражение (42, 2*2) 
      - `2*2` - умножение - символ-оператор, это нетерминал, так же как и числа 2
      - `2*2` нельзя упростить, это терминал, * - часть терминала в данном контексте
    - пример: `<expr> ::= <term> | <expr> "+" <term>` 
  - группировка
- принцип
  - последовательное определение одних синтаксических категорий через другие
  - или, как построить сложную конструкцию из простых, декомпозировать

- задача - описать допустимые конструкции и допустимый порядок следования конструкций
- примение: с помощью BNF описаны C, Java, SQL, JSON, XML
- бнф-конструкция определяет конечное число символов
- бнф-конструкция определяет правила замены символа на последовательность символов
- по бнф-описанию языка можно построить парсер этого языка
- по бнф-описанию языка можно построить компилятор компиляторов - алгоритм, создающий компилятор языка по синтаксическому или семантическому описанию этого языка
- BNF дополнена в системах EBNF и ABNF

#### EBNF
- расширенная нормальная форма Бэкуса-Наура

#### ABNF
- пополненная нормальная форма Бэкуса-Наура
- метасинтаксис для представления контекстно-свободных грамматик
- формальный способ описания формальных языков
- частое применение - описание протоколов IETF

#### peg
#### antlr
#### отличие рекурсивных грамматик от регулярных выражений
Требования
> описать грамматику EBNF
> методы статические
> Принимают указатель на позицию в исходнике
> Возвращал опциональной результат - Optional<>

> пример для текущей задачи со счетами и деньгами

---

[код - лексер](/src/main/java/FinOps/FinLexer.java)




---

## Источники

Что почитать о языках/компиляторах/трансляторах

1) https://craftinginterpreters.com/
   можно в online (engilsh)

Очень практическая книга

Написание интерпретатора языка Lox (на Java и C)
Построение AST, парсера (рекурсивный спуск)

Вторая часть — bytecode VM с ручной реализацией GC
Особо: открытая онлайн-версия — https://craftinginterpreters.com
Уровень: от новичка до среднего

но из за практичности может вылететь теория, хотя вроде толково написана

2) https://habr.com/ru/articles/786158/ Компилятор за выходные

6 статей
Синтаксические деревья и наивный транслятор в питон (эта статья)
Лексер/парсер
2'. Про́клятый огонь, или магия препроцессора C
Таблицы символов: области видимости переменных и проверка типов
Стек и транслятор в питон без использования питоновских переменных
Транслятор в ассемблер
Рейтрейсинг :)
некий Питон
норм

3) https://habr.com/ru/articles/99162/
   у автора вроде 10 статей на эту тему
   по сути немного по другому изложение

начните с этой страницы https://habr.com/ru/users/tyomitch/articles/page6/

4) Сергей Александрович Орлов
   Теория и практика языков программирования:
   Учебник для вузов.

суховато, но как учебник для вузов самое то.. много букв

5) Книга «Основы компиляции: инкрементный подход»
   Джереми Сик

Вот это, точно практичный подход, рекомендую
но тут вы уже должны знать/уметь написание парсеров AST, и написать хотя бы примитивный интерпретатор

https://habr.com/ru/companies/piter/articles/791764/

6) https://habr.com/ru/articles/110710/
   Грамматика арифметики или пишем калькулятор на ANTLR

что бы не мучиться и быстро написать парсер,
да для idea/vs code есть плагины

---------------------------------
если не разу не касались темы, то начните либо со статей на хабр, либо https://craftinginterpreters.com/

конечно лучше самому на практике написать примитивный калькулятор, что бы в голове понятия встали по местам

проблема с чтением одна - на опыта не много дает, лучше руками по пробовать

#ldev


Написал 3 больших текста, с примером рабочего кода.
Тема текстов - синтаксический анализ текста.

Собственно сам рабочий пример и тексты лежат тут
https://github.com/gochaorg/samples/tree/master/math-parse

текст разбит на 3 смысловых блока

1) https://github.com/gochaorg/samples/blob/master/math-parse/semantic.md - Про семантику
2) https://github.com/gochaorg/samples/blob/master/math-parse/lexer.md - Про лексический анализ
3) https://github.com/gochaorg/samples/blob/master/math-parse/grammar.md -  Про грамматики и в частности про грамматику арифметики

Как их читать

Эти тексты взаимосвязаны между собой, следует читать последовательно

Первый текст может показаться "водой", по сути так и есть, но первую его половину - диалог, можно пропустить.

В нем есть заголовок Семантика - он описывает понятие числа и операций на столько четко, так что бы запрограммировать его

Второй и третий текст - собственно это уже о синтаксисе

----------------

Я не буду сюда его копировать, т.к. большая часть форматирования "поедет"

Просьба оставить отзыв о этих текстах в комментариях, можно вопросы задать уточняющие - отвечу

PS вот на Хабре описываются польза от создания своего языка
https://habr.com/ru/companies/ruvds/articles/835974/

такая мотивационая статья


samples/math-parse/grammar.md at master · gochaorg/samples · GitHub
https://github.com/gochaorg/samples/blob/master/math-parse/grammar.md


Принцип схожий

Только вот сначала реши с чего начнёшь, какие классы или понятия у тебя будут в парсинге