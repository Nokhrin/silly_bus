## Консольный трекер задач

## Установка и запуск трекера - для пользователя


## Установка и запуск проекта - для разработчика


## 


### Применяемые технологии и подходы

Паттерн Одиночка / Singleton для списка задач

Ввод/вывод
- Ввод - `BufferedReader`
- Печать, запись в файл - `BufferedWriter`
---
Обработка ошибок / перехват исключений
---
Управление зависимостями
добавить пакет `slf4j`
---
Логирование
применить `slf4j` + `slf4j-simple`
---
Сборка
имя пакета `tracker.jar`
shell скрипт сборки
сборка Maven
---
Критерии проверки
- При запуске `java -jar tracker.jar` выводится меню.
- Данные сохраняются в `tasks.csv` и загружаются при повторном запуске.
- Обработка ошибок: некорректный ввод числа, отсутствие файла.
---
Установка проекта для разработчика
выполняется клонирование репозитория
выполняется установка зависимостей


---
   
## Постановка задачи / Ход выполнения / Вопросы 

### 9. Итоговый проект: Консольный трекер задач
**Цель**: Объединить все навыки в приложении с сохранением состояния.


#### **План решения и обоснование**
1. **Структура данных** (процедурный стиль):
    - Используем `List<Map<String, String>>` вместо класса `Task` (как в п.3).  
      *Обоснование*: Избегаем ООП, работаем с коллекциями как в п.3.

2. **Ввод/вывод и обработка ошибок** (п.4, п.8):
    - Меню через `Scanner` (п.4).
    - Сохранение в `tasks.csv` через `BufferedWriter` (п.8).  
      *Обоснование*: Повторяем шаблоны из п.4 и п.8, но объединяем их.

3. **Сборка** (п.6, п.7):
    - Сборка через Maven (п.7) для упрощения запуска.


#### **Критерии проверки**
- При запуске `java -jar tracker.jar` выводится меню.
- Данные сохраняются в `tasks.csv` и загружаются при повторном запуске.
- Обработка ошибок: некорректный ввод числа, отсутствие файла.

#### **Каверзные вопросы**
- ❓ Что произойдет, если в `tasks.csv` будет строка `Buy milk,high` (без статуса)?
  - > *Ответ*: Программа пропустит строку (как в п.8 при `FileNotFoundException`).
  - TODO - развернуть ответ

- ❓ Почему `try-with-resources` безопаснее ручного закрытия файла?  
  - > *Ответ*: Гарантирует закрытие даже при ошибках (как в п.4).  
  - каким средствами достигается эта гарантия?
  - как именно происходит обработка ошибки?
  - как происходит работа в штатном порядке / когда ошибки нет?

---

## чему я научился
- решение проблемы запуска пакета типа `добавить jar в classpath`
- настройка логирования в консоль
- при записи файла применил `try-with-resources` для освобождения ресурсов
- использовать сокращенную подстановку в строку при печати в SLF4J
  - `logger.debug("Введена строка {}", line);`

---

# вопросы

### переопределения

ai-assistant посоветовал

```java
    // Переопределение equals и hashCode — важно для тестов
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Task task = (Task) o;
        return id.equals(task.id);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
```

почему важно?
equals() и hashCode() — основа корректной работы коллекций (Set, Map)
в частности, для операций сравнения

если не переопределить метод equals, он будет работать по умолчанию, то есть, будет проверять равенство ссылок на объекты, но не содержимое объектов 









### работа с файлами
- какой подход работы с директориями лучше и почему?
  - путь - экземпляр String?
  - путь - экземпляр Path?
- что делает `InputStreamReader(System.in)`?
  - создает строковый поток из байтового потока, переданного в качестве аргумента
  - читает посимвольно
- что делает `BufferedReader(new InputStreamReader(System.in))`?
  - добавляет функционал для работы с прочитанным строковым потоком
    - например, читает строку целиком
  - работает с текстом
  - применяет буферизацию
    - накапливает в памяти символы, считанные потоком


---
- поймал проблему с BufferedReader в цикле - только на второй итерации:
```
writer.write("\nВведи команду...");
writer.flush();
userInput = reader.readLine();
```
- чат:
> ✅ На первый взгляд — всё работает.  
> ❌ **НО**: `System.out` и `System.in` — это **стандартные потоки**, и **они не закрываются автоматически**, но **могут быть закрыты другим кодом**, особенно если:
- Приложение останавливается (например, `System.exit()`),
- Код вызывается в среде, где потоки могут быть перехвачены (например, IDE, тесты, контейнеры),
- Или `System.setOut()` / `System.setIn()` были вызваны ранее.

- командыи из 1 и 3 не использовал, предполагаю, случился кейс 2, потому что выполнял в IDE

- обнаружил, что создаю новый буфер чтения в методе чтения при получении имени задачи, убираю, передаю буферЧитатель из мейна

---

### тестирование
- создавать несколько классов тестов для одного класса приложения - норм практика?
  - или придерживаться "один класс приложения - один класс тестов"?

- `testReadFileContent`
  - корректно ли создание файла в автотесте с точки зрения проверки?

### конфигурация Maven
- назначение и практическое применение тега <scope> в <dependency>
  - этап сборки, на котором используется либа
- код использует `System.exit()`, из-за чего сборка падает на этапе тестов
  - `System.exit()` завершает работу всей JVM
  - заменил выходом из метода `return;`
    - для void метода `return;` не возвращает никакого значения

### данные
- сообщение лога - поясни происхождение символов `[L`
> [main] DEBUG pop.lesson09.TaskTracker - [Ljava.lang.String;@31221be2
  - `[L` - массив объектов, `java.lang.String` тип объектов массива, итого: `массив строк по адресу 31221be2`

- корректно так создавать датувремя?
```
LocalDateTime creation_time = LocalDateTime.now();
```
> корректно

- корректно использовать в юниттестах `UUID.randomUUID()`?
```
String id = String.valueOf(UUID.randomUUID());
```
> корректно

### логирование
- вывод логгера при выполнении TestNG
- каждый класс содержит свой закрытый и неизменяемый экземпляр логгера?
- практика в ООП такая?
- если придерживаться процедурного стиля, то корректно создать один логгер в методе `main`?
  - или всё же в каждом классе?
    - интуитивно это считаю более чистым и управляемым подходом, но хочу придерживаться видения задачи
