### 9. Итоговый проект: Консольный трекер задач
**Цель**: Объединить все навыки в приложении с сохранением состояния.


#### **План решения и обоснование**
1. **Структура данных** (процедурный стиль):
    - Используем `List<Map<String, String>>` вместо класса `Task` (как в п.3).  
      *Обоснование*: Избегаем ООП, работаем с коллекциями как в п.3.

2. **Ввод/вывод и обработка ошибок** (п.4, п.8):
    - Меню через `Scanner` (п.4).
    - Сохранение в `tasks.csv` через `BufferedWriter` (п.8).  
      *Обоснование*: Повторяем шаблоны из п.4 и п.8, но объединяем их.

3. **Сборка** (п.6, п.7):
    - Сборка через Maven (п.7) для упрощения запуска.


#### **Критерии проверки**
- При запуске `java -jar tracker.jar` выводится меню.
- Данные сохраняются в `tasks.csv` и загружаются при повторном запуске.
- Обработка ошибок: некорректный ввод числа, отсутствие файла.

#### **Каверзные вопросы**
- ❓ Что произойдет, если в `tasks.csv` будет строка `Buy milk,high` (без статуса)?
  - > *Ответ*: Программа пропустит строку (как в п.8 при `FileNotFoundException`).
  - TODO - развернуть ответ

- ❓ Почему `try-with-resources` безопаснее ручного закрытия файла?  
  - > *Ответ*: Гарантирует закрытие даже при ошибках (как в п.4).  
  - каким средствами достигается эта гарантия?
  - как именно происходит обработка ошибки?
  - как происходит работа в штатном порядке / когда ошибки нет?

---

## чему я научился
- решение проблемы запуска пакета типа `добавить jar в classpath`
- настройка логирования в консоль
- при записи файла применил `try-with-resources` для освобождения ресурсов

---

## вопросы

### работа с файлами
- какой подход работы с директориями лучше и почему?
  - путь - экземпляр String?
  - путь - экземпляр Path?
- что делает `InputStreamReader(System.in)`?
  - создает строковый поток из байтового потока, переданного в качестве аргумента
  - читает посимвольно
- что делает `BufferedReader(new InputStreamReader(System.in))`?
  - добавляет функционал для работы с прочитанным строковым потоком
    - например, читает строку целиком
  - работает с текстом
  - применяет буферизацию
    - накапливает в памяти символы, считанные потоком


### тестирование
- создавать несколько классов тестов для одного класса приложения - норм практика?
  - или придерживаться "один класс приложения - один класс тестов"?

- `testReadFileContent`
  - корректно ли создание файла в автотесте с точки зрения проверки?

### конфигурация Maven
- назначение и практическое применение тега <scope> в <dependency>
  - этап сборки, на котором используется либа
- код использует `System.exit()`, из-за чего сборка падает на этапе тестов
  - `System.exit()` завершает работу всей JVM
  - заменил выходом из метода `return;`
    - для void метода `return;` не возвращает никакого значения

### данные
- сообщение лога - поясни происхождение символов `[L`
> [main] DEBUG pop.lesson09.TaskTracker - [Ljava.lang.String;@31221be2
  - `[L` - массив объектов, `java.lang.String` тип объектов массива, итого: `массив строк по адресу 31221be2`

- корректно так создавать датувремя?
```
LocalDateTime creation_time = LocalDateTime.now();
```
> корректно

- корректно использовать в юниттестах `UUID.randomUUID()`?
```
String id = String.valueOf(UUID.randomUUID());
```
> корректно

### логирование
- вывод логгера при выполнении TestNG
- каждый класс содержит свой закрытый и неизменяемый экземпляр логгера?
- практика в ООП такая?
- если придерживаться процедурного стиля, то корректно создать один логгер в методе `main`?
  - или всё же в каждом классе?
    - интуитивно это считаю более чистым и управляемым подходом, но хочу придерживаться видения задачи
