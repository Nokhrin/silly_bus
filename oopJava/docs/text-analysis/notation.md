# Описание синтаксических правил

## BNF

Backus-Naur Form ≡ BNF ≡ форма Бэкуса-Наура ≡ нормальная форма Бэкуса-Наура
- классическая, без расширений
- формальная система описания ≡ нотация ≡ метаязык
- применяется для описания синтаксиса искусственных языков - грамматики, элементов, атрибутов
  - ЯП,
  - данных,
  - протоколов

- основные элементы
  - терминал - символ - "" (указывается в кавычках, пример: `"+"`)
    - позиция в грамматической конструкции, которую невозможно заменить/упростить, конечное/терминальное описание
  - нетерминал - правило - в скобках <> - пример: `<expr>`
    - позиция в грамматической конструкции, которую можно заменить упрощенной конструкцией
  - определение - выражается знаком `::=`
    - пример: `<expr> ::= <term>` - выражение определяется как терминал - этому описанию соответствуют нетерминалы: число, арифметическое выражение (42, 2*2)
      - `2*2` - умножение - символ-оператор, это нетерминал, так же как и числа 2
      - `2*2` нельзя упростить, это терминал, * - часть терминала в данном контексте
    - пример: `<expr> ::= <term> | <expr> "+" <term>`
  - группировка
- принцип
  - последовательное определение одних синтаксических категорий через другие
  - или, как построить сложную конструкцию из простых, декомпозировать

- задача - описать допустимые конструкции и допустимый порядок следования конструкций
- примение: с помощью BNF описаны C, Java, SQL, JSON, XML
- бнф-конструкция определяет конечное число символов
- бнф-конструкция определяет правила замены символа на последовательность символов
- по бнф-описанию языка можно построить парсер этого языка
- по бнф-описанию языка можно построить компилятор компиляторов - алгоритм, создающий компилятор языка по синтаксическому или семантическому описанию этого языка
- BNF дополнена в системах EBNF и ABNF



- поддерживает операторы:
`::=` - определение нетерминала - читается "определяется как ...", может обозначаться стрелкой вправо `->`
`<>` - угловые скобки заключают нетерминал
`""` - кавычки заключают терминал

---

`|` 
- СИНТАКСИЧЕСКАЯ КОНСТРУКЦИЯ
- НЕ ЛОГИЧЕСКАЯ ОПЕРАЦИЯ
- НЕ ТРЕБУЕТСЯ ЧТОБЫ КАКОЙ-ЛИБО ВАРИАНТ БЫЛ ИСТИННЫМ
- перечисление альтернатив подстановки
- A ::= B | C - А может быть либо В, либо С  // здесь не выполняется вычисление выражения, B или С - ссылки на подставляемые значения, которые определяют ФОРМУ, не смысл
- по нотации является включающим ИЛИ: A OR B === A v B === A | B
- по смыслу близко A _XOR_ B === A ⊕ B - выбирается только один вариант
- формально | допускает существование всех описанных альтернатив, по факту выбирается - в случае LL парсеров - первое слева правило, подходящая к лексему

`operation ::= "+" | "-" | "*" | "/"`
операция может одновременно быть какой-то одной из возможных

---

- не поддерживает операторы количества: `[]`, `{}`


пример кс-грамматики арифметического выражения

```bnf
<S>     ::= <E>
<E>     ::= <E> "+" <T> | <T>
<T>     ::= <T> "*" <F> | <F>
<F>     ::= "(" <E> ")" | "a" | "b" | "0" | "1"
```

<S>, <E>, <T>, <F> - нетерминалы - метапеременные
"(", ")", "a", "b", "0", "1" - терминалы

1, 2, 3, 4 - не последовательность действий! не шаги
это 4 правила, которые применяются для проверки синтаксиса строки

1 - 4 идут от общего к частному,
в обратном порядке от 4 к 1 - прослеживается "наращивание выражения"

`F -> ( E ) | a | b | 0 | 1`
- F есть базовое выражение | база, это либо выражение в скобках, либо переменная а или b, либо число 0 или 1

`T -> T * F | F`
- нетерминал либо раскладывается на умножение нетерминала и базы, либо преобразуется в базовое выражение
- T - 'term' - это выражение, которое можно заменить выражением `T * F` или выражением `F`
- F - 'factor' - элемент, который невозможно разложить - переменная, число

> a * b * 1
> умножение - левоассоциативно => a * b * 1 = (a * b) * 1
> по правилу T * F, то есть слева от умножения идет выражение,
> группировка a * (b * 1) этому не соответствует, поэтому рассматриваем (a * b) * 1
> по правилу T * F, то есть справа от умножения идет база,
> в группировке a * (b * 1) справа `(b * 1)`, что не является базой, так как содержит умножение

E -> E + T | T
- нетерминал либо раскладывается на сложение нетерминала и терминала, либо преобразуется в другой нетерминал

S -> E
- любая строка описываемой грамматики начинается с S
- первый шаг всегда - замена S на E - замена стартового символа на нетерминал
- то есть, любое выражение начинается с нетерминала

---

запись `num_value ::= digit {digit}` не имеет смысла в BNF
эквивалентная запись с применением рекурсии
- digits определяет сам себя по цифрам
- последняя цифра будет выходом из рекурсии:
```
num_value ::= digits
digits ::= digit | digit digits
digit ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
```

число со знаком определяется:
```
num_value ::= sign digits
digits ::= digit | digit digits
digit ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
sign ::= "+" | "-"
```
знак присутствует всегда

---


правила для парсера определены в нотации EBNF

## EBNF
- расширенная нормальная форма Бэкуса-Наура

пример
```
add_sub_expression ::= mul_div_expression { [ws] add_sub_operation [ws] mul_div_expression }
mul_div_expression ::= atom_expression { [ws] mul_div_operation [ws] atom_expression }
atom_expression ::= num_value | '(' [ws] add_sub_expression [ws] ')'
mul_div_operation ::= "*" | "/"
add_sub_operation ::= "+" | "-"
num_value ::= [sign] digit {digit}
digit ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
sign ::= "+" | "-"
ws ::= (" " | "\t" | "\n" | "\r") {" " | "\t" | "\n" | "\r"}
```

---

## ABNF
- пополненная нормальная форма Бэкуса-Наура
- частое применение - описание протоколов передачи данных

применяет иные символы сокращений 
- `n*` повтор n и более раз
  - в частности, 0*digit == {digit}
- `/` разделитель альтернатив

правила парсера в ABNF
```
add_sub_expression   = mul_div_expression 1*( [ws] add_sub_operation [ws] mul_div_expression )
mul_div_expression   = atom_expression 1*( [ws] mul_div_operation [ws] atom_expression )
atom_expression      = num_value / "(" [ws] add_sub_expression [ws] ")"
mul_div_operation    = "*" / "/"
add_sub_operation    = "+" / "-"
num_value            = [sign] 1*digit
digit                = "0" / "1" / "2" / "3" / "4" / "5" / "6" / "7" / "8" / "9"
sign                 = "+" / "-"
ws                   = *( " " / "\t" / "\n" / "\r" )
```

---

## PEG
parsing expression grammar
нотация для описания синтаксиса языка, семантика отличается от BNF и ее расширений

терминалы PEG:
- символ - строка в кавычках: `"1", "-", "123", ")"`
- классы символов: `["0"-"9"]`
- любой символ: `.`

операторы:
`?` - 0 или 1 вхождение
`*` - 0 и более
`+` - 1 и более
`/` - последовательный выбор
`<-` - определение | сопоставление

число определяется как 0 или один sign, за которым следует 1 или более digit
```
num_value <- sign? digit+
digit     <- "0" / "1" / "2" / "3" / "4" / "5" / "6" / "7" / "8" / "9"
sign      <- "+" / "-"
```

выбор:
- сопоставление с приоритетом слева направо
  - `a <- b / c` - если b вернуло значение, c не проверяется - `if b then b else c` - с только если не b
  - `a <- b / c` неэквивалентно `a = c / b`
то же выражение в ebnf `a ::= b | c` эквивалентно `a ::= c | b` - логическое ИЛИ - или b, или c


пример для калькулятора
```
add_sub_expression  <- mul_div_expression 1*( [ws] add_sub_operation [ws] mul_div_expression )
mul_div_expression  <- atom_expression 1*( [ws] mul_div_operation [ws] atom_expression )
atom_expression     <- num_value / "(" [ws] add_sub_expression [ws] ")"
mul_div_operation   <- "*" / "/"
add_sub_operation   <- "+" / "-"
num_value           <- sign? digit+
digit               <- "0" / "1" / "2" / "3" / "4" / "5" / "6" / "7" / "8" / "9"
sign                <- "+" / "-"
ws                  <- (" " / "\t" / "\n" / "\r")*
```

## ANTLR

операторы:
`?` - 0 или 1 вхождение
`*` - 0 и более
`+` - 1 и более
`|` - альтернатива
`()` - группировка
`:` - определение | сопоставление
`;` - конец определения
`''` - строки в одинарных кавычках
`[]` - классы символов
`..` - диапазоны

- семантически ближе к ЯП
- стилистически ближе к Java - из-за camel-case
- позволяет разделить направить считанные токены по каналам (channels)
  - например, заглушить пробельные символы напраляя их -> channel(HIDDEN) - искать лексемы, но скрыть результат
  - aналогия - перенаправление консольного вывода программы в /dev/null

пример для калькулятора
```
addSubExpression  : mulDivExpression ( (WS)? (ADD | SUB) (WS)? mulDivExpression );
mulDivExpression  : atomExpression ( (WS)? (MUL | DIV) (WS)? atomExpression );
atomExpression    : numValue | '(' (WS)? addSubExpression (WS)? ')';
MUL               : '*';
DIV               : '/';
ADD               : '+';
SUB               : '-';
numValue          : (SIGN)? DIGIT+;
DIGIT             : '0'..'9';
SIGN              : [+-];
WS                : [ \t\n\r] -> channel(HIDDEN);
```
