# Контекстно-свободные грамматики - КСГ

правилом может быть только конструкция, соответствующая формальным правилам синтаксиса
ИЛИ
в КСГ правило должно быть формально корректным


дано: expr - нетерминал, term - терминал

expr -> term   // корректно, может быть порождающим правилом - expr порождает term
-> term    // отсутствует нетерминальный символ - символ, от которого производится порождение => нарушение формального синтаксиса => некорректно
неопредленность, вызывающая вопрос "чем порождается term?"

expr ->   // некорректно, отсутствует цепочка порождаемых символов
неопредленность, вызывающая вопрос "что является порождением expr?"
порождение пустой цепочки формально корректно в представлении: `expr -> e`
e - это эпсилон, символ пустой цепочки

expr -> term +    // некорректно, бинарная операция, оператор + требует следования операнда
корректные примеры:
expr -> term + expr
expr -> term + term
expr -> term

## Обозначения и понятия

- аналогия в Java
  нетерминал - определение класса
  терминал - экземпляр класса


S -> A B    // нетерминал S порождает последовательность нетерминалов A B
A -> a | b  // A порождает или терминал a, или терминал b
B -> c | d  // B порождает или терминал c, или термниал d


пример
правило `expr -> term | expr + term` - сокращенная запись двух правил:
`expr -> term`
`expr -> expr + term`

формально:
A -> a | b - сокращенная запись правил
A -> a
A -> b

### Синтаксическое дерево - Parse Tree

дано порождающее правило
`expr -> term | expr + term`
expr - нетерминал, может быть заменен согласно порождающему правилу
term - нетерминал
`+` - терминал, не может быть заменен

expr порождает term
```
expr    // корень
|
term    // лист
```
ИЛИ

expr порождает expr плюс term
```
      expr     // корень дерева, имеет двух потомков
    /      \ 
expr       +     // экземпляр нетерминала expr Y, + - терминал
|         |
term      term    // терминалы - не могут иметь потомков
```

каждый лист - с необходимостью - потомок
но не каждый потомок - лист, потомком может быть внутренний узел
внутренний узел - или, ветка - нетерминал (в контексте синтаксического дерева)
лист - это потомок, у которого нет потомков - терминал (в контексте синтаксического дерева)

#### пример

S -> a | S + a
где S - нетерминал, a - терминал

дерево S -> a
```
      S        // корень, частный случай внутреннего узла, нетерминал 
      |        // порождает 
      a        // лист, терминал
```

дерево S -> S + a

```
      S        // корень, частный случай внутреннего узла, нетерминал
   /     \     // порождает
  S       +    // нетерминал S, является левым операндом; терминал +, оператор 
  |       |    // S порождает терминал; связь с правым операндом
  a       a    // правый операнд
```



## Понимание порождающих правил

> описать синтаксическое правило в форме синтаксического дерева 

### задача 1
дано порождающее правило
`expr -> term | expr + term`
expr - нетерминал, может быть заменен согласно порождающему правилу
term - нетерминал
`+` - терминал, не может быть заменен

expr порождает term
ИЛИ
expr порождает expr плюс term

одному способу порождения соответствует одно синтаксическое дерево (parse tree)

синтаксическое правило `expr -> term`

синтаксическое дерево:
```
expr    // корень
  |
term    // лист
```

правило: `expr -> expr + term`
дерево:
```
      expr     // экземпляр нетерминала expr X, корень дерева
    /      \ 
 expr       +     // экземпляр нетерминала expr Y, + - терминал
  |         |
 term      term    // терминалы - не могут иметь потомков
```

### задача 2
---

factor -> digit | ( expr )
digit -> 1 | 2 | ... | 9

factor порождает digit
ИЛИ
factor порождает expr в круглых скобках

```
factor
   |
   v
  expr    ИЛИ     factor
                    |
                    v
                 ( expr )
```

### задача 3
---

statement -> if ( expr ) statement    // описывает синтаксис конструкции, НЕ поведение или алгоритм условного ветвления
statement -> if ( expr ) statement  // синтаксически допустимая конструкция, где expr - нетерминал, statement - нетерминал
что происходит при ложности (expr) ?  - ответ на этот вопрос не является задачей грамматики

обработка условия if и решение о ветвлении - вопрос семантики
> КСГ описывает синтаксис, КСГ не описывает семантику

семантика обрабатывается компилятором/интерпретатором/транслятором после успешного синтаксического анализа

```java
import CalcParser.Expression;
import CalcParser.Parser;
import org.codehaus.groovy.ast.expr.BinaryExpression;

import java.util.Optional;

public static void main(String[] args) {
    Optional<Expression> expr = Optional.of(new BinaryExpression(new NumValue(1.0), Parser.Operation.ADD, new NumValue(2.0)));
    if (expr.isPresent()) {
        System.out.println("значение выражения = " + expr.get().evaluate());
    } else {
        System.out.println("выражение отсутствует");
    }
}
```

statement порождает statement при условии что выражение expr в круглых скобках истинно


```
        statement
            |
            v
         if (expr) -> statement
```


# контекстно-свободная грамматика - КСГ - арифметических и булевых операций

ксг - формальный аппарат описания синтаксиса языка с помощью правил вида `A -> aльфа`
правило `A -> aльфа` означает 
А порождает альфа, где А - нетерминал, альфа - любая цепочка из терминалов/нетерминалов, включая:
- терминальная цепочка: Т
- нетерминальная цепочка: E
- смешанная цепочка: E + T
- эпсилон - пустая цепочка

создание описания синтаксиса языка <-> построение КС-грамматики языка
- то есть, создание множества формальных правил A -> альфа, порождающих корректные синтаксические конструкции языка
- для арифметических операций - это построение КС-грамматики арифметических выражений
- для булевых - построение КС-грамматики булевых выражений

## Арифметические операции
язык следующих арифметических выражений:
- целочисленные константы
  - синтаксически является валидным выражением согласно правилу порождения F -> number
  - семантически является валидным выражением, так как может быть оценена к значению (свойство выражений)
  - возможное обозначение - атом или атомарное выражение
- скобки
- операции (+, *, -, /)

множество терминалов:
{0,1,2,3,4,5,6,7,8,9,+,−,∗,/,(,)}

число: d1 (d1 | ... | d9)* , di принадлежит {0, 1, ... 9}, d1 != 0 

множество нетерминалов: 
```
{  
  E - add_expr     // выражение - выражение сложения/вычитания
  T - mul_expr     // терм - выражение умножения/деления
  F - factor       // фактор - или выражение в скобках, или рекурсивное выражение в скобках, или число
}
```

ксг

```
E -> E + T | E - T | T    // выражение сложения/вычитания порождает или сложение нетерминалов E + T, или вычитание нетерминалов E - T, или нетерминал T
T -> T * F | T / F | F    // выражение умножения/деления порождает или произведение нетерминалов T * F, или частное нетерминалов T / F, или нетерминал F
F -> (E) | number         // нетерминал F порождает нетерминал выражение сложения/вычитания в скобках или терминал - число
```

~ebnf
```
add_expr ::= add_expr '+' mul_expr | add_expr '-' mul_expr | mul_expr
mul_expr ::= mul_expr '*' factor | mul_expr '/' factor | factor
factor ::= '(' add_expr ')' | number
number ::= '0' | [1-9][0-9]*
```

## Булевы операции
язык булевых выражений

множество терминалов
- константы: true, false
- операторы: not, and, or
- группировка: (, )

множество нетерминалов
B - булево выражение - стартовый символ
C - and - конъюнкция
D - or  - дизъюнкция
N - not - отрицание

ксг
```
B -> D                            // выражение порождает дизъюнкцию
D -> D or C | C                   // D порождает или выражение дизъюнкции между D и C, или C
C -> C and N | N                  // C порождает или выражение конъюнкции между С и N, или N 
N -> not N | (B) | true | false   // отрицание порождает или отрицание рекурсивно, или выражение в скобках, или терминал true, или терминал false
```
порядок правил определяет приоритет операций: not - наивысший, ниже - and, ниже - or
грамматика является левоассоциативной - выражения разрешаются слева направо

~ebnf
```
bool_expr ::= dis_expr
dis_expr ::= dis_expr 'or' con_expr | con_expr
con_expr ::= con_expr 'and' neg_expr | neg_expr
neg_expr ::= 'not' neg_expr | '(' bool_expr ')' | true | false
```

#### пример разбора выражения
`not true and false or true`

ожидаемый порядок:
not true -> false          // neg_expr - отрицание, остается `and false or true`
false and false -> false   // con_expr - конъюнкция, остается `or true`
false or true -> true      // dis_expr - дизъюнкция

```
                          bool_expr
                             |
                          dis_expr
                         /         \                                           
                  dis_expr       'or'     // применение dis_expr: not false or true -> true
                  /       \
          con_expr      'and'            // применение con_expr: false and false -> false
         /       \          
   neg_expr     'not'                      // применение neg_expr: not true -> false
       |          
    'true'                                  // терминал true
```
