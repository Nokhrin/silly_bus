# Контекстно-свободные грамматики - КСГ

правилом может быть только конструкция, соответствующая формальным правилам синтаксиса
ИЛИ
в КСГ правило должно быть формально корректным


дано: expr - нетерминал, term - терминал

expr -> term   // корректно, может быть порождающим правилом - expr порождает term
-> term    // отсутствует нетерминальный символ - символ, от которого производится порождение => нарушение формального синтаксиса => некорректно
неопредленность, вызывающая вопрос "чем порождается term?"

expr ->   // некорректно, отсутствует цепочка порождаемых символов
неопредленность, вызывающая вопрос "что является порождением expr?"
порождение пустой цепочки формально корректно в представлении: `expr -> e`
e - это эпсилон, символ пустой цепочки

expr -> term +    // некорректно, бинарная операция, оператор + требует следования операнда
корректные примеры:
expr -> term + expr
expr -> term + term
expr -> term

## Обозначения и понятия

- аналогия в Java
  нетерминал - определение класса
  терминал - экземпляр класса


S -> A B    // нетерминал S порождает последовательность нетерминалов A B
A -> a | b  // A порождает или терминал a, или терминал b
B -> c | d  // B порождает или терминал c, или термниал d


пример
правило `expr -> term | expr + term` - сокращенная запись двух правил:
`expr -> term`
`expr -> expr + term`

формально:
A -> a | b - сокращенная запись правил
A -> a
A -> b

### Синтаксическое дерево - Parse Tree

дано порождающее правило
`expr -> term | expr + term`
expr - нетерминал, может быть заменен согласно порождающему правилу
term - нетерминал
`+` - терминал, не может быть заменен

expr порождает term
```
expr    // корень
|
term    // лист
```
ИЛИ

expr порождает expr плюс term
```
      expr     // корень дерева, имеет двух потомков
    /      \ 
expr       +     // экземпляр нетерминала expr Y, + - терминал
|         |
term      term    // терминалы - не могут иметь потомков
```

каждый лист - с необходимостью - потомок
но не каждый потомок - лист, потомком может быть внутренний узел
внутренний узел - или, ветка - нетерминал (в контексте синтаксического дерева)
лист - это потомок, у которого нет потомков - терминал (в контексте синтаксического дерева)

#### пример

S -> a | S + a
где S - нетерминал, a - терминал

дерево S -> a
```
      S        // корень, частный случай внутреннего узла, нетерминал 
      |        // порождает 
      a        // лист, терминал
```

дерево S -> S + a

```
      S        // корень, частный случай внутреннего узла, нетерминал
   /     \     // порождает
  S       +    // нетерминал S, является левым операндом; терминал +, оператор 
  |       |    // S порождает терминал; связь с правым операндом
  a       a    // правый операнд
```



## Понимание порождающих правил

> описать синтаксическое правило в форме синтаксического дерева 

### задача 1
дано порождающее правило
`expr -> term | expr + term`
expr - нетерминал, может быть заменен согласно порождающему правилу
term - нетерминал
`+` - терминал, не может быть заменен

expr порождает term
ИЛИ
expr порождает expr плюс term

одному способу порождения соответствует одно синтаксическое дерево (parse tree)

синтаксическое правило `expr -> term`

синтаксическое дерево:
```
expr    // корень
  |
term    // лист
```

правило: `expr -> expr + term`
дерево:
```
      expr     // экземпляр нетерминала expr X, корень дерева
    /      \ 
 expr       +     // экземпляр нетерминала expr Y, + - терминал
  |         |
 term      term    // терминалы - не могут иметь потомков
```

### задача 2
---

factor -> digit | ( expr )
digit -> 1 | 2 | ... | 9

factor порождает digit
ИЛИ
factor порождает expr в круглых скобках

```
factor
   |
   v
  expr    ИЛИ     factor
                    |
                    v
                 ( expr )
```

### задача 3
---

statement -> if ( expr ) statement    // описывает синтаксис конструкции, НЕ поведение или алгоритм условного ветвления
statement -> if ( expr ) statement  // синтаксически допустимая конструкция, где expr - нетерминал, statement - нетерминал
что происходит при ложности (expr) ?  - ответ на этот вопрос не является задачей грамматики

обработка условия if и решение о ветвлении - вопрос семантики
> КСГ описывает синтаксис, КСГ не описывает семантику

семантика обрабатывается компилятором/интерпретатором/транслятором после успешного синтаксического анализа

```java
import CalcParser.Expression;
import CalcParser.Parser;
import org.codehaus.groovy.ast.expr.BinaryExpression;

import java.util.Optional;

public static void main(String[] args) {
    Optional<Expression> expr = Optional.of(new BinaryExpression(new NumValue(1.0), Parser.Operation.ADD, new NumValue(2.0)));
    if (expr.isPresent()) {
        System.out.println("значение выражения = " + expr.get().evaluate());
    } else {
        System.out.println("выражение отсутствует");
    }
}
```

statement порождает statement при условии что выражение expr в круглых скобках истинно


```
        statement
            |
            v
         if (expr) -> statement
```


# контекстно-свободная грамматика - КСГ - арифметических и булевых операций

ксг - формальный аппарат описания синтаксиса языка с помощью правил вида `A -> aльфа`
правило `A -> aльфа` означает 
А порождает альфа, где А - нетерминал, альфа - любая цепочка из терминалов/нетерминалов, включая:
- терминальная цепочка: Т
- нетерминальная цепочка: E
- смешанная цепочка: E + T
- эпсилон - пустая цепочка

создание описания синтаксиса языка <-> построение КС-грамматики языка
- то есть, создание множества формальных правил A -> альфа, порождающих корректные синтаксические конструкции языка
- для арифметических операций - это построение КС-грамматики арифметических выражений
- для булевых - построение КС-грамматики булевых выражений

## Арифметические операции
язык следующих арифметических выражений:
- целочисленные константы
  - синтаксически является валидным выражением согласно правилу порождения F -> number
  - семантически является валидным выражением, так как может быть оценена к значению (свойство выражений)
  - возможное обозначение - атом или атомарное выражение
- скобки
- операции (+, *, -, /)

множество терминалов:
{0,1,2,3,4,5,6,7,8,9,+,−,∗,/,(,)}

число: d1 (d1 | ... | d9)* , di принадлежит {0, 1, ... 9}, d1 != 0 

множество нетерминалов: 
```
{  
  E - add_expr     // выражение - выражение сложения/вычитания
  T - mul_expr     // терм - выражение умножения/деления
  F - factor       // фактор - или выражение в скобках, или рекурсивное выражение в скобках, или число
}
```

ксг

```
E -> E + T | E - T | T    // выражение сложения/вычитания порождает или сложение нетерминалов E + T, или вычитание нетерминалов E - T, или нетерминал T
T -> T * F | T / F | F    // выражение умножения/деления порождает или произведение нетерминалов T * F, или частное нетерминалов T / F, или нетерминал F
F -> (E) | number         // нетерминал F порождает нетерминал выражение сложения/вычитания в скобках или терминал - число
```

~ebnf
```
add_expr ::= add_expr '+' mul_expr | add_expr '-' mul_expr | mul_expr
mul_expr ::= mul_expr '*' factor | mul_expr '/' factor | factor
factor ::= '(' add_expr ')' | number
number ::= '0' | [1-9][0-9]*
```

## Булевы операции
язык булевых выражений

множество терминалов
- константы: true, false
- операторы: not, and, or
- группировка: (, )

множество нетерминалов
B - булево выражение - стартовый символ
C - and - конъюнкция
D - or  - дизъюнкция
N - not - отрицание

ксг
```
B -> D                            // выражение порождает дизъюнкцию
D -> D or C | C                   // D порождает или выражение дизъюнкции между D и C, или C
C -> C and N | N                  // C порождает или выражение конъюнкции между С и N, или N 
N -> not N | (B) | true | false   // отрицание порождает или отрицание рекурсивно, или выражение в скобках, или терминал true, или терминал false
```



порядок правил определяет приоритет операций: not - наивысший, ниже - and, ниже - or
грамматика является левоассоциативной - выражения разрешаются слева направо

~ebnf
```
bool_expr ::= dis_expr
dis_expr ::= dis_expr 'or' con_expr | con_expr
con_expr ::= con_expr 'and' neg_expr | neg_expr
neg_expr ::= 'not' neg_expr | '(' bool_expr ')' | true | false
```

#### пример разбора выражения
`not true and false or true`

ожидаемый порядок:
not true -> false          // neg_expr - отрицание, остается `and false or true`
false and false -> false   // con_expr - конъюнкция, остается `or true`
false or true -> true      // dis_expr - дизъюнкция

```
                          bool_expr
                             |
                          dis_expr
                         /         \                                           
                  dis_expr       'or'     // применение dis_expr: not false or true -> true
                  /       \
          con_expr      'and'            // применение con_expr: false and false -> false
         /       \          
   neg_expr     'not'                      // применение neg_expr: not true -> false
       |          
    'true'                                  // терминал true
```


---

> Проблема! Левая рекурсия - D -> D or C - функция, реализующая парсинг выражения D, будет вызывать себя бесконечно - до переполнения стека
> то же в C -> C and N | N
> not N | (B) | true | false

---

Левая рекурсия в КС-грамматике - ситуация, при которой нетерминал порождает себя в левой позиции

Левая рекурсия в общем виде:
A -> A альфа | бета
где А - нетерминал, альфа - любая цепочка символов (строка), бета - нетривиальная цепочка (т.е. не эпсилон)

> цепочка (string) - это последовательность символов, определенных алфавитом анализируемого языка
> например, для двоичных чисел определены символы 0 и 1, тогда цепочкой символов будет любая последовательность 0 и 1: `101010`

`A -> A альфа | бета`
заменяется правилами
```
A -> бета A'
A' -> альфа A' | эпсилон
```

> на этом вопросе задерживаюсь, потому что для меня неочевидно тождество заменяемых и замещающих правил
> рассмотрю подробнее

заменяемое правило: 
`A -> A альфа | бета`

заменяющее правило
```
A -> бета A'
A' -> альфа A' | эпсилон
```

задача - устранить левую рекурсию, выполнив формальное преобразование и сохранив эквивалентность языка, 
порожденного грамматиками до и после замены

##### понимание исходного правила
`A -> A альфа | бета` - А может быть заменено или на `А альфа`, или на `бета`; альфа и бета - терминалы, бета - нетривиальный
`| бета` означает, что финальным порождением будет цепочка бета, т.е., результат будет начинаться с цепочки бета
пример
A -> Ax | y

A =>* yx^n , n>=0  // для нуля или более шагов вывода будет получена цепочка из `y` и n раз `x`
при n=3 порождается строка `yxxx`
A =>      // применяется А -> A x, A заменен на A x
A x =>      // применяется А -> A x, A заменен на A x
A x x =>      // применяется А -> A x, A заменен на A x
A x x x =>      // применяется А -> y, A заменен на y
y x x x     // 
возможно применить правило А -> y на любом шаге, если правило содержит A
если так, то почему левая рекурсия - проблема?

проблема левой рекурсии не в синтаксисе - нарушения синтаксиса нет, 
проблема в автоматическом анализе синтаксиса с левой рекурсией
парсер применяет правило, которое соответствует считанному символу
  - если этот символ - нетерминал из левой части правила - происходит зацикливание

##### LL-парсер
синтаксический анализатор, который
- считывают слева направо - первая L в названии
- выполняет левый - первый указанный по грамматике - вывод - вторя L в названии
- считывает по одному символу, проверяет 1 символ, следующий далее - поэтому называется еще LL(1)-парсер
- использует стек для хранения ожидаемых вызовов
- обходит сверху вниз - от корня к листьям

работа LL-парсера на примере
дана грамматика
```                     
S -> E
E -> E + T | T  
T -> 1 | 2       
```                     
на стеке находится стартовый символ `S`
на вход парсеру передается цепочка `1 + 2`

правило E -> E + T : любое выражение Е можно заменить выражением Е + Т
правило E -> T : любое выражение Е можно заменить выражением Т
правило T -> 1 | 2 : любое выражение T можно заменить или терминалом 1, или терминалом 2

шаг 0
событие: входные значения 
действие: -
на стеке: S
выражение: 1 + 2

> выполняется разрешение правил

шаг 1
событие: S -> E
действие: снятие со стека S, поиск правила - правило найдено - S заменяется на E, помещение Е на стек
на стеке: E
выражение: 1 + 2


шаг 2
событие: E -> E + T
действие: снятие со стека E, поиск правила - правило найдено - E заменяется на E + T, помещение E + T на стек
на стеке: E + T
выражение: 1 + 2


шаг 3
событие: E -> T
действие: снятие со стека E, поиск правила - правило найдено - E заменяется на T, помещение T на стек
на стеке: T + T
выражение: 1 + 2

> все правила разрешены до терминального правила

> обрабатывается ввод

шаг 4
событие: T -> 1
действие: снятие со стека T, считывание лексемы 1, проверка правила: T -> 1 | 2, т может перейти в 1, парсинг лексемы успешен, переход к следующей лексеме
на стеке: + T
выражение: + 2


шаг 5
событие: +
действие: снятие со стека +, считывание лексемы +, оператор совпал с лексемой, успех, снятие со стека, переход к следующей лексеме
на стеке: T
выражение: 2


шаг 6
событие: T -> 2
действие: снятие со стека T, считывание лексемы 2, проверка правила: T -> 1 | 2, т может перейти в 2, парсинг лексемы успешен, переход к следующей лексеме
на стеке: 
выражение:

анализ завершен

---

итого: задача - преобразовать леворекурсивное выражение так, чтобы алгоритм LL-парсера мог применить правила, не входя в бесконечную рекурсию

ксг - леворекурсивная
```
B -> D                            // выражение порождает дизъюнкцию
D -> D or C | C                   // D порождает или выражение дизъюнкции между D и C, или C
C -> C and N | N                  // C порождает или выражение конъюнкции между С и N, или N 
N -> not N | (B) | true | false   // отрицание порождает или отрицание рекурсивно, или выражение в скобках, или терминал true, или терминал false
```

заменяемое правило:
`D -> D or C | C`

заменяющее правило
```
D -> C D'
D' -> or C D' | e
```

заменяемое правило:
`C -> C and N | N`

заменяющее правило
```
C -> N C'
C' -> and N C' | e
```

заменяемое правило:
`N -> not N | (B) | true | false`

N должен порождать отрицание N, булево выражение в скобках, true, false  
отрицание N порождает отрицание любого выражения из {булево выражение в скобках, true, false}: not true, not false, not (not true), ... 

заменяющее правило
```
N -> (B) N' | true N' | false N'
N' -> not N' | e
```

ксг булева выражения - праворекурсивная
```
B -> D                          
D -> C D'
D' -> or C D' | e
C -> N C'
C' -> and N C' | e
N -> (B) N' | true N' | false N'
N' -> not N' | e 
```

#### рекурсивный спуск по булеву выражению
`not true and false or true`

разложение на лексемы
[not, true, and, false, or, true]

сопоставление лексем и грамматики

TODO