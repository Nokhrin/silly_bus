# Грамматики

#### Иерархия грамматик Хомского
иерархия классифицирует формальные грамматики по их синтаксической сложности

в порядке возрастания синтаксической сложности определены формальные грамматики:

- регулярная
  - уровень лексического анализатора / лексера

- контекстно-свободная
  - уровень синтаксического анализатора / парсера

- контекстно-зависимая
- свободная

---

## Контекстно-свободная грамматика
Система формальных правил описания языков программирования
Текст состоит из символов
Символы представлены терминалами и нетерминалами
КС грамматика Определяет правила взаимодействия символов, при котором не нарушаются синтаксические правила языка и сохраняется смысл конструкции
Пример - проверка исходного кода программы статическим (синтаксическим) анализатором - линтером


### Составляющие

#### терминалы
- элементы, которые не могут быть далее раскрыты/представлены цепочкой иных операций и/или терминалов,
  - соответствующие синтаксическим правилам языка: ключевые слова, операторы, переменные
- пример для банковских операций: `deposit`, ` `, `123.45`, `7317ba2f-9145-4f31-9efe-5b4919b2b027`

#### нетерминалы
- элементы, которые могут быть представлены последовательностью других элементов в результате продукции
- представляют синтаксические категории: утверждения, выражения
- правила - метапонятия - описания над конкретными значениями

---
понимание терминал/нетерминал

- `<action>` - это нетерминал, это правило, которое ожидает действие, но это не само действие
  - `"deposit"` - терминал, конкретное действие, реализация правила
- `<amount>` - это нетерминал, это правило, которое ожидает сумму, но это не само число
  - `100` - терминал, число, реализация amount




---


#### начальный символ | стартовый символ | start symbol
- нетерминал, от которого начинается применение продукционных правил
- обозначается `S`

#### продукция | правила вывода | продукционные правила | production rules
применение вне КС-грамматики ограничено, так как не дает формальной строгости
дает наглядность, читаемость, "понимаемость на глаз" - для быстрого проектирования черновика системы норм
форма представления знания в формате импликации (если-то): условие-действие
не учитывает содержание суждение, только формальную логическую зависимость
> ЕСЛИ запрошена операция снятия И сумма не превышает баланс, ТО выполнить снятие
> ЕСЛИ найдена строка `withdraw 100`, ТО вызвать статический метод Withdraw.perform(100)
> ЕСЛИ в коде есть "{" без "}", ТО - ошибка синтаксиса

derivation - вывод - результат применения правил
применение правила обозначается `A -> α`, A - нетерминал, α - цепочка терминалов и/или нетерминалов


---

#### BNF
Backus-Naur Form ≡ BNF ≡ форма Бэкуса-Наура ≡ нормальная форма Бэкуса-Наура
- формальная система описания ≡ нотация ≡ метаязык
- применяется для описания синтаксиса искусственных языков - грамматики, элементов, атрибутов
  - ЯП,
  - данных,
  - протоколов

- основные элементы
  - терминал - символ - "" (указывается в кавычках, пример: `"+"`)
    - позиция в грамматической конструкции, которую невозможно заменить/упростить, конечное/терминальное описание
  - нетерминал - правило - в скобках <> - пример: `<expr>`
    - позиция в грамматической конструкции, которую можно заменить упрощенной конструкцией
  - определение - выражается знаком `::=`
    - пример: `<expr> ::= <term>` - выражение определяется как терминал - этому описанию соответствуют нетерминалы число, арифметическое выражение (42, 2*2)
      - `2*2` - умножение - символ-оператор, это нетерминал, так же как и числа 2
      - `2*2` нельзя упростить, это терминал, * - часть терминала в данном контексте
    - пример: `<expr> ::= <term> | <expr> "+" <term>`
  - группировка
- принцип
  - последовательное определение одних синтаксических категорий через другие
  - или, как построить сложную конструкцию из простых, декомпозировать

- задача - описать допустимые конструкции и допустимый порядок следования конструкций
- примение: с помощью BNF описаны C, Java, SQL, JSON, XML
- бнф-конструкция определяет конечное число символов
- бнф-конструкция определяет правила замены символа на последовательность символов
- по бнф-описанию языка можно построить парсер этого языка
- по бнф-описанию языка можно построить компилятор компиляторов - алгоритм, создающий компилятор языка по синтаксическому или семантическому описанию этого языка
- BNF дополнена в системах EBNF и ABNF

---

понимание - bnf описание грамматики арифметического выражения

S - стартовый символ, начальный нетерминал
E, T, F - нетерминалы - названия **синтаксических конструкций**
+, *, a, b, 0, 1, (, ) - терминалы - **конкретные символы**

```
1/ S -> E
2/ E -> E + T | T
3/ T -> T * F | F
4/ F -> ( E ) | a | b | 0 | 1
```
1, 2, 3, 4 - не последовательность действий! не шаги
это 4 правила, которые соблюдаются для описываемого выражения

1 - 4 идут от общего к частному, 
в обратном порядке от 4 к 1 - прослеживается "наращивание выражения"

`F -> ( E ) | a | b | 0 | 1`
- F есть базовое выражение | база, это либо выражение в скобках, либо переменная а или b, либо число 0 или 1

`T -> T * F | F`
- нетерминал либо раскладывается на умножение нетерминала и базы, либо преобразуется в базовое выражение
- T - это выражение, которое может содержать умножение
- F - элемент, который невозможно разложить - переменная, число
- T может быть выражением, умноженным на базу, либо T может быть базой

> a * b * 1
> умножение - левоассоциативно => a * b * 1 = (a * b) * 1
> по правилу T * F, то есть слева от умножения идет выражение,
> группировка a * (b * 1) этому не соответствует, поэтому рассматриваем (a * b) * 1
> по правилу T * F, то есть справа от умножения идет база,
>  в группировке a * (b * 1) справа `(b * 1)`, что не является базой, так как содержит умножение

E -> E + T | T
- нетерминал либо раскладывается на сложение нетерминала и терминала, либо преобразуется в другой нетерминал

S -> E
- любая строка описываемой грамматики начинается с S
- первый шаг всегда - замена S на E - замена стартового символа на нетерминал
- то есть, любое выражение начинается с нетерминала



---


---
## Описание синтаксических правил

BNF - нормальная форма Бэкуса-Наура
- формальный способ определения правил контекстно-свободных грамматик
- 

правила для парсера определены в нотации EBNF

### EBNF
- расширенная нормальная форма Бэкуса-Наура

пример
```
add_sub_expression ::= mul_div_expression { [ws] add_sub_operation [ws] mul_div_expression }
mul_div_expression ::= atom_expression { [ws] mul_div_operation [ws] atom_expression }
atom_expression ::= num_value | '(' [ws] add_sub_expression [ws] ')'
mul_div_operation ::= "*" | "/"
add_sub_operation ::= "+" | "-"
num_value ::= [sign] digit {digit}
digit ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
sign ::= "+" | "-"
ws ::= (" " | "\t" | "\n" | "\r") {" " | "\t" | "\n" | "\r"}
```

### BNF - классическая, без расширений
поддерживает операторы
`::=` - определение нетерминала
`|` - "или" - перечисление возможных значений
`<>` - угловые скобки заключают нетерминал
`""` - кавычки заключают терминал
- нет операторов количества: `[]`, `{}`

запись `num_value ::= digit {digit}` не имеет смысла в BNF
эквивалентная запись с применением рекурсии
- digits определяет сам себя по цифрам
- последняя цифра будет выходом из рекурсии:
```
num_value ::= digits
digits ::= digit | digit digits
digit ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
```

число со знаком определяется:
```
num_value ::= sign digits
digits ::= digit | digit digits
digit ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
sign ::= "+" | "-"
```
знак присутствует всегда


#### ABNF
- пополненная нормальная форма Бэкуса-Наура
- частое применение - описание протоколов передачи данных

применяет иные символы сокращений 
- `n*` повтор n и более раз
  - в частности, 0*digit == {digit}
- `/` разделитель альтернатив

правила парсера в ABNF
```
add_sub_expression   = mul_div_expression 1*( [ws] add_sub_operation [ws] mul_div_expression )
mul_div_expression   = atom_expression 1*( [ws] mul_div_operation [ws] atom_expression )
atom_expression      = num_value / "(" [ws] add_sub_expression [ws] ")"
mul_div_operation    = "*" / "/"
add_sub_operation    = "+" / "-"
num_value            = [sign] 1*digit
digit                = "0" / "1" / "2" / "3" / "4" / "5" / "6" / "7" / "8" / "9"
sign                 = "+" / "-"
ws                   = *( " " / "\t" / "\n" / "\r" )
```

### PEG
parsing expression grammar
нотация для описания синтаксиса языка, семантика отличается от BNF и ее расширений

терминалы PEG:
- символ - строка в кавычках: `"1", "-", "123", ")"`
- классы символов: `["0"-"9"]`
- любой символ: `.`

операторы:
`?` - 0 или 1 вхождение
`*` - 0 и более
`+` - 1 и более
`/` - последовательный выбор
`<-` - определение | сопоставление

число определяется как 0 или один sign, за которым следует 1 или более digit
```
num_value <- sign? digit+
digit     <- "0" / "1" / "2" / "3" / "4" / "5" / "6" / "7" / "8" / "9"
sign      <- "+" / "-"
```

выбор:
- сопоставление с приоритетом слева направо
  - `a <- b / c` - если b вернуло значение, c не проверяется - `if b then b else c` - с только если не b
  - `a <- b / c` неэквивалентно `a = c / b`
то же выражение в ebnf `a ::= b | c` эквивалентно `a ::= c | b` - логическое ИЛИ - или b, или c


пример для калькулятора
```
add_sub_expression  <- mul_div_expression 1*( [ws] add_sub_operation [ws] mul_div_expression )
mul_div_expression  <- atom_expression 1*( [ws] mul_div_operation [ws] atom_expression )
atom_expression     <- num_value / "(" [ws] add_sub_expression [ws] ")"
mul_div_operation   <- "*" / "/"
add_sub_operation   <- "+" / "-"
num_value           <- sign? digit+
digit               <- "0" / "1" / "2" / "3" / "4" / "5" / "6" / "7" / "8" / "9"
sign                <- "+" / "-"
ws                  <- (" " / "\t" / "\n" / "\r")*
```

#### ANTLR

операторы:
`?` - 0 или 1 вхождение
`*` - 0 и более
`+` - 1 и более
`|` - альтернатива
`()` - группировка
`:` - определение | сопоставление
`;` - конец определения
`''` - строки в одинарных кавычках
`[]` - классы символов
`..` - диапазоны

- семантически ближе к ЯП
- стилистически ближе к Java - из-за camel-case
- позволяет разделить направить считанные токены по каналам (channels)
  - например, заглушить пробельные символы напраляя их -> channel(HIDDEN) - искать лексемы, но скрыть результат
  - aналогия - перенаправление консольного вывода программы в /dev/null

пример для калькулятора
```
addSubExpression  : mulDivExpression ( (WS)? (ADD | SUB) (WS)? mulDivExpression );
mulDivExpression  : atomExpression ( (WS)? (MUL | DIV) (WS)? atomExpression );
atomExpression    : numValue | '(' (WS)? addSubExpression (WS)? ')';
MUL               : '*';
DIV               : '/';
ADD               : '+';
SUB               : '-';
numValue          : (SIGN)? DIGIT+;
DIGIT             : '0'..'9';
SIGN              : [+-];
WS                : [ \t\n\r] -> channel(HIDDEN);
```

---

TODO

### регулярные грамматики
> "регулярный" - от латинского "regularis" - "подчиненный правилу", "повторяющийся"
> повторяющаяся предсказуемая последовательность правил, не требующая памяти, в частности, стека
- регулярные грамматики являются строгим подмножеством КС-грамматик
- регулярная грамматика порождает регулярный язык
- регулярное выражение - формальное описание регулярного языка
- регулярный язык является конечным автоматом

кс-грамматика:
A -> α - нетерминал порождает цепочку символов, состоящую из терминалов и/или нетерминалов

регулярная грамматика:
в регулярной грамматике определены только три порождения
- нетерминала в терминал и нетерминал: `A -> αB`
- нетерминала в терминал: `A -> a`
- нетерминала в пустую цепочку: `A -> ε`


по определению формальной грамматики - G = (N, T, P, S) - для существования грамматики требуются все 4 элемента
где
N - множество нетерминалов
T - множество терминалов
P - множество правил (продукций)
S - стартовый символ

регулярное правило:
> `S` - стартовый нетерминал - точка входа грамматического правила
- несет грамматическую нагрузку как указать начала цепочки, не несет смысловой нагрузки в плане содержания

```
S -> aA  // цепочка начинается с нетерминала и терминала
A -> bB  // нетерминал A порождает терминал а и нетерминал B
B -> c   // нетерминал B порождает терминал c
c -> e   // терминал c порождает пустую цепочку
```
регулярный язык, порожденный регулярным правилом - подстановка по правилу:
`S -> aA -> abB -> abc -> e`


### отличие рекурсивных грамматик от регулярных выражений
- рекурсивная грамматика - формальная грамматика, способная описать язык, не являющийся регулярным
  - т.е. рекурсивная грамматика охватывает больше возможных сочетаний символов
- рекурсивность - свойство правил грамматики
- контекстно-свободность - свойство грамматик
- регулярные выражения поддерживают линейную рекурсию:
  - левая рекурсия в РГ: A -> aA
  - правая рекурсия в РГ: A -> Aa

однако - A -> aAb - не работает
потому что требуется считать количество a и количество b
то есть хранить состояние
регулярная грамматика - конечный автомат - не имеет памяти

> решить на сколько возможно регулярной грамматикой (регулярными выражениями)
> корректно сбалансированное скобочное выражение - т.е. для каждой открывающей скобки есть парная закрывающая

по аналогии - скобочное выражение 
если a = (, b = )
- возможность описания регулярным выражением 
невозможно, потому что нужен счет, неподдерживаемый КА, например, записывать в стек встреченные скобки
```
((3 + 2) * (4 - 1))
Количество вхождений (: 3   
Количество вхождений ): 3
```

- ограничения при описании регулярным выражением


---

### Рекурсивный спуск - РС - recursive descent
метод синтаксического анализа
в РС для каждого нетерминала определена функция, реализующая разбор конструкций, порожденных этим нетерминалом
нетерминал - функция, разбирающая подпоследовательность
нетерминал может содержать другие нетерминалы - то есть быть функцией, вызывающей другие функции, 
в том числе, саму себя, что есть рекурсия

РС проверяет одно и только одно правило для выражения, определенное в функции согласно грамматике


Для возможности РС требуется отсутствие левой рекурсии

левая рекурсия: A -> Aa
> Нетерминал А порождает последовательность нетерминала А, за которым следует терминал а
> A - в `Aa` - вызывается? в первую очередь => бесконечный цикл


пример левой рекурсии:

дано порождающее правило
`expr -> term | expr + term` - expr порождает term или expr порождает expr плюс term

```
expr
  |
  v
term  ИЛИ  expr
            |
            v
       expr + term
```


expr - нетерминал, term - терминал

в правой части - `expr + term` - слева та же функция, что в левой части - `expr`

преобразование приводит к циклическому вызову: `expr` -> `expr` -> `expr` -> `expr` -> `expr` -> ... -> StackOverflow

необходимо преобразование левой рекурсии к правой рекурсии
expr -> term | expr + term  =  A -> a | A b
замена
`A` -> `A' b`  // A' - не есть A, рекурсия устранена

`A'` -> `+ a A' | e`  // правая рекурсия - A' - в `+ a A'` -  вызывается в конце

e - пустая цепочка - условие, при котором не будет вызвана функция, то есть остановка возможной рекурсии

> A' - всегда присутствует в правой части, а значит -  всегда вызывается,  как может быть остановка?

A' - есть правило, НЕ функция
e - правило - не конкретное пустое значение
применяется одно из правил
если применено e, то происходит возврат к предыдущему вызову на стеке

#### пример

дано правило операции сложения целых чисел в контекстно-свободной грамматике - в нотации eBNF

```
expr ::= term | expr [ws] + [ws] term
term ::= [sign] num_value
num_value ::= digit {digit}
digit ::= "0" | "1" | ... | "9"
ws ::= " "
```

символ является терминалом, если определен в грамматике
если символ в грамматике не определен, то терминалом не является, но продолжает оставаться символом
терминал - символ, который не может быть заменен нетерминалом грамматики

в грамматике-примере: 
` ` - символ, определяющий терминал `ws`
`1`..`9` - символы, определяющие терминал `digit`

дано выражение `1 + 2`, где `1`, ` `, `+`, ` `, `2` - терминалы - символы
` ` - разделитель - элемент множества пробельных символов - в примере - пробел
`+` - оператор - знак операции
`1`, `2` - операнды - значения - в общем случае - выражения, над которыми выполняется операция


например: 
преобразование `A -> Aa` содержит нетерминал `A` и терминал `a`



дан метод parseExpr - функция разбора выражения `expr`

parseTerm

читаю выражение
parseExpr(`1 + 2`)
символ `1` - соответствует правилу term
  вызываю parseTerm(`1`)
  пропускаю пробел
  читаю `+` - правило expr
  вызываю parseExpr(`+`)
    пропускаю пробел
    читаю `2` - правило term
    вызываю parseTerm(`2`)





---

### восходящие анализаторы