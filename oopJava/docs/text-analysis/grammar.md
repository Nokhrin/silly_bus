# Грамматики

## Иерархия грамматик Хомского
иерархия классифицирует формальные грамматики по их синтаксической сложности

в порядке возрастания синтаксической сложности определены формальные грамматики:

- регулярная
  - уровень лексического анализатора / лексера

- контекстно-свободная
  - уровень синтаксического анализатора / парсера

- контекстно-зависимая
- свободная

---

## Контекстно-свободная грамматика - КСГ
Система формальных правил описания языков программирования
Текст состоит из символов
Символы представлены терминалами и нетерминалами
КС грамматика определяет **правила** взаимодействия символов, 
при котором не нарушаются синтаксические правила языка
и сохраняется способность конструкции содержать смысл

смысл будет проверен на этапе **семантического** анализа

КС-грамматика валидирует **форму** выражения
КС-грамматика **НЕ** проверяет содержание - то есть не оценивает анализируемое значение
формально проверяет соответствие структуры выражения правилам грамматики

Пример - проверка исходного кода программы статическим (синтаксическим) анализатором - линтером


### Понятия КСГ

определение формальной грамматики
`G = (N, T, P, S)`
где
N - множество нетерминалов
T - множество терминалов
P - множество правил (продукций)
S - стартовый символ
- для существования КСГ необходимы все составляющие определения



#### S - стартовый символ
- указатель на правило, которое применяется первым

#### терминалы
- символы, которые входят в алфавит
- элементы, которые не могут быть далее раскрыты/представлены цепочкой иных операций и/или терминалов,
  - соответствующие синтаксическим правилам языка: ключевые слова, операторы, переменные
- пример для банковских операций: `deposit`, ` `, `123.45`, `7317ba2f-9145-4f31-9efe-5b4919b2b027`

#### нетерминалы
- элементы, которые могут быть представлены последовательностью других элементов в результате продукции
- представляют синтаксические категории: утверждения, выражения
- правила - метапонятия - описания над конкретными значениями

---
понимание терминал/нетерминал

- `<action>` - это нетерминал, это правило, которое ожидает действие, но это не само действие
  - `"deposit"` - терминал, конкретное действие, реализация правила
- `<amount>` - это нетерминал, это правило, которое ожидает сумму, но это не само число
  - `100` - терминал, число, реализация amount

---


#### начальный символ | стартовый символ | start symbol
- нетерминал, от которого начинается применение продукционных правил
- обозначается `S`

#### продукция | правила вывода | продукционные правила | production rules
применение вне КС-грамматики ограничено, так как не дает формальной строгости
дает наглядность, читаемость, "понимаемость на глаз" - для быстрого проектирования черновика системы норм
форма представления знания в формате импликации (если-то): условие-действие
не учитывает содержание суждение, только формальную логическую зависимость
> ЕСЛИ запрошена операция снятия И сумма не превышает баланс, ТО выполнить снятие
> ЕСЛИ найдена строка `withdraw 100`, ТО вызвать статический метод Withdraw.perform(100)
> ЕСЛИ в коде есть "{" без "}", ТО - ошибка синтаксиса

derivation - вывод - результат применения правил
применение правила обозначается `A -> α`, A - нетерминал, α - цепочка терминалов и/или нетерминалов


- [грамматика арифметического выражения](../../src/main/java/CalcParser/docs/arithmetic_grammar.md)
- [грамматика булева выражения](../../src/main/java/CalcParser/docs/arithmetic_grammar.md)

---

## регулярные грамматики
> "регулярный" - от латинского "regularis" - "подчиненный правилу", "повторяющийся"
> повторяющаяся предсказуемая последовательность правил, не требующая памяти, в частности, стека
- регулярные грамматики являются строгим подмножеством КС-грамматик
- регулярная грамматика порождает регулярный язык
- регулярное выражение - формальное описание регулярного языка
- регулярный язык является конечным автоматом

кс-грамматика:
A -> α - нетерминал порождает цепочку символов, состоящую из терминалов и/или нетерминалов

регулярная грамматика:
в регулярной грамматике определены только три порождения
- нетерминала в терминал и нетерминал: `A -> αB`
- нетерминала в терминал: `A -> a`
- нетерминала в пустую цепочку: `A -> ε`


регулярное правило:
> `S` - стартовый нетерминал - точка входа грамматического правила
- несет грамматическую нагрузку как указать начала цепочки, не несет смысловой нагрузки в плане содержания

```
S -> aA  // цепочка начинается с нетерминала и терминала
A -> bB  // нетерминал A порождает терминал а и нетерминал B
B -> c   // нетерминал B порождает терминал c
c -> e   // терминал c порождает пустую цепочку
```
регулярный язык, порожденный регулярным правилом - подстановка по правилу:
`S -> aA -> abB -> abc -> e`


### отличие рекурсивных грамматик от регулярных выражений
- рекурсивная грамматика - формальная грамматика, способная описать язык, не являющийся регулярным
  - т.е. рекурсивная грамматика охватывает больше возможных сочетаний символов
- рекурсивность - свойство правил грамматики
- контекстно-свободность - свойство грамматик
- регулярные выражения поддерживают линейную рекурсию:
  - левая рекурсия в РГ: A -> aA
  - правая рекурсия в РГ: A -> Aa

однако - A -> aAb - не работает
потому что требуется считать количество a и количество b
то есть хранить состояние
регулярная грамматика - конечный автомат - не имеет памяти

> решить на сколько возможно регулярной грамматикой (регулярными выражениями)
> корректно сбалансированное скобочное выражение - т.е. для каждой открывающей скобки есть парная закрывающая

по аналогии - скобочное выражение 
если a = (, b = )
- возможность описания регулярным выражением 
невозможно, потому что нужен счет, неподдерживаемый КА, например, записывать в стек встреченные скобки
```
((3 + 2) * (4 - 1))
Количество вхождений (: 3   
Количество вхождений ): 3
```

- ограничения при описании регулярным выражением

TODO: рассмотреть понятие конечного автомата, после - вернуться к механике регулярных выражений

---


## Рекурсивные спусковые анализаторы
спусковые - потому что выполняют построение ast от корня к листам

реализации
- recursive descent - рекурсивный спуск
- LL(1) - левый-левый с просмотром +1 
- LL(k) - левый-левый с просмотром +1


### Рекурсивный спуск - РС - recursive descent
метод синтаксического анализа
в РС для каждого нетерминала определена функция, реализующая разбор конструкций, порожденных этим нетерминалом
нетерминал - функция, разбирающая подпоследовательность
нетерминал может содержать другие нетерминалы - то есть быть функцией, вызывающей другие функции, 
в том числе, саму себя, что есть рекурсия

РС проверяет одно и только одно правило для выражения, определенное в функции согласно грамматике


Для возможности РС требуется отсутствие левой рекурсии

левая рекурсия: A -> Aa
> Нетерминал А порождает последовательность нетерминала А, за которым следует терминал а
> A - в `Aa` - вызывается? в первую очередь => бесконечный цикл


пример левой рекурсии:

дано порождающее правило
`expr -> term | expr + term` - expr порождает term или expr порождает expr плюс term

```
expr
  |
  v
term  ИЛИ  expr
            |
            v
       expr + term
```


expr - нетерминал, term - терминал

в правой части - `expr + term` - слева та же функция, что в левой части - `expr`

преобразование приводит к циклическому вызову: `expr` -> `expr` -> `expr` -> `expr` -> `expr` -> ... -> StackOverflow

необходимо преобразование левой рекурсии к правой рекурсии
expr -> term | expr + term  =  A -> a | A b
замена
`A` -> `A' b`  // A' - не есть A, рекурсия устранена

`A'` -> `+ a A' | e`  // правая рекурсия - A' - в `+ a A'` -  вызывается в конце

e - пустая цепочка - условие, при котором не будет вызвана функция, то есть остановка возможной рекурсии

> A' - всегда присутствует в правой части, а значит -  всегда вызывается,  как может быть остановка?

A' - есть правило, НЕ функция
e - правило - не конкретное пустое значение
применяется одно из правил
если применено e, то происходит возврат к предыдущему вызову на стеке

---

## Восходящие анализаторы