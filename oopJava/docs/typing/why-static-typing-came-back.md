# Возвращение статической типизации

https://youtu.be/Tml94je2edk

## введение

автор разрабатывал на языках со статической типизацией
затем переключился на языки с динамической типизацией

автор отмечает тенденцию ЯП с динамической типизацией (ДТ) - реализовывать статическую типизацию (СТ)
проводит сравнительный анализ популярных ЯП в разрезе типизации

JavaScript, Python, PHP - ЯП с динамической типизацией
C++, Java, TypeScript - ЯП с динамической типизацией

TypeScript - реализация JavaScript с применением СТ
Некоторые ЯП с ДТ получили инструменты статической типизации
В Python для статической типизации применяется библиотека `mypy`

## вопрос доклада

Автор поставил задачу разобраться, почему ЯП с ДТ стали тяготеть к СТ
Для этого сформулировал вопросы:

- [мотивация популярности ЯП с ДТ](#мотивация-популярности-яп-с-дт)
- [перемены](#перемены)
- [влияние на будущее ЯП](#влияние-на-будущее-яп)

## мотивация популярности ЯП с ДТ

- первая половина 1990х
- JS, PHP, Python, Ruby, Lua

### преимущества и недостатки ЯП с ДТ и СТ

- актуальные сегодня ЯП - Perl, Python, JS и другие - были разработаны в первой половине 1990х
    - ЯП со СТ также разрабатывались в эти годы, но в меньшем количестве
- первая гипотеза о мотивации
    - появление графических веб-браузеров
    - появление интернет-бизнесов
    - инженерная предпосылка - появление задачи быстрой разработки в связи с интересом к веб как к новой технологии
    - экономическая предпосылка - появление задачи быстрой разработки веб-сайтов для интернет-бизнесов, повышение продаж
    - ИТОГ: применение ДТ вызвано задачей повышения скорости разработки
- за счет чего ЯП с ДТ повышают скорость разработки
    - нет этапов сборки
        - компиляции, в частности, как составляющей процесса сборки
    - "компактный" синтаксис
        - компактные выражения
            - выполняемые программы

```java
class Scratch {
    public static void main(String[] args) {
        System.out.println("hello");
    }
}
```

```python
print('hello')
```

- синтаксический сахар
    - техника вызова низкоуровневых или многословных операций с помощью методов, обладающих синтаксисом, сокращенным по
      сравнению с оригинальным
    - не изменяет поведение вызываемых операций
    - решает задачу повышения удобства при сохранении поведения
    - применяется как в ЯП независимо от типизации в ЯП, **не является доводом**

```java
class Scratch {
    public static void main(String[] args) {
        // Без сахара: итерация с помощью счетчика i
        int[] numbers = {1, 2, 3, 4, 5};
        for (int i = 0; i < numbers.length; i++) {
            System.out.println(numbers[i]);
        }

        // Синтаксический сахар: for-each
        // отличие для человека - не требуется объявлять и инкрементировать счетчик
        // отличие для машины - компилятор при генерации байт-кода преобразует цикл for-each в цикл со счетчиком
        int[] numbers = {1, 2, 3, 4, 5};
        for (int x : numbers) {
            System.out.println(x);
        }
    }
}
```

### реализация типизации

в Python

- объекты, классы которых реализуют метод `__eq__`, могут быть включены в список/list
- объекты, классы которых реализуют метод `__eq__` и `__hash__`, могут быть включены в set, dict

```python
# Без сахара - создание списка, добавление объектов в список
squares = []
for x in range(5):
    squares.append(x**2)

# Синтаксический сахар: списковое включение - форма записи цикла for
squares = [x**2 for x in range(5)]
```

- выполнение скомпилированного кода осуществляется быстрее интерпретируемого за счет выполненной ранее компиляции
    - не влияет на результат - время получения веб-страницы пользователем - в связи с низкой скоростью сетевого
      соединения
- больше возможностей сред разработки для ЯП со СТ
    - низкое влияние - среды разработки платные,
    - производительность машин, на которых разрабатывался софт, низкая, в связи с чем стат анализ кода, функции
      автодополнения, работаю медленно или отсутствуют
- отлов некоторых проблем на раннем этапе разработки
    - часть проверок выполняет компилятор
    - например, некорректный синтаксис (не поставил ; в конце строки), некорректное указание типов в методах (написал
      String[] arr = new int[];)

- технологии, развивавшиеся совместно с ЯП ДТ позволяли безвозмездную эксплуатацию
    - в числе технологий: Linux, Apache, MySQL

### Вывод

- языки с ДТ получили приоритет по экономическим соображениям

### рост популярности ЯП с СТ

- первая половина 2010х
- Kotlin, Rust, Go, Dart, TypeScript

## перемены

мнение автора о СТ 10 годами ранее:

- ЯП с СТ многословны
- автор считает СТ не такой уж полезной технологией
- автору не нравится процедура получения обратной связи от кода

### ЯП с СТ многословны

- приводит сравнение решения задачи формирования строки по условию
    - на JS (10 строк) и Java (50 строк)
        - пример спорный, так как на JS приведен один метод, на Java - полная реализация класса
        - потеря скорости разработки в Java - спорный аргумент,
          так как "шаблонный" код - геттеры, сеттеры, hash - может генерировать среда разработки
    - пример для версий языков начала 2010х
        - насколько я вижу, Java не требует столько служебного кода
        - например, реализация класса FinCalc.Account на Java и Python у меня занимает соразмерный объем
    - особо выделяет скорость разраб на фреймворке Rails (ЯП Ruby)
        - думаю, пример нарушает логику повествования, так как тема - языки, а не фреймворки
    - отмечает отличия современного JS от JS 2010 - увеличение строгости
        - const вместо var
        - const вместо function
    - отмечает отличия современного JS от TypeScript
        - в TypeScript явно указан тип объекта, принимаемого параметром функции
        - код на статически типизированном TypeScript несущественно многословнее кода на JS


- приводит довод в защиту многословного класса на Java
    - "шаблонный" код не отнимает много времени - его генерит среда разработки
    - на первый взгляд избыточный метод, описывающий структуру JSON, выполняет валидацию байтов JSON до передачи методу
      отрисовки
        - то есть в случае некорректного значения (например, структуры JSON), выполнение остановится раньше,
            - ошибку легче изолировать, легче найти корневую причину

- демонстрирует ЯП, который разрабатывает
    - язык интерпретируемый
    - интерпретатор определяет и проверяет тип переданного значения по контексту
        - на примере сериализации поля JSON, в котором записано имя пользователя
            - если передано `name`, интерпретатор проверяет, что переданное значение содержит `name`,
            - то есть интерпретатор проверяет тип объекта по его значению объекта

- вывод - статическая типизация не всегда приводит к многословности языка,
    - многословность - свойство языка,
    - многословность - НЕ свойство типизации

- оперирует понятием `Type inference`

### СТ - мало пользы

- приводит пример ошибок, происходивших при выполнении статически типизированного кода, в котором не было обнаружено
  ошибок на этапе компиляции
    - ошибка сегментации, повреждение памяти, исключение указателя на null
    - #ВОПРОС - является ли возникновение исключение доводом против статической типизации?

- при использовании стека JS+Ruby - ДТ
    - автор реализует проверку и анализ ошибок, связанных с исключениями null
- при использовании стека elm+Haskell - СТ
    - ошибки, связанные с исключениями null, не нуждаются в обработке, так как комплияторы elm и Haskell не выполнят
      компиляцию, если обнаружат возможность ошибок null
- подитог - СТ гарантировано исключает категорию ошибок на этапе разработки

- туманные сообщения об ошибках в некоторых случаях и ЯП СТ
    - отрицательный пример - ЯП СТ С++, ошибка, возникающая при отсутствии указателя - много текста, сложно найти
      причину
    - положительный пример - ЯП СТ elm - ясное сообщение об ошибке, однозначно указан объект, вызвавший ошибку
      компиляции

- долгий отзыв среды разработки
    - проблема - медленная работа ресурсоемких инструментов, как автодополнение и стат анализ

- вывод: Ни одно из этих свойств не является само собой разумеющимся
    - современные машины и среды разработки дают быстрый отзыв
    - существуют ЯП СТ, предоставляющие читаемую и применимую информацию об ошибках при проверке типов данных

- указанные проблемы не являются следствием вида типизации
    - среда разработки может лагать для ЯП ДТ
    - сообщения об ошибках могут быть лучше и точнее в любом ЯП

### СТ - длинная цепь обратной связи

- автору не нравится процедура получения обратной связи от кода
    - на примере:
        - Python поддерживает интерактивный режим, консоль REPL, в которой можно выполнить фрагмент кода и прикинуть,
          работает в целом или нет
        - контраргумент - в ЯП СТ надо сперва скопилировать, только потом узнаешь результат
            - в части Java довод неубедительный, Java содержит интерактивную консоль JShell
            - для проверки более крупных фрагментов кода интерактивная консоль не принесет ощутимой пользы ни для какого
              ЯП
- компиляция в настоящее время выполняется достаточно эффективно за счет применения параллелизма

- автор проводил опрос об отношении к TypeScript
    - вопрос тем, кто положительно отзывался о TypeScript
        - что именно в языке вам нравится?
        - ожидаемые ответы:
            - надежность скопилированной программы
            - скорость выполнения скопилированной программы
            - легче процесс отладки и поиска ошибки
            - читаемость кода
            - поддержка вспомогательных инструментов типизации в среде разработки
        - самый популярный ответ:
            - поддержка вспомогательных инструментов типизации в среде разработки - подчеркивание ошибки
            - подчеркивание ошибки - пример быстрой обратной связи, которой автору не хватало в ЯП ДТ
                - эмпирический довод в пользу СТ

## будущее СТ и ДТ в ЯП

- гипотетические сценарии:
    - преобладание СТ
    - преобладание ДТ
        - доводы, актуальные для первой половины 1990х, сейчас не работают
        - средства, предоставляемые ДТ, которые подчеркнул автор, сейчас предоставляются в СТ
    - гибридная типизация:
        - частичное аннотирование типов - например,
            - в классе 2 метода, в одном методе указаны типы параметров, во втором - не указаны, и это допустимо, код
              скомпилируется
            - типы проверяются только для тех объектов, для которых указаны типы, остальные объекты типизируются
              динамически
        - реализовано в TypeScript, применимо к Python при условии применения стат анализатора
        - решения в Python:
            - статическая проверка типов на этапе анализа кода
                - проверку выполняет самостоятельная программа, проверяемый код не выполняется, но анализируется
                  семантически
                - в основе статической проверки типов лежит семантический анализ
            - проверка типов во время выполнения (runtime type checking)
                - реализуется вставкой в байткод функций проверок аргументов и возвращаемых значений

### доводы за СТ

- ЯП СТ могу перенять и перенимают свойства ЯП ДТ, тогда как ЯП ДТ принципиально не могут перенять преимущества СТ без
  дополнительных инструментов, например, статических анализаторов кода
- накладные расходы во время выполнения кода с ДТ
- реализация статической типизации проще реализации гибридной типизации
    - дина

---

# Разбор комментариев

---
> 3 minutes in and somehow he managed to put a timeline of non statically typed languages from the 1950s on that doesn't
> have Lisp

комментарий обращает внимание на отсутствие ЯП Lisp в таймлайне языков без статической типизации
рассмотрим свойства типизации Lisp

- динамическая типизация
    - проверяется тип значения в момент выполнения
    - тип переменной определяется на этапе выполнения программы
    - тип переменной определяется по типу значения, которое записано в памяти по адресу, который сохраняется в
      переменной
- утиная типизация
    - при вызове метода, аргументом которого является объект X, проверяется наличие реализации в объекте X вызвавшего
      метода
        - если объект "знает что делать" для запрошенной инструкции - объект считается корректным значением
- полиморфизм
    - функция будет работать с типом, если она определена для этого типа
- возможность статической проверки
    - поддерживается указание типов в определениях функций и переменных
- иерархическая организация типов
    - от общего к частному
    - базовый (любой) <- числовой <- вещественный <- отношение целых чисел <- целые числа

типизация Lisp по свойствам аналогична типизации Python?

---

> I seriously thought, "It would be nice to throw type safety out the window and use a dynamic language for this
> project". On the contrary, very often I find myself thinking "it would be nice to have an even stronger language and
> type system for this project", but I often end up settling in a compromise middle-ground, such as C#

> in a ML setting, where you might have some 5000 parameters in your model, the last thing you want it to write those
> parameters (and their types) one by one by hand

комментарий говорит, что выбор типизации зависит

- от настроения разработчика
- от задачи проекта
- от количества и свойств параметров, требующих проверки типов

в качестве компромисса строгости типизации называется C#
рассмотрим свойства типизации C#


> So far, NO ONE, on any internet forum, or in any company that I worked for, ever, has given me a really compelling
> argument in favor of dynamic languages.

в практике автора не встречались программисты-профессионалы, являющиеся приверженцами ЯП с динамической типизацией

> The kind of runtime type fuckery "magic" that dynamic languages enable is exactly the kind of thing that you will want
> to keep AWAY from your production codebase as much as possible, because it's really hard to reason about, and
> practically impossible to debug.

автор высказывается против инструментов статической проверки типов, аргументы
- высокая сложность поиска реальной причины ошибки
- высокая сложность отладки ошибок, обнаруженных стат анализатором

---
