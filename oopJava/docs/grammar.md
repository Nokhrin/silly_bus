# Грамматики

#### Иерархия грамматик Хомского
иерархия классифицирует формальные грамматики по их синтаксической сложности

в порядке возрастания синтаксической сложности определены формальные грамматики:

- регулярная
  - уровень лексического анализатора / лексера

- контекстно-свободная
  - уровень синтаксического анализатора / парсера

- контекстно-зависимая
- свободная

---

## Контекстно-свободная грамматика
Система формальных правил описания языков программирования
Текст состоит из символов
Символы представлены терминалами и нетерминалами
КС грамматика Определяет правила взаимодействия символов, при котором не нарушаются синтаксические правила языка и сохраняется смысл конструкции
Пример - проверка исходного кода программы статическим (синтаксическим) анализатором - линтером


### Составляющие

#### терминалы
- элементы, которые не могут быть далее раскрыты/представлены цепочкой иных операций и/или терминалов,
  - соответствующие синтаксическим правилам языка: ключевые слова, операторы, переменные
- пример для банковских операций: `deposit`, ` `, `123.45`, `7317ba2f-9145-4f31-9efe-5b4919b2b027`

#### нетерминалы
- элементы, которые могут быть представлены последовательностью других элементов в результате продукции
- представляют синтаксические категории: утверждения, выражения
- правила - метапонятия - описания над конкретными значениями

---
понимание терминал/нетерминал

- `<action>` - это нетерминал, это правило, которое ожидает действие, но это не само действие
  - `"deposit"` - терминал, конкретное действие, реализация правила
- `<amount>` - это нетерминал, это правило, которое ожидает сумму, но это не само число
  - `100` - терминал, число, реализация amount




---


#### начальный символ | стартовый символ | start symbol
- нетерминал, от которого начинается применение продукционных правил
- обозначается `S`

#### продукция | правила вывода | продукционные правила | production rules
применение вне КС-грамматики ограничено, так как не дает формальной строгости
дает наглядность, читаемость, "понимаемость на глаз" - для быстрого проектирования черновика системы норм
форма представления знания в формате импликации (если-то): условие-действие
не учитывает содержание суждение, только формальную логическую зависимость
> ЕСЛИ запрошена операция снятия И сумма не превышает баланс, ТО выполнить снятие
> ЕСЛИ найдена строка `withdraw 100`, ТО вызвать статический метод Withdraw.perform(100)
> ЕСЛИ в коде есть "{" без "}", ТО — ошибка синтаксиса

derivation - вывод - результат применения правил
применение правила обозначается `A → α`, A - нетерминал, α - цепочка терминалов и/или нетерминалов


---

#### BNF
Backus-Naur Form ≡ BNF ≡ форма Бэкуса-Наура ≡ нормальная форма Бэкуса-Наура
- формальная система описания ≡ нотация ≡ метаязык
- применяется для описания синтаксиса искусственных языков - грамматики, элементов, атрибутов
  - ЯП,
  - данных,
  - протоколов

- основные элементы
  - терминал - символ - "" (указывается в кавычках, пример: `"+"`)
    - позиция в грамматической конструкции, которую невозможно заменить/упростить, конечное/терминальное описание
  - нетерминал - правило - в скобках <> - пример: `<expr>`
    - позиция в грамматической конструкции, которую можно заменить упрощенной конструкцией
  - определение - выражается знаком `::=`
    - пример: `<expr> ::= <term>` - выражение определяется как терминал - этому описанию соответствуют нетерминалы число, арифметическое выражение (42, 2*2)
      - `2*2` - умножение - символ-оператор, это нетерминал, так же как и числа 2
      - `2*2` нельзя упростить, это терминал, * - часть терминала в данном контексте
    - пример: `<expr> ::= <term> | <expr> "+" <term>`
  - группировка
- принцип
  - последовательное определение одних синтаксических категорий через другие
  - или, как построить сложную конструкцию из простых, декомпозировать

- задача - описать допустимые конструкции и допустимый порядок следования конструкций
- примение: с помощью BNF описаны C, Java, SQL, JSON, XML
- бнф-конструкция определяет конечное число символов
- бнф-конструкция определяет правила замены символа на последовательность символов
- по бнф-описанию языка можно построить парсер этого языка
- по бнф-описанию языка можно построить компилятор компиляторов - алгоритм, создающий компилятор языка по синтаксическому или семантическому описанию этого языка
- BNF дополнена в системах EBNF и ABNF

---

понимание - bnf описание грамматики арифметического выражения

S - стартовый символ, начальный нетерминал
E, T, F - нетерминалы - названия **синтаксических конструкций**
+, *, a, b, 0, 1, (, ) - терминалы - **конкретные символы**

```
1/ S → E
2/ E → E + T | T
3/ T → T * F | F
4/ F → ( E ) | a | b | 0 | 1
```
1, 2, 3, 4 - не последовательность действий! не шаги
это 4 правила, которые соблюдаются для описываемого выражения

1 - 4 идут от общего к частному, 
в обратном порядке от 4 к 1 - прослеживается "наращивание выражения"

`F → ( E ) | a | b | 0 | 1`
- F есть базовое выражение | база, это либо выражение в скобках, либо переменная а или b, либо число 0 или 1

`T → T * F | F`
- нетерминал либо раскладывается на умножение нетерминала и базы, либо преобразуется в базовое выражение
- T - это выражение, которое может содержать умножение
- F - элемент, который невозможно разложить - переменная, число
- T может быть выражением, умноженным на базу, либо T может быть базой

> a * b * 1
> умножение - левоассоциативно => a * b * 1 = (a * b) * 1
> по правилу T * F, то есть слева от умножения идет выражение,
> группировка a * (b * 1) этому не соответствует, поэтому рассматриваем (a * b) * 1
> по правилу T * F, то есть справа от умножения идет база,
>  в группировке a * (b * 1) справа `(b * 1)`, что не является базой, так как содержит умножение

E → E + T | T
- нетерминал либо раскладывается на сложение нетерминала и терминала, либо преобразуется в другой нетерминал

S → E
- любая строка описываемой грамматики начинается с S
- первый шаг всегда - замена S на E - замена стартового символа на нетерминал
- то есть, любое выражение начинается с нетерминала



---

> дана команда снятия 100 ед
withdraw 100
withdraw - терминал, конкретная команда, заменить другим правилом невозможно
100 - терминал, конкретное число

bnf-описание

---


#### EBNF
- расширенная нормальная форма Бэкуса-Наура

#### ABNF
- пополненная нормальная форма Бэкуса-Наура
- метасинтаксис для представления контекстно-свободных грамматик
- формальный способ описания формальных языков
- частое применение - описание протоколов IETF

#### peg
#### antlr
#### отличие рекурсивных грамматик от регулярных выражений


---


Требования
> описать грамматику EBNF
> методы статические
> Принимают указатель на позицию в исходнике
> Возвращал опциональной результат - Optional<>

> пример для текущей задачи со счетами и деньгами

---
#### рекурсивный спуск
- алгоритм чтения и проверки лексем в тексте - в частности, распознавания команд в тексте исходного кода

---

[код - лексер](/src/main/java/FinOps/FinLexer.java)