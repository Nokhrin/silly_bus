# Полиморфизм  
  
## Аксиоматическое определение | Что это?  
Свойство системы программирования  
предоставлять алгоритм выполнения операций над объектами
на основе типа реализации объекта

  
## Прагматическое определение | Зачем? | Чем это может быть полезно?  
множество реализаций -> одна сигнатура
контроль соблюдения требований к состоянию и поведению

### снизить цикломатическую сложность задачи `определить тип объекта -> определить метод объекта`  
O(N) -> O(1), где N - количество типов

#### пример
площадь получаю методом getSquare для **любой фигуры (типа объекта - именно, поддтипа Shape)**  
выбор реализации по фактическому типу объекта - в runtime  
[Полиморфизм](../../concepts/src/main/java/org/example/polymorphism/shapes/AreasManagerPoly.java)

#### контрпример
площадь получаю определением типа фигуры, по типу фигуры выбираю метод расчета площади  
статический выбор реализации в compile  
[НеПолиморфизм](../../concepts/src/main/java/org/example/polymorphism/shapes/AreasManagerNoPoly.java)


### уменьшение количества строк кода: +1 тип -> +1 класс, вместо +N точек вызова, которые нужно исправить

#### пример
Задача - выбор сериализатора
для добавления сериализации нового формата создаю **новый класс**, не трогаю существующие *.class  
[Динамический выбор / Полиморфизм](../../concepts/src/main/java/org/example/polymorphism/serializables/SerializableDynamic.java)

#### контрпример
для добавления сериализации нового формата создаю меняю **существующий класс**, необходимо перекомпилировать систему  
[Статический выбор / НеПолиморфизм](../../concepts/src/main/java/org/example/polymorphism/serializables/SerializableStatic.java)


### не перекомпилировать существующие бинарники
### перемещение ошибок из runtime в compile за счет проверки подтипов

  
## Выигрыш  
- контроль поведения объекта в одном классе / интерфейсе  

- избежать модификации существующего кода класса/метода при изменении логики (старое не меняем)  
- новый код расширяет существующий класс/тип (добавляем интерфейс)  
  
## Проигрыш  
  
  
# Связь с ООП сущностями  
  
## abstraction  
полиморфизм гарантирует соблюдение контракта

| уровень <br/>абстрагирования | абстракция            | абстрагируемые понятия и свойства               | реализация в java        |
|------------------------------|-----------------------|-------------------------------------------------|--------------------------|
| 0                            | физический мир        | все возможные объекты и их поведения            | -                        |
| 1                            | структура модели      | свойства, необходимые и достаточные для задачи  | class V record           |           
| 2                            | контракт U требования | поведения, необходимые и достаточные для задачи | interface                |
| 3                            | объект в коде         | конкретная реализация контракта                 | Circle(), Square()       |
| 4                            | вызов                 | полиморфное обращение к базовому типу           | IShapeCalculator shape_1 |

полиморфизм применим в пределах созданной абстракции - предусмотрено то, что явно описано, т.е. контракт  
Добавление требования (абстракция требования - метода интерфейса)
  

### пример
[площадь фигур](../../concepts/src/main/java/org/example/polymorphism/shapes/ShapeMain.java)  
в задаче имеют значения величины, необходимые для расчета площади  
не имеют значения => не включаются в модель/класс: тип линии, размер точки, координаты центра фигуры  
  
api-контракт: для получения площади фигуры типа Квадрат передай длину стороны  
пользователь: дан квадрат со стороной 5, верни площадь этого квадрата  
api-контракт: площадь квадрата со стороной 5  
  
пользователя интересует результат - площадь фигуры;   
пользователя не интересует прочее, например, методика определения типа и выполнения расчета  
  

### контрпример - нарушение абстракции
нарушение в том, что клиент ожидает расчета периметра для любой фигуры
[интерфейс не предоставляет расчет периметра](../../concepts/src/main/java/org/example/polymorphism/shapes/IShapeCalculator.java)
реализация квадрата предоставляет

клиентский код содержит указание на подтип (Square), тогда как по идее полиморфизма достаточно базового типа для согласования типов
[площадь фигур](../../concepts/src/main/java/org/example/polymorphism/shapes/ShapeMain.java)

вопрос: должен ли периметр быть в интерфейсе/контракте?
ответ: зависит от требований / постановки задачи - абстрагирование включает в абстракцию необходимые и достаточные для решения задачи элементы структуры и поведения сущности

  
---  
  
## OCP  
  
### Аксиоматическое определение | Что это?  
Обеспечение свойства модели добавить функциональность без внесения изменений в существующую реализацию  
  
  
### Прагматическое определение | Зачем? | Чем это может быть полезно?  
 

Скомпилированные файлы не должны требовать замены  
Расширение - буквально - добавление нового файла `*.class` (в нем новый функционал | расширение), который применяется существующими `*.class`  
Одним из способов реализации OCP является полиморфизм
  
  
### рассуждения  
есть система управления банковскими операциями  
существует `BankOperationOCP.class`  
пользователь, чья задача -   
получение на вход последовательности операций,  
последовательная обработка операций по FIFO,  
валидация операции,  
при успехе валидации - выполнение операции  
при провале валидации - отклонение операции  
  
существует ``  
  
если принять за истину `Скомпилированные файлы не должны требовать замены`  
> как старый и новый байт код работают вместе ?

  
Расширение функционала - в новом java файле?  
Добавление метода в существующий интерфейс изменит исходный код и потребует перекомпиляции - это нарушение OCP?  
  
Есть сущность A, представленная в коде  
Для сущности написана логика  
oopJava/concepts/src/main/java/org/example/polymorphism/payments/AccountOCP_1.java  
  
Сущность применяется во внешнем коде  
  
  
Код, содержащий повторяющиеся блоки код  
  
полиморфизм - инструмент соблюдения принципа открытости/закрытости (open/closed principle | ocp)  
  
  
  
---  
  
## Решение о применении  
- раз в неделю добавляется подтип  
- стабильность и удобство приоритетнее производительности  
  
- один новый подтип добавляется 1 раз в год  
- критичны расходы (микросекунды) на динамическую диспетчеризацию  
  
  
  
---  

# Задача
моделировать ООП

изучить термин лямбда функции - нужно базовое понимание, детское, что лямбда это переменная - указатель на метод/функцию

привести рабочий пример работы с лямбдами как с переменными

должно быть

а) определение переменных
б) запись в переменную
в) чтение из переменной - с целью выполнить метод
г) передача переменных в метод через стек
д) получение переменных / значений в результате вызова метода

тут речь (а,б,в,г,д) о переменных которые содержат лямбды