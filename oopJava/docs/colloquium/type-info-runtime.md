статическая и строгая типизации

статическая / динамическая - на каком этапе проверяются типы? -
статическая - до выполнения программы
динамическая - во время выполнения

строгая - обеспечивающая типовую безопасность
гарантия , что программа не выполнит операции над данными, недопустимые для типов этих данных

строгий яп эквивалентно типобезопасный яп


java - статический, типобезопасный
python - динамический, типобезопасный
c - статический, опасный
,js - динамический, опасный

сильная/слабая - корректно - наличие/отсутствие типобезопасности


Если используется статическая типизация, то нужно ли хранить информацию о типе в run time, и почему

с точки зрения теории типов

если яп поддерживает
динамическое связывание - необходим фактический адрес объекта для выбора исполняемого метода
проверяемое приведение типов - необходимо описание иерархии наследования
рефлексию - требуется сигнатура методов, параметров, аннотаций

статическая типизация исключает некоторые ошибки - например, использование несуществующих или несовместимых типов, но не может исключить ошибки характерные для выполнения - д намические явления - полиморфизм, приведение

информация о типах нужна в runtime



в java строгая типизация, поэтому вопрос перефразируется
нужно ли в runtime java иметь доступ к информации о типах значений примитивов, объектов, параметрах и возвращаемых значениях методов

нужно кому?

статическая проверка выполнена компилятором ранее  на этапе compile time

в runtime управление выполнением принадлежит JVM

JVM оперирует над фактическими типами - типами экземпляров

instanceof для наследования
vtable + invokevirtual для полиморфизма (динамического связывания)


нужна ли информация о типах для выполнения скомпилированного байт кода?
зависит от содержания кода

если скомпилированный не содержит полиморфов, проверяемых приведений, рефлексии,
то есть типы предопределены в compile , и не могут измениться, то информация не нужна
стирание - type erasure

типизация массивов?
GC?

хранение
типы примитивов - в инструкциях байт кода
ссылки - в куче - заголовок объекта и указатель на экземпляр

информация о типах необходима JVM для проверки типов динамических операций
то есть для обеспечения полиморфизма


вопросы

хранение информации о типах в runtime - цена полиморфизма?
предположим, что в java нет приведения типов и наследования. нужны ли типы в runtime?
почему статический анализ не справляется с проверкой наследованных типов? приведения типов?
что значит массивы реифицированы?
рефлексия - уязвимость безопасности типов?



## вопросы

sealed interface ассоциируется с pattern matching, это связано с фиксацией множества классов-наследников и однозначностью выбора реализации?
switch не требует динамического связывания?
pattern matching - это оптимизация структуры условных операторов? и только?