# Родовидовые отношения в типах данных

> Родовидовые отношения в типах данных (см Логику) - Подтипы / Subtyping

Родо-видовые отношения - способ построения иерархии типов, построенный на идее обобщения и специализации
Род - общие признаки
Вид = род + видовые отличия
понятие вида полностью входит в объем понятия рода
все, что верно для рода, верно для типа, но не наоборот

надтип данных - пример рода
`Number` - род  по отношению к `Integer`
подтип данных - пример вида
`Integer` вид по отношению к `Number`

объем понятие Integer - целые числа в диапазоне от нижней до верхней границы в пределах 32 бит
видовое отличие - методы класса Integer, структура данных


Отношение подтипирования

типы S находятся в отношении подтипирования к типам T тогда и только тогда, 
когда множество значений типа S является подмножеством значений типа T

подтипированме - бинарное отношение, так имеет смысл только для пары элементов, определяя отношение подтипирования между элементами пары
подтипирование - правило совместимости - отвечает на вопрос -  можно ли выполнить подстановку s вместо t?
отношение подтипирования только описывает поведения типа, но не создает тип

пример
треугольник - это многоугольник с тремя сторонами
многоугольник - род
треугольник - вид - многоугольник с видовым отличием "3 стороны"

однако
подтипирование s по отношению к t является вхождением множества s в множество t
в системах типов, где 
типы интерпретируются как множества значений - денотационная семантика
значения неизменяемые
отсутствуют побочные эффекты


например , 
есть неизменяемые множества целых четных чисел и целых чисел
тогда 
четные целые входят в множество целых
и
четные целые - подтип целых

итого на практике:
подтипирования - это контракт поведения, то есть поведенческая совместимость в определенном контексте

---

в программировании
род - базовый тип
вид - специализированный тип
объём понятия - возможные значения переменной
видовое отличие - определенные методы, структура данных



мутабельность и ковариантность
является ли List<Integer> подтипом List<Number>?
зависит от реализации
если список неизменяемые, то является

вариантность - изменчивость
для двух значений

ковариантность - одно меняется, второе меняется в том же направлении
чтение

дана коробка яблок
поступает требование - взять коробку с фруктами
яблоки - подмножество фруктов
поэтому требование расширяет контекст, но не нарушает систему
поэтому контекстно безопасно взять коробку с яблоками

контрвариантность - одно меняется, второе меняется в противоположном направлении
запись

дан нож для фруктов
требование - нарезать яблоки
требование сужает контекст от фруктов к яблокам
используем более широкий тип ножа
требование выполнимо, так как нож для фруктов подходит для яблок


инвариантность - одно меняется, другое не зависит от изменения первого
чтение + запись

понятие Подтипа

дана пара типов (s, t)
первый элемент - s - подтип
второй элемент - t - надтип


такая подстановка описана принципом подстановки Барбары Лисков, буква L в аббревиатуре SOLID
- практически: значение типа s можно использовать в контексте, ожидающем тип t
- теоретически: если некоторое свойство, доказанное для объектов типа T, это свойство остается верным при подстановке значения типа S, то S является подтипом T

T - множество всех типов в рассматриваемой системе

(s, t) принадлежит декартову произведению T x T
то есть, s принадлежит T , t принадлежит T
если это условие выполняется, то отношение s к t является кандидатом на отношение подтипирования

итого
подтипирование - бинарное отношение на множестве типов T
подмножество декартова произведения T x T, состоящее из пар (s,t), для которых значение типа s можно подставить на место значения типа t


примеры
условие - в системе типов Integer является подтипом Number
множество типов T включает тип Number
значение t  имеет тип Number
значение s имеет тип Integer

тогда тип значения s является подтипом значения t
и значение s допустимо использовать в контексте, в котором допускается значение t


---

вопросы

- следует ли углубляться в свойства рефлексивности, транзитивности?
- «Если родовидовые отношения — это про включение объёмов, то всегда ли подтипирование можно смоделировать как включение множеств значений? Где эта модель ломается?»
- «Можно ли считать, что каждый тип в программе — это “вид” некоторого универсального “рода” (например, `Object`)? Что теряется при таком взгляде?»
- «Если я определю новый тип, добавив ограничения к существующему, — автоматически ли он станет его подтипом? Или нужно ещё проверять поведение?»
- «Аристотель говорил, что вид наследует все свойства рода. Как это соотносится с принципом замещения Лисков?»
