# Тип данных  
  
> Что такое тип данных. Как тип данных связан с данными и операциями.  
Я говорю не про конкретный тип (int/string), а вообще про само понятие Тип данных, именно предельно абстрактно,  
и так же предельно абстрактно и четко хочу услышать ответ, хоть и короткий, но четкий.  
  
## Аксиоматическое определение | Идея | Что это?  
  
тип - контракт между данными и программой об интерпретации и преобразовании информации, определяющий:  
- множество допустимых значений  
- множество допустимых операций  
- семантические правила, определяющие связь значений и операций  
  
  
## Прагматическое определение | Воплощение идеи | Для чего это?  
  
Типизация не является частью [парадигмы ООП](oop-idea.md)  
Типизация - свойство языка программирование  
  
  
## Как тип данных связан с данными и операциями.  
тип данных определяет область допустимых значений и операций  
  
данные - экземпляры значений, принадлежащих одному или нескольким типам  
  
операции - функции над значениями типа, сохраняющие семантику этого типа  
  
данные - это биты, тип говорит операциям как интерпретировать биты, без типа операция не имеет смысла  
  
например  
последовательность 8 бит  
01101010  
  
без типа - просто биты  
применим контракт типа целое число без знака,  
получим 106 и множество допустимых операций: сложение и тд  
  
если примем как char, получим букву 'j'  
примем как boolean[8] , получим массив из 8 булевых значений  
вывод - тип данных преобразует данные в информацию, то есть задает смысл  
  
  
## открытые типы (open в Kotlin) vs закрытые типы (sealed в Java)  
  
### Прагматика:   
контроль наследования - явное разрешение на расширение типа  
не принимать решение разрешить / запретить наследование => снижение риска ошибки проектирования  
если класс не open (final), связь методов происходит в compile time, не применяется динамическая диспетчеризация  
если класс не open, но наследуется => ошибка в compile time  
если класс не open, то программист уверен, что класс не переопределен, ошибку в наследниках можно элиминировать  
  
возможная проблема - использование класса в тестах, когда в тесте создается не экземпляр конкретного класса, а экземпляр наследника со структурой и поведением, отвечающим задаче теста  
[мок реализуем - Java - not final class](../../concepts/src/main/java/org/example/inheritance/MockOpen.java)  
[мок невозможен - Java - final class](../../concepts/src/main/java/org/example/inheritance/MockFinal.java)  
  
открытый тип - "открыт" означает - открыт для расширения (как в принципе OCP)   
то есть :  
open class может быть наследован  
open метод может быть переопределен  
открытость - договоренность о расширяемости, не влияет на свойства самого типа  
  
идея контроля наследования в Kotlin:   
по умолчанию классы закрыты для наследования, открываются модификатором open - `open class Smth {}`  
интерфейсы открыты для реализации всегда, не модифицируется - `interface IActionable`  
для наследования надо явно "открыть" класс, сделать not final - `open class Smth {}`  
  
open interface может быть расширен без ограничений  
[наследование классов в Kotlin по умолчанию (имитация на Java)](../../concepts/src/main/java/org/example/inheritance/NotificationKotlin.java)  
  
идея контроля наследования в Java:  
sealed interface может быть расширен явно указанными подтипами, переданными в permits `sealed interface INotifications permits EmailNotifications`  
то есть  
sealed interface - открыты, но ограничены: конкретными наследниками, областью видимости - доступны на уровне модуля  
[наследование типа в Java](../../concepts/src/main/java/org/example/inheritance/INotification.java)  
[наследование без ограничения Java - class](../../concepts/src/main/java/org/example/inheritance/EmailJavaOpen.java)  
[ограничение наследование Java - final class](../../concepts/src/main/java/org/example/inheritance/EmailJavaFinal.java)  
[ограничение наследование Java - sealed class](../../concepts/src/main/java/org/example/inheritance/EmailJavaSealed.java)  
  
в Java `class Something`, `interface IActionable` - по умолчанию открыты  
возможная проблема: наследование без контроля, в случае изменения базового класса может перестать работать код наследников, множество которых не определено, надо искать, отлаживать  
открыт  
[наследование классов в Java по умолчанию](../../concepts/src/main/java/org/example/inheritance/NotificationJava.java)  
  
  
## Связь между закрытыми типами (sealed) и pattern matching  
  
sealed определяет множество подтипов, которые могут реализовать (для классов) или расширить (для интерфейсов) базовый тип  
pattern matching сопоставляет объект с типом и извлекает значение объекта без явного приведения типа (cast)  
  
Прагматика:  
sealed предоставляет компилятору исчерпывающий перечень подтипов в permits  
pattern matching (в выражении switch) обеспечивает проверку подтипов из перечня в compile time => не требуется default, невозможны "неучтенные" типы  
  
[switch без sealed](../../concepts/src/main/java/org/example/inheritance/INotificationSwitchWithoutSealed.java)  
[switch с sealed](../../concepts/src/main/java/org/example/inheritance/INotificationSwitchWithSealed.java)  