
## Средства достижения цели
В качестве практики будет взята предметная область и запрограммировано приложение


# Практика

## Функциональные требования

Консольное приложение для управления банковскими счетами

реализующее операции: 
- открытие счета
- пополнение счета
- снятие со счета
- перевод со счета на счет
- проверка баланса счета
- закрытие счета


### CLI
- Ответы содержат:
    - `ok [сообщение]` - успех,
    - `err [сообщение]` - ошибка
- Общий синтаксис команд и ответов
    - комада [аргумент1 [аргумент2 [...]]
    - команда и аргументы разделяются пробелами
    - ok [сообщение]
    - err [сообщение]
- Аргументы разделяются **одиночными пробелами**

### Поддерживаемые команды и формат аргументов:

```text
open                                → создать новый счет (возвращает номер)
closeAccount <номер_счета>                 → закрыть счет
deposit <номер_счета> <сумма>       → пополнить счет
withdraw <номер_счета> <сумма>      → снять со счета
transfer <номер_счета> <сумма>      → перевести со счета на счет
balance <номер_счета>               → посмотреть баланс
list-accounts                                → вывести список всех открытых счетов
```

### Обработка ошибок
- `not found` - счет не существует
- `not enough funds` - недостаточно средств для снятия
- `invalid input` - некорректный ввод

### Тестирование
- Тесты пишутся **применительно к классу `BankAccountSystem`**
- CLI-ввод не тестируется
- Тесты должны **покрывать все требования первого комплекта**:
  - открытие, 
  - пополнение, 
  - снятие, 
  - баланс, 
  - закрытие

### Пример взаимодействия с приложением

```shell
> # закрытие счета → счета не существует → ошибка
> closeAccount 12
<err account not found

> # открытие счета → счета не существует → успех
> open
<ok 12

> # пополнение счета - id=12, +34 руб → счет существует → успех
> deposit 12 34
<ok

> # снятие - счет id=12, -43 руб → недостаточно средств → ошибка
> withdrawal 12 43
<err not enough funds

> # снятие - счет id=12, -31 руб → достаточно средств → успех
> withdrawal 12 31
<ok
```

---

## Проектирование

### Основные сущности

#### Счет

- Уникальный номер - UUID - тип `UUID`
  - нельзя открыть счет с уже существующим номером, если счет с существующим номер НЕ закрыт
- Баланс - вещественное число - тип `BigDecimal`
- Счет может быть открытым или закрытым
- Произвольное количество счетов

#### Пополнение счета
  - нельзя пополнить счет суммой 0 или меньше

#### Снятие со счета
  - нельзя снять денег, больше чем есть на балансе
  - снятие денег возможно при положительном балансе

#### Перевод со счета на счет
  - Равнозначно операциям снятия и пополнения

#### Заем/Кредит
#### Списание процентов по кредиту
#### Просрочка

---
Со счетом (не владельцем счета, а именно со счетом)
может быть связано 0 или более кредитов

Для одного счета есть лимит суммы всех активных кредитов, открыть новый кредит нельзя

Кредит может быть в двух состояниях:
- Активен (начальное) -средства со счета банка выделены на счет владельца
- Закрыт (конечное) -средства переведены со счета владельца на счет банка



### Диаграммы

- вычитать постановку,
- найти сущности в тексте и какие есть между ними операции,
- нарисовать отношения в виде диаграммы
  - Диаграмму состояний и/или диаграмму последовательности
    - определить для каждой операции какие сущности учавствуют
    - Как и в какой последовательности меняются
    - Определить (не) допустимость операций - т.е. проверки и отобразить на диаграмме
  - Операций должно быть 4, но сначала сделать 3 - надо для учебной задачи
    - Пополнение, Снятие, Перевод
    - Кредиты (допустим требование о них появилось во втором релизе)
    - То есть должно быть 2 комплекта диаграмм

- Диаграммы могут использоваться для двух разных языков
  - Первый для описания, что должно делать программа, но без учета специфики, ООП/Java
  - Второй будет уже специфика, возможно потребует по править первые диаграммы

---

#### Диаграмма классов


#### Диаграмма состояний

- начальное состояние: определяет, какие данные и условия считаются доступными к моменту старта

| Элемент                              | Описание                                                                 |
|--------------------------------------|--------------------------------------------------------------------------|
| Входные данные от внешних источников | Например, инициация события («запрос на регистрацию», «поступил заказ»). |
| Состояние внешней среды              | Например, сеть подключена, оборудование включено, база данных доступна.  |
| Параметры системы                    | Настройки, идентификаторы, права доступа (если они заданы до начала).    |
| Состояние хранилища данных           | Например, база пуста, но доступна для записи.                            |
| Временные метки                      | Текущее время, дата - могут быть использованы для инициализации.         | 

    > Пример: Система контроля доступа
    > **Событие**: «Пользователь подошел к двери».
    > **Доступные данные**:
    >     - ID карты (считано считывателем).
    >     - Время суток (для проверки действия пропусков).
    >     - Статус двери (закрыта, открыта, аварийно открыта).
    >     - Список разрешенных карт (из хранилища).
    > 
    > Начальное состояние: «Ожидание ввода карты»  
    > → Система готова проверить карту, если считыватель работает.

#### состояние/прямоугольник

1. Это не результат работы
2. Это условное **состояние памяти** компютера или "системы",
   - возможно оперативной памяти, возможно жесткого диска или комбинации

Состояние (прямоугольник) на диаграмме состояний включает:  
- имя состояния,  
- входные действия,  
- выходные действия,  
- длительные действия,  
- возможные подсостояния.

пример

```plaintext
[Работает]
  entry / запустить мониторинг подключения
  do / обновлять статус каждые 30 секунд
  exit / остановить поток мониторинга
```

В этом примере:
- **Имя состояния**: `Работает`
- **Входное действие**: `запустить мониторинг подключения`
- **Длительное действие (внутри состояния)**: `обновлять статус каждые 30 секунд`
- **Выходное действие**: `остановить поток мониторинга`


#### стрелки/переходы
- **условие** `смены состояния`/`выполнения перехода`
  - ответь на вопрос `что вызывает смену состояния?`
- **действие**
  - действие не равно функции/методу


> Ввод данных и вывод результата, это отдельная задача, не связанная с самой логикой, на диаграммах только логика, без связи с user interface и без связи с каким либо языком программирования

- формат `[условие] / [действие]`
- пример
```
[Пользователь ввел логин и пароль]
    ↓
[проверка данных] → [доступ разрешен] / [открыть доступ к кабинету]
```

> Условие: `логин и пароль верны`  
> Действие: `открыть доступ к кабинету`

---

### Результаты работы

[Диаграмма классов](../assignments/fin-calc/src/main/resources/docs/uml/class-diagram-financial-entities.md)
[Диаграмма состояний - реализация](../assignments/fin-calc/src/main/resources/docs/uml/state-diagram-financial-entities.md)

---

## Кодирование

---

### Классы операций

> Задача - применить понятие полиморфизма из ООП

#### Требования
- [ ] конструктор - _без проверок_
- [ ] метод выполнения операции - `perform`
- [ ] учти свзянные операции, например, `открытие счета` и `закрытие счета`

---
Сценарий - все операции валидны и успешны

- **Счет 1**: `1`, баланс: **5000.00 ₽**
- **Счет 2**: `2`, баланс: **3000.00 ₽**

| №   | Операция       | Параметры                                      | Ожидаемый результат                      |
|-----|----------------|------------------------------------------------|------------------------------------------|
| 1   | **Зачисление** | Сумма: 800.00, Счет-получатель: `1`            | Счет 1: **5800.00**                      |
| 2   | **Снятие**     | Сумма: 600.00, Счет-источник: `2`              | Счет 2: **2400.00**                      |
| 3   | **Перевод**    | Сумма: 1200.00, Источник: `1`, Получатель: `2` | Счет 1: **4600.00**, Счет 2: **3600.00** |
| 4   | **Зачисление** | Сумма: 450.00, Счет-получатель: `2`            | Счет 2: **4050.00**                      |
| 5   | **Снятие**     | Сумма: 900.00, Счет-источник: `1`              | Счет 1: **3700.00**                      |
| 6   | **Перевод**    | Сумма: 500.00, Источник: `2`, Получатель: `1`  | Счет 1: **4200.00**, Счет 2: **3550.00** |
| 7   | **Зачисление** | Сумма: 1100.00, Счет-получатель: `1`           | Счет 1: **5300.00**                      |
| 8   | **Снятие**     | Сумма: 1400.00, Счет-источник: `2`             | Счет 2: **2150.00**                      |
| 9   | **Перевод**    | Сумма: 750.00, Источник: `1`, Получатель: `2`  | Счет 1: **4550.00**, Счет 2: **2900.00** |
| 10  | **Зачисление** | Сумма: 300.00, Счет-получатель: `2`            | Счет 2: **3200.00**                      |

#### Минимум ООП

Задача - выполнить очередь опереаций
Условие - без ООП
Цель - увидеть преимущества полиморфизма и наследования

- Каждый объект в очереди это экземпляр класса, который не наследует
- Каждая операция это какой то метод объекта, каждый со своим именем
- Можешь использовать метод getClass и операцию class cast/приведение типов
- Запрещено наследование методов

##### Решение - Рефлексия

- определены два банковских счета
- определено множество операций: 
  - создание счета
    - параметры: баланс на счете при открытии счета,
  - зачисление на счет
    - параметры: сумма начисления, объект счета-получателя,
  - снятие со счета
    - параметры: сумма снятия, объект счета-источника,
  - перевод со счета на счет
    - параметры: сумма перевода, объект счета-источника, объект счета-получателя,
- определена очередь операций
  - очередь операций включает операции
    - зачисление на счет
    - снятие со счета
    - перевод со счета на счет
  - очередь операций представлена объектом коллекции
    - объект коллекции - экземпляр класса, реализующего интерфейс `Collection`
    - для решения применен класс `Queue` - в связи с близостью логики типа данных (FIFO) и проектируемой системы (очереди операций)
- определен цикл, в теле которого производится
  - извлечение операции из очереди
  - выполнение операции

###### Понятия
> Collection - интерфейс коллекций, существующих в Java
> Queue - класс, реализующий интерфейс Collection

###### Проблема
- каждая операция реализована отдельным классом без применения наследования, то есть
  - тип операции, соответственно, поля и методы операции, неизвестны до извлечение
- при извлечении операции требуется
  - определить принадлежащие операции поля и методы
  - выполнить метод
- гарантируется, что каждая операция содержит только один публичный метод
  - имя метода неизвестно заранее 
  - нельзя жестко привязать "если операция - экземпляр класса FinCalc.Deposit, то выполнять метод performDeposit"
  - можно выполнить существующий метод при условии, что он единственный существующий

> решаем задачу динамической диспетчеризации операций

##### Решение - Динамическая типизация

Цель: освоить динамическую типизацию
Задача: придумать типизацию, как если бы ее не было в Java

Условия:
- запрет на методы Class, Method...
- Используй доп информацию рядом с входными данными (объектами), а не внутри самих данных.
  - передать в очереди пару `(Имя операции, Тип операции)`
  - Тип указываешь как строку

###### Подход

- ограничение - в Java статическая типизация => реализация динамической типизации - имитация
- суть  - тип операции указываю явно при выполнении - то есть как будто код не был скомпилирован, но интерпретируется при выполении
- поскольку "компиляции не производилось", очередь не знает арибутов объекта, поступившего на выполнение
- задача - выполнить операцию, полученную из очереди
  - определить тип операции => понять, какие данные необходимо передать
    - с помощью `instanceof` определяю имя класса
    - реализация классов известна
      - вариант 1 - определить словарь "имя класса: имя метода"
        > не использует ООП принципов
      - вариант 2 - в каждом классе Операции использовать одно и то же слово для имени метода
        > приближает к полиморфизму
  - вызвать метод операции

[реализация - динамическая типизация](src/main/java/NoOop/OpsQueueDynamicTyping.java)

---

#### Полиморфизм

- как работает полиморфизм, 
- привести примеры, 
- что было бы если этот механизм отсутствовал при условии сохранения статической типизации 
  - (т.е. как бы ты выкручивался бы, см варианты type cast / class cast)
- определить понятия contains, aggregates, implements в задаче наследования
- Агрегация VS Наследование

##### Понятие и Понимание полиморфизма
- принцип ООП
- реализуется в Java с помощью `абстрактных классов`, `интерфейсов`, `суперклассов`
- дословно обозначает `возможность принимать множественные формы`

> что такое форма?
- форма - реализация поведения - пример: метод `выполнить`

> как кодируется форма?
- метод `perform` в классах 
  - [FinCalc.Deposit](../src/main/java/Deposit.java), 
  - [FinCalc.Withdrawal](../src/main/java/Withdrawal.java), 
  - [FinCalc.Transfer](../src/main/java/Transfer.java)
- метод носит одинаковое имя в трех разных классах - отсюда понимаем метод `perform` как единую сущность
- метод выполняет определенный для него в классе код - метод `perform` называется одним именем, но реализован по-разному
- каждая уникальная реализация метода `perform` - есть _форма_ метода `perform`

> как определить тип объекта, на который указывает ссылка?
- если считать типом объекта А имя класса, экземпляром которого является объект А, то тип объекта можно определить 
  - выполнением оператора `isinstanceof` - пример: `operation isinstanceof FinCalc.Deposit`
    - вернет `true`, если ссылка `operation` указывает на экземпляр класса `FinCalc.Deposit`
  - выполнением метода `Object.getClass()` - пример: `operation.getClass().getSimpleName()`
    - вернет `FinCalc.Deposit`, если ссылка `operation` указывает на экземпляр класса `FinCalc.Deposit`

##### Применение полиморфизма в текущей задаче
- есть класс Операции
- класс операции содержит метод выполнения операции `perform`
- от класса Операции наследуются классы Пополнение, Снятие, Перевод
- каждый метод-наследник переопределяет метод `perform` - то есть, реализует характерную процедуру выполнения
  - выполнение для Пополнения - добавление суммы Операции к балансу счета
  - выполнение для Снятия - вычитание суммы Операции из баланса счета
  - выполнение для Перевода - вычитание суммы Операции из баланса счета отправителя, добавление суммы Операции к балансу счета получателя

> Меня в этом описании, смущают общие слова. Мне прям описание требуется, механики

`FinCalc.Operation` - абстрактный класс  
абстракция здесь - общее для некоторых сущностей множество атрибутов  
таким - общим - атрибутом в `FinCalc.Operation` яаляется метод `perform`  
общим для кого?  
для классов-наследников  
классами-наследниками являются `FinCalc.Deposit`, `FinCalc.Withdrawal`, `FinCalc.Transfer`  
класс-наследник переопределяет родительский метод `perform`   
  - то есть реализует свой способ выполнения метода `perform`  
  - `способ выполнения` [выше](README.md:411) был назван `формой`  
  - полиморфизм - многоформие - гарантирует, что в каждом наследнике будет метод родителя, в данном примере - `perform`  
зачем наследовать, если реализация своя?  
наследовать, чтобы гарантировать наличие метода `perform` в множестве классов и их экземплярах  

один метод - `perform` - разные реализации `FinCalc.Deposit.perform`, `FinCalc.Withdrawal.perform`, `FinCalc.Transfer.perform`  
  
- Роль полиморфизма на этапе компиляции  
на этапе компиляции выполняется проверка синтаксиса, проверка типов, проверка графа наследования, пример:  
`FinCalc.Operation op = new FinCalc.Deposit(BigDecimal.valueOf(500.00));`  
- компилятор проверяет  
  - FinCalc.Deposit наследует FinCalc.Operation  
  - конструктор FinCalc.Deposit существует и принимает аргументы, заявленые в компилируемом коде - в данном случае экземпляр класса BigDecimal  
`op.perform(account)`  
- компилятор проверяет  
  - класс FinCalc.Operation, экземпляром которого является объект `op`, содержит метод `perform`  
  - компилятор сверяет ожидаемый принимаемый тип аргумента `perform` с типом фактически переданного объекта `account`  

- компилятор записывает в байт-код метод `FinCalc.Operation.perform()`  
  
- проявление полиморфизма  
  - на этапе выполнения (в райнтайме/runtime)  
  - реализацию метода выберет JVM   
- Как JVM знает, что op - это FinCalc.Deposit?  
  - для private методов - с помощью "статического связывания" - выбор реализации метода на этапе компиляции,  до выполнения программы  
  - для public методов - методов, которые могут быть переопределены - с помощью "динамического связывания" - на основе знания типа объекта  
  - динамическое связывание - это привязка ключ-значение, которые записываются в системную таблицу vtable  
  - пример vtable  

```text
vtable для класса FinCalc.Deposit:
[0]  Object.hashCode()
[1]  Object.equals()
[2]  Object.toString()
[3]  FinCalc.Operation.perform() → указатель на метод FinCalc.Deposit.perform()
```

  - при выполнении JVM читает имя класса - FinCalc.Deposit, находит в vtable связанный с ним метод FinCalc.Deposit.perform, выполняет FinCalc.Deposit.perform  
---

##### Динамика VS Статика

- дан код на языке программирования с динамической типизацией

```python
class A:
    def say_hello(self):
        print('hello from A')

class B:
    def say_hello(self):
        print('hello from B')

a = A()
a.say_hello()

a = B()
a.say_hello()
```
дает вывод
```text
hello from A
hello from B
```

- дан [такой же - уже не рабочий - код на java](../src/main/java/DemoTyping/MainBroken.java)
дает ошибку компиляции
```text
src/main/java/DemoTyping/MainBroken.java:6:11
java: variable a is already defined in method main(java.lang.String[])
```

- дан [похожий рабочий код на java](../src/main/java/DemoTyping/MainOperational.java)

> задача - развернуто объяснить механику возникновения ошибки


- рассмотрим код Python
```python
class A:  # объявление класса
    def say_hello(self):  # объявление метода - сигнатура
        print('hello from A')  # объявление метода - тело

class B:
    def say_hello(self):
        print('hello from B')

# A() - вызов инициализатора класса A -> создание экземпляра класса А
# при создании экземпляр класса А получает идентификатор - встроенный атрибут `id`
# `a = ` - создание ссылки `a`, ссылка `a` содержит `id` объекта - экземпляра класса А
a = A()
# вызов метода экземпляра класса А
a.say_hello()

# B() - вызов инициализатора класса B -> создание экземпляра класса B
# при создании экземпляр класса B получает идентификатор - встроенный атрибут `id`
# `a = ` - создание ссылки `a`, ссылка `a` содержит `id` объекта - экземпляра класса B
# `a` принимает значение id эземпляра класса B, 
#  таким образом, ссылка на экземпляр А потеряна, экземпляр A будет ликвидирован сборщиком мусора
a = B()  # переменная `a` теперь хранит id экземпляра класса B
# вызов метода экземпляра класса B
a.say_hello()
```

- рассмотрим корректный код Java

```java
public class MainOperational {
    public static void main(String[] args) {
        // new A() - вызов конструктора класса А -> создание экземпляра класса А
        // A a = - объявление переменной `a`, предназначенной для хранения ссылки на экземпляр класса A, установка ссылки на экземпляр класса A
        // аналогично для B
        A a = new A();
        B b = new B();

        // вызов метода объекта, ссылка на который содержит переменная `a`, `b`
        a.sayHello();
        b.sayHello();
    }
}
```

- рассмотрим некорректный код Java
```java
public class MainBroken {
    public static void main(String[] args) {
        // new A() - вызов конструктора класса А -> создание экземпляра класса А
        // A a = - объявление переменной `a`, предназначенной для хранения ссылки на экземпляр класса A, установка ссылки на экземпляр класса A
        A a = new A();

        // new B() - вызов конструктора класса B -> создание экземпляра класса B
        // A a = - объявление переменной `a`, предназначенной для хранения ссылки на экземпляр класса A
        // установка ссылки переменной для типа `A` на объект типа `B` -> недопустимая операция, 
        //  поскольку `a` предназначена только для указания на экземпляры `A`

//        A a = new B();  // строка, вызывающая ошибку компиляции

        //  можно создать новый экземпляр класса A - это работает, так как `a` определена для работы с A
        A a = new A();
        
        // дважды вызвать метода объекта, ссылка на который содержит переменная `a`
        a.sayHello();
        a.sayHello();
    }
}
```

---

- выполнить для некорректного кода
1) Что бы использовалась только одна переменная a
2) использовались оба объекта A, B
3) используй механизм полиморфизма, создай третий общий класс

- задача 
  - сохранить статическую типизацию, 
  - сохранить имена методов

[реализация](../src/main/java/DemoTyping/MainPoly.java)

---

- объяснить связь `ссылка на объект` и `vtable`

`ссылка на объект`
- определение - это объект, в одном из полей которого записана **адрес в памяти**, по которому располагается объект, на который указывает ссылка  
- задача - использовать один экземпляр объекта, не создавать копии для операций, выполняемых над объектом
- пример:
  - `A a = new A();`
  - new A() - выражение, выполняющее конструктор, создающий в памяти экземпляр класса A  
  - a - ссылка на созданные экземпляр класса A  
  - A - тип ссылки  

`невиртуальный метод`
- в Java - метод, который не может быть переопределен: (static ИЛИ final ИЛИ private)
- JVM вызывает `невиртуальный метод` **по типу ссылки на объект**

`виртуальный метод`
- в Java - метод, который может быть переопределен: НЕ (static ИЛИ final ИЛИ private)
- JVM вызывает `виртуальный метод` **по типу объекта**
- для определения "реального" метода, который в коде переопределен виртуальным, выполнение которого код требует от JVM,
JVM использует `vtable`

## жизненный цикл методов в java
### компилятор
- принимает исходный код (источники: файлы *.java)
- переводит исходный код на язык инструкций
  > ...
  > invoke virtual #myVirtMethod   // вызвать виртуальный метод
  > invoke static  #myStaticMethod // вызвать статический метод
  > ...
- записывает инструкции в формате `байт-кода JVM` - внутреннем формате виртульной машины Java
  - в байт-коде каждая инструкция представлена **одним** байтом
  - байт-код состоит из последовательности байтов
- байт-код может храниться в памяти, может быть записан в файлы *.class, может быть передан по сети, минуя запись на диск

---
исходный код с виртуальным и статическим методами
```java
package DemoTyping;

public class C {
    void sayHello() {
        System.out.println("hello from C");
        System.out.flush();
    }

    public static void sayStatic() {
        System.out.println("STATIC hello from C");
        System.out.flush();
    }
}
```

```java
package DemoTyping;

public class D extends C {
    @Override
    void sayHello() {
        System.out.println("hello from D");
        System.out.flush();
    }
}
```

```java
package DemoTyping;

public class MainPoly {
    public static void main(String[] args) {
        C c;

        c = new C();
        c.sayHello();
        C.sayStatic();

        c = new D();
        c.sayHello();
        D.sayStatic();  // sayStatic унаследован, не переопределен
    }
}
```

инструкции, сгенерированные компилятором из кода, прочитанного из файла `MainPoly.java`
```text
Compiled from "MainPoly.java"
public class DemoTyping.MainPoly {
  public DemoTyping.MainPoly();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public static void main(java.lang.String[]);
    Code:
       0: new           #7                  // class DemoTyping/C
       3: dup
       4: invokespecial #9                  // Method DemoTyping/C."<init>":()V
       7: astore_1
       8: aload_1
       9: invokevirtual #10                 // Method DemoTyping/C.sayHello:()V
      12: invokestatic  #13                 // Method DemoTyping/C.sayStatic:()V
      15: new           #16                 // class DemoTyping/D
      18: dup
      19: invokespecial #18                 // Method DemoTyping/D."<init>":()V
      22: astore_1
      23: aload_1
      24: invokevirtual #10                 // Method DemoTyping/C.sayHello:()V
      27: invokestatic  #19                 // Method DemoTyping/D.sayStatic:()V
      30: return
}
```

- `9: invokevirtual #10                 // Method DemoTyping/C.sayHello:()V`
  - команда вызова виртуального метода
- `12: invokestatic  #13                 // Method DemoTyping/C.sayStatic:()V`
  - команда вызова статического метода


### JVM
- принимает байт-код из источника (из памяти, файлов, сетевых подключений)
- проверяет байт-код
- загружает классы

`vtable`
- table - таблица, v - virtual
- синонимы: `virtual method table` / `VMT`, `dispatch table`
- сущность - структура данных
- функция - динамическое связывание
- задача - определить адрес в памяти, с которого начать выполнение

---


- объяснить понятие `виртуальный метод`
- объяснить хранение типа объекта во время исполнения / в runtime

---

- выделить ключевые мысли - [reddit - типизация с подсказками](https://www.reddit.com/r/Python/comments/10zdidm/why_type_hinting_sucks/)
- выделить ключевые мысли - [reddit - статическая типизация](https://www.reddit.com/r/programming/comments/141hzil/why_static_typing_came_back_richard_feldman/)



---

##### Обобщение

> почитать и осмыслить

- понятие `Родо-видовые понятия` из логики
- термины `sub-typing` и `ко-вариация` из программирования

---

В результате прочтения , того что я скинул должно появиться пара или больше абзацев, 
которые обощат опыт текущей задачи - полиморфизма

Обощение должно включать что общего между примером js, python и разного по ключевым вопросам.

Ключевой ... почему так по разному ведут два этих языка (1. Js, python, 2. Java) в вопросе полиморфизма и статич. типизации

Какие примущества и недостатки этих разных подходов дает тебе как программисту и тестировщику.

---

учти пару моментов
1) родо-видовые понятия это не сколько про полиморфизм, это **про типизацию - про родитель - потомок**
2) типизация не столько про формат данных, сколько **про ограничения и контроль формальных - "смысловых" ошибок**
3) полиморфизм - это частный случай реализации родо-видовых понятий
4) Барбара Листов из  SOLID - это "кривой перевод" этих понятий
5) Есть рядом стоящее понятие - Ко-вариация, так же активно используется в терминологии типизации - родо-видовые

---


### Результаты работы
