# Моделирование ООП  
  
# Шаг 1 - Лямбда-функции - базовые операции  
  
работы с лямбдами как с переменными  
  
а) определить/объявить переменную типа лямбды  
  
б) запись в переменную значения типа лямбды  
  
в) чтение значения типа лямбды из переменной - с целью выполнить метод  
  
г) передача значения типа лямбды из переменной в метод через стек   
-> передача указателя на функцию методу  
  
д) получение переменных / значений в результате вызова метода  
-> метод возвращает указатель на функцию  

[Лямбда-функции - базовые операции - код](../../java/org/example/oop_modeling/LambdasBasics.java)  
  
---
  
# Шаг 2 - Моделирование Вызова метода по сигнатуре  
  
Реализовать метод, который:  
  
принимает на вход значение типа Object, которое может содержать указатель на лямбда-функцию  
  
выполняет явное приведение типа к сигнатуре  
  
Выполнением метода получить результаты:   
  
а) downcast выполнен, метод возвращает значение  
б) downcast провален, метод генерирует исключение  

[Лямбда-функции - базовые операции - код](../../java/org/example/oop_modeling/MethodModel.java)

---
  
# Шаг 3 - моделирование Объекта   
> WIP  
  
Моделирование объекта Animal в стиле JavaScript - Мар<String,Object>  
  
Их содержание это  
1. Данные  
2. Ссылки на методы  
   Вызов должен происходить так:  
   • var obj = newAnimal()  
   • callingAnimal(obj)  
   в обоих случаях вызываются методы  
   один возвращает Мар<String,Object>  
   другой получает Мар<String,Object>  
  
Задача 1  
1) Эмуляция оператора new   
- создать метод который вернет новый объект класса Animal, тип объекта Мар<String,Object>  
  
2) Вызвать у объекта метод makeSound()   
ожидаем ответ Some sound  
Объект Мар<String,Object> должен содержать значение makeSound, Тип значения Runnable  
  
  
  
---  
  
  
# Шаг 4 - моделирование Полиморфизма  
Продолжение первой задачи  
Добавить метод newDog() - конструтор объекта класса Dog, который также возвращает Мар<String,Object>  
Создать объект dog  
Не меняя реализацию callingAnimal передать объект dog, ожидаем ответ Bark  
  
# Шаг 5 - моделирование this и данных  
  
Задача смоделировать работу ООП в стиле Javascript в аспектах:  
• Чтение данных объекта  
• Изменение данных объекта  
• Использование данных объекта с учетом типа  
  
Надо:  
• Создать конструктор возвращающий данный объект тип javascript Мар <String,Object>, с инициализированным значением и таблицой Vtable  
• вычислить квадрат (вызов метода)  
◦ реализация должна прочитывать value  
• Установить новое значение и вычислить квадрат  
• Установить не допустимое значение (string или другой тип) и попытаться вычислить квадрат  
всё взаимодействие с объектом должно проходить через его методы  
Сигнатуры методов  
Понимание различных сигнатур методов  


---

# вопросы

## Шаг 2

подозреваю ошибку в коде - в getLambda передается value, но не используется

пункты г и д работают некорректно



проговариваю понимание операций в А-Д:

начало  
v  
**а**  
объявление переменной типа функционального интерфейса: `IIntegerAction lambdaN`, интерфейс определяет метод `perform`  
v  
**б**  
инициализация переменной лямбда-выражением `lambdaN = n -> n*n`  
v  
**в**  
переменная ссылается на объект, реализующий функциональный интерфейс,   
поэтому возможно вызвать метод функционального интерфейса, обратившись `переменная.метод` -> `lambdaN.perform()`  
это чтение значения (т.е. чтение лямбда-выражения + вызов метода, которые реализует лямбда-выражение)  
v  
**г**  
создаю метод, принимающий значение типа функционального интерфейса, значение типа int (аргумент для передачи в лямбду)   
и возвращающий значение того же типа: `IIntegerAction getLambda(IIntegerAction action, int value)`
```java  
    // getLambda(F, Z) -> F  
    // value сейчас не обрабатывается: F -> F  
    public static IIntegerAction getLambda(IIntegerAction action, int value) {  
        return action;  
    }  
```  
переделал


=> переменная <- лямбда-выражение  
т.е.  
=> переменная типа интерфейса содержит ссылку на объект, удовлетворяющий требованиям интерфейса  
объект содержит один метод с определенной сигнатурой

=> перечисленные свойства делают функцию

v  
**д**  
объявляю переменную типа функционального интерфейса `IIntegerAction`  
инициализирую методом, который возвращает применение лямбда-выражения к значению  
`IIntegerAction calcSquare = getLambda(lambdaN, 8)`  
вызываю метод  
`calcSquare.perform(5)`

та же задача решается на шаге "в", что отличает шаг "д", почему он необходим?

задача "д" - модификация поведения "в"?  


нет понимания модели  
какое поведение ООП моделирует каждый шаг?