
# абстракция
есть физический объект, в реальном мире

пример:
банкомат, "физический" объект, то есть, сущность, с которой напрямую взаимодействуют люди
с атрибутами id, владелец, даты, ...
со множеством допустимых операций - зачисление, списание ...
банкомат можно рассмотреть как собственность банка, как предмет интерьера, инструмент для управления балансом счета
каждое представление требует множество атрибутов из числа существующих, но не все:
для управления балансом пользователю не важен цвет и масса банкомата

абстракция 
- оставление характеристрик, необходимых для решения задачи
- исключение невлияющего на решение поставленной задачи, упрощение
- создание черного ящика - знаем вводные, знаем результат, не грузим голову содержимым ящика



дана задача - управлять банковским счетом с помощью банкомата
банкомат как финансовая абстракция

пример:
банкомат для управления счетом - важны соединение с банком, устройства ввода/вывода, кассета с деньгами, доступность действий по аутентификации, внесению/снятию наличных, ...

контрпример:
банкомат как предмет интерьера - важны габариты, цвет... - иной набор характеристик, это другая абстракция, не подходит для решения поставленной задачи, но может быть создана для другой задачи


# Инкапсуляция, private, protected... какая польза и как тестировать инкапсулированное поведение

инкапсуляция - методология защиты объекта с помощью сокрытия полей и реализации методов, дающих функционал из требований

## инструмент абстракции
абстракция разделяет сущности на важные и неважные в контексте задачи
инкапсуляция реализует важные

пример
дает конкретное решение - списать средства вместо получить баланс, посчитать, записать баланс


## проблема 1 - безопасность состояния
защита от изменения данных внешним кодом

механизм решения - скрыть поля -> запретить чтение и запись напрямую
в java доступ к полям управляется инструкциями уравней доступа public, private, package-private, protected

чтение и запись выполнять методами, объявленными в интерфейсе

кто, откуда, как обращается к данным - если доступ открыт - дорого разбираться


## проблема 2 - управляемость кодом

изменение требований -> экспоненциальный рост точек отказа

если есть 100500 методов в 100 модулях, которые работают с состоянием, то при изиенении требований,
например, множество значений поля (были все int, стали только >0), придется изменять логику 100500 методов в 100 модулях
ошибка в этой работе неизбежна, будет нежданный косяк

## проблема 3 - использование не по инструкции

определить поля и методы таким образом по принципу "что не разрешено, то запрещено" / белый список

## проблема 4 - надежность кода, ответственность программиста

### инкапсуляция + наследование реализации => наследование класса
хрупкость при изменении базового класса
изменится реализация родителя - может отвалиться наследник

пример
зависимость от типа значения при обращении напрямую

### инкапсуляция + наследование интерфейса => подтипизация
взаимодействие через контракт - методы
надежность 
локализация ответственности повышает надежность -
доступ разрешен только в специальных методах, 
в которых программист проверяет требования, логика защищена
программисту легче контролировать значения, состояние
