# Спецификация

## динамическая типизация
- переменная может содержать объект любого типа
- значение переменной может меняться на значение любого типа
- ошибки взаимодействия типов обнаруживаются в runtime
- мотивация к примененению в Lox - быстрая реализация интерпретатора относительно реализации со статической типизацией

## автоматическое управление памятью
- автоматическое здесь значит - не требующее явного вызова инструкций управления памятью - например, free()
- две основные техники управления памятью
  - счет ссылок - проще в реализации, имеет ограничения - какие ? TODO
  - сборка мусора с отслеживанием
- счет ссылок - часть процесса сборки мусора
- в Lox реализуется сборка мусора

## типы данных
- преобразование типов явное
- Boolean - логический
  - eBNF
    ```
    Boolean :== true|false
    ```
- Numbers - числа двойной точности с плавающей точкой
  - тип реализует целые числа и десятичные дроби: `123`, `12.3`
  - eBNF
    ```
    Number :== {digit} [.] {digit}
    digit :== "0" | "1" | "2" | "3 | "4" | "5" | "6" | "7" | "8" | "9"
    ```
- Strings - последовательность символов в двойных кавычках
  - eBNF
    ```
    String :== "{Char}"
    Char :== {a-zA-Z0-9}
    ```
- Nil - представляет `отсутствие значения`
  - автор:
    > в динамической типизации лучше ввести понятие Отсутствие значения, чем пытаться избежать его использования
  ? почему?
- правила типов данных - eBNF
  ```
  var :== Nil | String | Number | Boolean
  Boolean :== true|false
  Number :== {digit} [.] {digit}
  String :== "{char}"
  digit :== "0" | "1" | "2" | "3 | "4" | "5" | "6" | "7" | "8" | "9"
  char :== {a-zA-Z0-9}
  Nil :== null 
  ```

## выражение === expression
> аналогия: типы данных и литералы типы данных есть молекулы, выражения есть молекулы
- expression создает значение - value
- арифметические - 4 базовые операции
  - все операторы поддерживаются только типом Number
  - String поддерживает `+` как операцию конкатенации строк
  - все операторы infix - то есть, располагаются между первым и вторым операндами
  - `-` может быть prefix - в случае использования для отрицания значения: `-value`
  - eBNF
    ```
    Operation :== String "+" String
    Operation :== Number operator Number
    Operation :== "-" Number
    operator :== "+" | "-" | "*" | "/"
    ```
- сравнение и равенство
  - возвращают тип Boolean
  - сравнение
    - выполняется только для значений типа Number
  - равенство и неравенство выполняется для значений типов Boolean, Number, String
  - результат операции равенства для значений разных типов всегда возвращает `false`
  - eBNF
    ```
    Operation :== Number comparisonOp Number
    Operation :== var equalityOp var
    comparisonOp :== "<" | ">" | "<=" | ">="
    equalityOp :== "==" | "!="
    ```
      
- логические операторы
  - отрицание: `!`
  - логическое И: `and`
  - логическое ИЛИ: `or`
  - операторы short-circuit - "ленивые": 
    - true or false -> true - значение второго операнда не проверяется
    - false and true -> false - значение второго операнда не проверяется
  - eBNF
    ```
    Operation :== Number comparisonOp Number
    Operation :== var equalityOp var
    comparisonOp :== "<" | ">" | "<=" | ">="
    logicalOp :== "!" | "and" | "or"
    ```
- приоритеты и группировка операций
  - приоритеты операций идентичны приоритетам аналогичных операций в языке C
  - для группировки используются круглые скобки
  - eBNF
    ```
    Operation :== Number comparisonOp Number
    Operation :== var equalityOp var
    comparisonOp :== "<" | ">" | "<=" | ">="
    groupingOp :== "(" | ")"
    ```
- операторы, которые не поддерживаются:
  - побитовые операции
  - операции битового сдвига
  - остаток от деления | modulo
  - условные операторы

## Утверждение === Statement
- statement создает действие - effect
  - примеры действий: изменение состояния объектов, чтение ввода, выполнение вывода
  - утверждения оканчиваются `;`
  - утверждение, содержащее выражение+ называется expression statement

## Переменная === Variable
- объявление переменной обозначается ключевым словом `var`
- язык поддерживает области видимости - область видимости ограничивается фигурными скобками `{}`

## Управление потоком выполнения
- if (condition) { ...; } else { ...; }
- while (condition) { [...;]* }
- for (init, condition, incr) { [...;]* }

## Функции
- язык является динамически типизируемым => нет разделения на объявление | declaring и определение | defining функции
  - объявление функции - связывание имени функции и типа значения, возвращаемого функцией
  - определение функции - логика, выполняемая функцией, код тела функции
- синтаксис близок к синтаксису C и Java
- вызов функции выполняется выражением `имяФункции();`
- литерал `имяФункции` является ссылкой на функцию
- ключевое слово для объявления функции - `fun` - `fun имяФункции() { ...; }`
- аргумент - действительный параметр - конкретное значение, передаваемое функции при вызове функции
- параметр - формальный параметр - переменная, содержащее значение аргумента, существующая в теле функции
- ключевое слово для возвращения значения функции - `return`
- при успешном выполнении тела функции, не содержащей `return`, функция возвращает `nil`
- функции - объекты первого класса - функции могут быть значениями переменных, функции - ссылочные объекты
- объявление функции есть утверждение | statement => допускается объявление функции в теле другой функции => поддерживается механизм замыканий

## ООП
- основные концепты - класс и экземпляр класса
- экземпляр хранит состояние экземпляра и ссылку на класс экземпляра
- класс описывает методы и цепь наследования
- в Lox применяются классы
- автор - мотивация реализации классов в Lox 
  - возможность создания составных типов данных
  - тематическая группировка функций относительно применяемой сущности - реализация в виде методов класса
- классы являются объектами первого класса
- методы объявляются аналогично функциям, но без ключевого слова `fun`
- механика классов:
  - вызов `Класс();` выполняет функцию конструктора | factory function
  - может быть объявлен инициализатор - метод `init`
    - аргументы, переданные вызову `Класс();`, передаются как аргументы методу `init`
  - присвоение значения несуществующему полю класса создает это поле
  - классы поддерживают наследование
    - максимум два класса в цепи наследования
    - наследование обозначается `<`
- значения примитивов не являются экземплярами классов, определяемых языком Lox
```
class Ticket {
  init(id, name) {
    this.id = id;
    this.name = name;
  }
  
  validate() {
    print "Доброго пути " + this.name + "!"
  }
}

var myTicket = Ticket("1", "Bob");
myTicket.validate(); // Доброго пути, Bob!

myTicket.seat = "10A";

class TrainTicket < Ticket {
  addПостельное() {
    print "Купить постельное белье";
  } 
```
- ссылка на экземпляр внутри экземпляра по слову `this`
> прототипирование - иной подход к ООП
>   Понятия Класс не существует, существует Объект
>   Объекты описывают и состояние, и методы, 
>   объекты наследуются - или, делегируются - напрямую другими объектами
